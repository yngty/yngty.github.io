[{"title":"C++ Class layout","url":"/2024/01/22/c++/C-Class-layout/","content":"C++ Class在类定义中，只有非静态数据声明会增加类对象的大小\nEmpty Class一个空类在C++中没有非静态数据成员、没有虚函数，也没有虚基类。这样的类通常被称为“无状态”，因为它们不封装任何状态或数据。然而，即使一个空类没有显式的数据成员，它仍然需要占用一些内存空间。\nC++标准规定，不同类型的对象必须具有不同的地址。因此，一个空类对象必须在内存中具有唯一的地址。这确保了即使一个空类对象没有任何可见的数据成员或行为，它也必须占用至少一个字节的内存，以区分它与具有不同类型的其他对象。\n\nC++20 no_unique_addressEmpty Base Class空基类优化（Empty Base Class Optimization，EBCO）\n\n对于多重继承，重新排列基类的顺序以便空基类首先出现在基类列表上通常是有意义的。\nC++ 标准并没有规定编译器必须对空基类进行存储优化\n\n标准布局类\nC++ 只为标准布局类型提供布局保证\n标准布局类型本质上是一种C类型:\n标量类型(算术、枚举或指针类型)\n具有标准布局类型元素的数组\n一个标准布局类(可能声明为结构或联合)\n\n\n\n标准布局类可以具有:\n\n无虚函数或虚基类\n标准布局类类型的零个或多个基类。\n没有两个相同类型的基类\n标准布局类型的零个或多个非静态数据成员，例如:所有成员具有相同的访问控制，并且\n所有成员都声明在最派生的类中或在同一个基类中标准布局类- 可以具有非虚和静态成员函数、静态数据成员和嵌套类型\n\n布局保证关于标准布局类的布局，C++ 只保证:\n\n第一个非静态数据成员位于偏移量为零\n这意味着将指向标准布局类对象的指针 reinterpret_cast 转换为指向其第一个非静态数据成员的指针是合理的\n每一个后续的非静态数据成员的偏移量都大于在它之前声明的非静态数据会员的偏移量\n类的对象存储在连续内存中\n\n","categories":["C/C++"]},{"title":"C++ aggregate","url":"/2024/01/08/c++/C-aggregates/","content":"什么是聚合类型(aggregate)在 C++03 中的定义\n不能有用户声明的构造函数\n没有私有或受保护的非静态数据成员，可以拥有任意数量的私有和受保护的成员函数（但不能是构造函数）以及任意数量的私有或受保护的静态数据成员和静态成员函数\n可以具有用户声明或用户定义的复制赋值运算符和或析构函数\n没有基类\n没有虚函数\n数组是聚合，即使它是非聚合类类型的数组\n\n\n聚合的作用可以使用 &#123;&#125; 初始化数组初始化Type array_name[n] = &#123;a1, a2, …, am&#125;;\n\n\nm &#x3D;&#x3D; n\n数组的第 i 个 元素用 ai 初始化\n\n\nm &lt; n \n数组的前 m 个元素用 a1、 a2…am 初始化\n剩下的 n - m 个元素使用值初始化\n标量类型对象用 0初始化\n具有用户声明的默认构造函数的类类型的对象被值初始化时，将调用其默认构造函数\n隐式定义默认构造函数，则所有非静态成员都会递归地进行值初始化，(成员是引用的会初始化失败)\n\n\n\n\nm &gt; n\n编译报错\n\n\n\nclass A&#123;public:  A(int) &#123;&#125; //no default constructor&#125;;class B&#123;public:  B() &#123;&#125; //default constructor available&#125;;int main()&#123;  A a1[3] = &#123;A(2), A(1), A(14)&#125;; //OK n == m  A a2[3] = &#123;A(2)&#125;; //ERROR A has no default constructor. Unable to value-initialize a2[1] and a2[2]  B b1[3] = &#123;B()&#125;; //OK b1[1] and b1[2] are value initialized, in this case with the default-ctor  int Array1[1000] = &#123;0&#125;; //All elements are initialized with 0;  int Array2[1000] = &#123;1&#125;; //Attention: only the first element is 1, the rest are 0;  bool Array3[1000] = &#123;&#125;; //the braces can be empty too. All elements initialized with false  int Array4[1000]; //no initializer. This is different from an empty &#123;&#125; initializer in that  //the elements in this case are not value-initialized, but have indeterminate values   //(unless, of course, Array4 is a global array)  int array[2] = &#123;1, 2, 3, 4&#125;; //ERROR, too many initializers&#125;\n类初始化\n按照非静态数据成员在类定义中出现的顺序（根据定义它们都是公共的）来初始化非静态数据成员\n\n如果初始化器的数量少于成员，则其余的将进行值初始化\n\n如果无法对未显式初始化的成员之一进行值初始化(例如成员是引用)，则会出现编译时错误\n\n如果初始化程序多于必要的数量，我们也会收到编译时错误\n\n对于聚合联合只能用大括号初始化它们的第一个成员\nstruct X&#123;  int i1;  int i2;&#125;;struct Y&#123;  char c;  X x;  int i[2];  float f; protected:  static double d;private:  void g()&#123;&#125;      &#125;; Y y = &#123;&#x27;a&#x27;, &#123;10, 20&#125;, &#123;20, 30&#125;&#125;;\n\nC++11 的变化不能有用户提供的构造函数以前聚合不能有用户声明的构造函数，但现在它不能有用户提供的构造函数。\nstruct Aggregate &#123;  Aggregate() = default; // 在 C++11 仍然是聚合类型&#125;;\n不能为非静态数据成员提供任何大括号或等号初始化程序struct NotAggregate &#123;  int x = 5; // valid in C++11  std::vector&lt;int&gt; s&#123;1,2,3&#125;; // also valid&#125;;\n\nC++14 的变化允许类内成员初始值 N3605: Member initializers and aggregates\n// 在C++11 不是聚合，在C++14 是聚合struct Aggregate&#123;  int a = 3;  int b = 3;&#125;;\n\nC++17 的变化C++17 扩展并增强了聚合和聚合初始化。标准库现在还包含一个 std::is_aggregate 类型特征\n聚合类现可以具有公共的非虚拟基类。在新的扩展中，如果类存在继承关系，则额外满足以下条件：\n\n必须是公开的基类，不能是私有或者受保护的基类\n必须是非虚继承\n\n此外，不要求基类是聚合的。如果它们不是聚合，则它们是列表初始化的。\n聚合类的初始化顺序是按基类的声明顺序，然后按不是匿名联合成员的直接非静态数据成员声明顺序\nstruct B1 // 不是聚合类，有用户提供的构造函数&#123;    int i1;    B1(int a) : i1(a) &#123; &#125;&#125;;struct B2&#123;    int i2;    B2() = default;&#125;;struct M // 不是聚合类，有用户提供的构造函数&#123;    int m;    M(int a) : m(a) &#123; &#125;&#125;;struct C : B1, B2&#123;    int j;    M m;    C() = default;&#125;;C c &#123; &#123; 1 &#125;, &#123; 2 &#125;, 3, &#123; 4 &#125; &#125;;cout    &lt;&lt; &quot;is C aggregate?: &quot; &lt;&lt; (std::is_aggregate&lt;C&gt;::value ? &#x27;Y&#x27; : &#x27;N&#x27;)    &lt;&lt; &quot; i1: &quot; &lt;&lt; c.i1 &lt;&lt; &quot; i2: &quot; &lt;&lt; c.i2    &lt;&lt; &quot; j: &quot; &lt;&lt; c.j &lt;&lt; &quot; m.m: &quot; &lt;&lt; c.m.m &lt;&lt; endl;//输出: is C aggregate?: Y, i1=1 i2=2 j=3 m.m=4\n\n没有用户提供的、显式的或继承的构造函数\n不允许显式构造函数\nstruct D // not an aggregate&#123;    int i = 0;    D() = default;    explicit D(D const&amp;) = default;&#125;;\n不允许继承构造函数\nstruct B1&#123;    int i1;    B1() : i1(0) &#123; &#125;&#125;;struct C : B1 // not an aggregate&#123;    using B1::B1;&#125;;\n\n扩展聚合类型的兼容问题例如以下代码:\n#include &lt;iostream&gt;#include &lt;string&gt;class BaseData &#123;  int data_;public:  int Get() &#123; return data_; &#125;protected:  BaseData() : data_(11) &#123;&#125;&#125;;class DerivedData : public BaseData &#123;public:&#125;;int main()&#123;  DerivedData d&#123;&#125;;  std::cout &lt;&lt; d.Get() &lt;&lt; std::endl;&#125;\n在 c++17 之前 DerivedData 不是聚合类型，所以会调用 DerivedData 的默认构造函数然后，调用 BaseData 的默认构造函数，虽然这里 BaseData 声明的是受保护的构造函数，但派生类是可以调用的，但在 C++17 之后发送了变化，DerivedData 是一个聚合类型，基类 BaseData 中的构造函数是受保护的关系，它不允许在聚合类型初始化中被调用导致编译失败，我可以可以通过添加一个默认构造函数使其不是聚合类型解决该问题。\nC++20 的变化没有用户声明或继承的构造函数又改回没有用户声明的构造函数了。因为没有用户定义的构造函数有时候会导致一些误会，例如下面的情况：\n#include &lt;iostream&gt;struct X &#123;  X() = default;&#125;;struct Y &#123;  Y() = delete;&#125;;int main() &#123;  std::cout &lt;&lt; std::boolalpha       &lt;&lt; &quot;std::is_aggregate_v&lt;X&gt; : &quot; &lt;&lt; std::is_aggregate_v&lt;X&gt; &lt;&lt; std::endl      &lt;&lt; &quot;std::is_aggregate_v&lt;Y&gt; : &quot; &lt;&lt; std::is_aggregate_v&lt;Y&gt; &lt;&lt; std::endl;&#125;// 输出: std::is_aggregate_v&lt;X&gt; : true//      std::is_aggregate_v&lt;Y&gt; : true\n\nY y1;   // 编译失败Y y1&#123;&#125;; // 编译成功\n除了删除默认构造函数，将其列入私有访问中也会有同样的问题，所以 C++17 增加了 explicit 修饰的构造函数，该类不是聚合类，但没有解决相同类型不同实例化方式表现不一致的尴尬问题。最后在 C++20 标准中禁止聚合类型使用用户声明的构造函数。\n初始化\n聚合类型对象的初始化可以用小括号列表来完成，其最终结果与大括号列表相同\n另外带大括号的列表初始化是不支持缩窄转换的，但是带小括号的列表初始化却是支持缩窄转换的\n\nstruct X &#123;  int i;  short f;&#125;;int main() &#123;    X x2&#123;1, 7.0&#125;; // 编译失败，7.0 从 double 转换到 short 是缩窄转换    X x2(1, 7.0); // 编译成功， c++20 之前，编译失败&#125;\n值得注意的是，这个规则的修改会改变一些旧代码的意义，比如我们经常用到的禁止复制构造的方法：\nstruct X &#123;  std::string s;  std::vector&lt;int&gt; v;  X() = default;  X(const X&amp;) = delete;  X(X&amp;&amp;) = default;&#125;;\n在 C++20 中 X 不是聚合类，一个可行的解决方案是不要直接使用 delete 来删除复制构造函数，而是通过加入或者继承一个不可复制构造的类型来实现类型的不可复制。\nstruct X &#123;  std::string s;  std::vector&lt;int&gt; v;  [[no_unique_address]] NonCopyable nc;&#125;;// 或者struct X : NonCopyable &#123;  std::string s;  std::vector&lt;int&gt; v;&#125;;\n\n参考资料\nWhat are aggregates and trivial types&#x2F;PODs, and how&#x2F;why are they special?\n现代 C++ 语言核心特性解析\n\n","categories":["C/C++"]},{"title":"C++ 中 malloc 和 new 的区别","url":"/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n\n\n特征\nnew\nmalloc\n\n\n\n类型\n关键字\n标准库函数\n\n\n支持语言\nC/C++\n只在 C++\n\n\n申请内存的位置\n自由存储区 free store\n堆\n\n\n分配内存的大小\n编译器根据类型信息自行计算\n显示指定字节数\n\n\n内存分配失败\n抛出 bac_alloc 异常, 不会返回 NULL\n返回 NULL\n\n\n返回类型\n返回对象类型的指针\n返回void 指针，需要转换\n\n\n是否调用构造函数&#x2F;析构函数\n调用\n不调用\n\n\n处理数组\nnew[]\n手动指定数组的大小\n\n\n是否支持重载\n支持\n不支持\n\n\n是否支持内存扩充\n不支持\nrealloc\n\n\n内存释放方式\nnew/delete, new[]/delete[]\nmalloc/free\n\n\n","categories":["C/C++"],"tags":["C++"]},{"title":"c++ Memory Order","url":"/2023/11/07/c++/c-Memory-Order/","content":"背景高级语言经过编译器将源码转为机器指令运行，其中的运行顺序和代码中的顺序有很大差异，主要是下面三个原因: \n\n编译器重排\nCPU 乱序执行\n存储器硬件设计，不同线程看到的顺序不一致。\n\n在 c++ 中线程同步只有两种方式：\n\n原子变量进行同步\n锁(Mutex)\n\n这里我们主要讨论原子变量的操作。\nMemory OrderC++11 规定了六种不同的 memory order:\n\nRelaxed\nConsume\nAcquire\nRelease\nAcquire-Release\nSequential Consistent\n对应着 std::memory_order 枚举值:\nstd::memory_order_relaxed\nstd::memory_order_consume\nstd::memory_order_acquire\nstd::memory_order_release\nstd::memory_order_acq_rel\nstd::memory_order_seq_cst\n\n对一个原子变量操作时可以传入一个  std::memory_order 枚举，指明这个原子操作需要满足的 memory order。没有传入默认为 std::memory_order_seq_cst。\nRelaxed最弱内存序，单纯的原子操作，没有线程间同步节点的作用。即：\n\n在一个 relaxed 写操作之前的写操作, 将不保证能被其他也对同一个原子变量的 relaxed 读操作看到。\n在一个 relaxed 读操作之后的读操作, 也不保证能看到被其他也对同一个原子变量的 relaxed 写操作之前的写操作。\n\nConsumeConsume 仅对原子读操作有效。\n我们首先理解什么是操作数之间的数据依赖: \n对于操作 A 和操作 B，如果操作 A 先于操作 B 发生，则有三种情况会使得操作 B 数据依赖于 操作 A：\n\nA 的值被用作 B 的运算数，除了\nB 是对 std::kill_dependency 的调用\nA 是内建 &amp;&amp;、||、?: 或 , 运算符的左运算数。\n\n\nA 写入标量对象 M，B 从 M 读取\n存在第三个操作 X 数据依赖于操作 A，操作 B 又数据依赖于操作 X\n\nacquire 要求线程 B 能够看到线程 A 中在 release 操作之前的具有数据依赖关系的写操作\nAcquireAcquire 仅对原子读操作有效。acquire 与 consume 唯一的区别是 acquire 要求线程 B 能够看到线程 A 中在 release 操作之前的所有写操作，而不仅仅是与写原子变量具有数据依赖关系的写操作。\nReleaseRelease 仅对原子写操作有效。Release 操作通常是与 consume 或 acquire 操作配对的。\nAcquire-Release\n对于一个原子读操作，该操作都是 acquire 操作\n对于一个原子写操作，该操作是 release 操作\n对于一个既有读又有写的原子操作，该操作既是 acquire 操作也是 release 操作, 例如 compare-and-swap 操作、read-modify-write&#96; 操作\n\nSequential Consistent\n对于一个原子读操作，该操作都是 acquire 操作\n对于一个原子写操作，该操作是 release 操作\n对于一个既有读又有写的原子操作，该操作既是 acquire 操作也是 release 操作\n程序内所有线程在使用 sequential consistent 操作原子变量时，必须以一致的顺序看到程序内的所有 sequential consistent 操作\n\n实现方式在 x86_64平台主流实现方式：\n\n限制线程同步节点前后的代码重排\nConsume\n所有的在 release 操作之前的、与 release 操作具有数据依赖关系的写操作不能被移动到 release 操作之后\n所有的在 consume 操作之后的、与 consume 操作具有数据依赖关系的读操作不能被移动到 consume 操作之后\n\n\nAcquire\n所有的在 release 操作附近之前的写操作不能被移动到 release 操作之后\n所有的在 acquire 操作附近之后的读操作不能被移动到 acquire 操作之前\n\n\nRelease\n所有在 release 操作附近之前的写操作均不能被移动到 release 操作之后\n\n\nAcquire-Release\n所有的在 acquire-release 操作附近之前的写操作不能被移动到 acquire-release 操作之后\n所有的在 acquire-release 操作附近之后的读操作不能被移动到 acquire-release 操作之前\n\n\n\n\n利用硬件特性，生成带 lock 前缀的操作指令\nSequential Consistent\n\n\n\n","categories":["C/C++"],"tags":["Memory Order"]},{"title":"enable_shared_from_this的注意事项","url":"/2023/03/11/c++/enable-shared-from-this%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"使用场景当我们在对象函数中需要返回或者使用自己的 shared_ptr 指针时，该怎么办呢？常见的错误写法如下：用不安全的表达式试图获得 this 的 shared_ptr 对象, 但可能会导致 this 被多个互不知晓的所有者析构.\nstruct Bad&#123;    std::shared_ptr&lt;Bad&gt; getptr() &#123;        return std::shared_ptr&lt;Bad&gt;(this);    &#125;    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called\\n&quot;; &#125;&#125;;\n\n&#123;    std::shared_ptr&lt;Bad&gt; bp1 = std::make_shared&lt;Bad&gt;();    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; &#x27;\\n&#x27;;&#125; // UB: Bad 对象将会被删除两次\n正确写法是将定义对象公开继承 enable_shared_from_this: \nclass Good: public std::enable_shared_from_this&lt;Good&gt; // 注意：继承&#123;    std::shared_ptr&lt;Good&gt; getptr() &#123;        return shared_from_this();    &#125;&#125;;\n\n\n\nstd::enable_shared_from_this 能让其一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t的所有权。\n实现enable_shared_from_this 的常见实现为：其内部保存着一个对 this 的弱引用（例如 std::weak_ptr )。 std::shared_ptr 的构造函数发现是并能访问 enable_shared_from_this 的基类，并且若内部存储的弱引用未生成。则 std::shared_ptr 生成内部存储的弱引用。 libc++ 的实现如下：\ntemplate&lt;class _Tp&gt;class _LIBCPP_TEMPLATE_VIS enable_shared_from_this&#123;    mutable weak_ptr&lt;_Tp&gt; __weak_this_;    ...public:    _LIBCPP_INLINE_VISIBILITY    shared_ptr&lt;_Tp&gt; shared_from_this()        &#123;return shared_ptr&lt;_Tp&gt;(__weak_this_);&#125;    _LIBCPP_INLINE_VISIBILITY    shared_ptr&lt;_Tp const&gt; shared_from_this() const        &#123;return shared_ptr&lt;const _Tp&gt;(__weak_this_);&#125;        ...&#125;\nshared_ptr 的构造函数：\n    ...    template&lt;class _Yp, class = __enable_if_t&lt;        _And&lt;            __raw_pointer_compatible_with&lt;_Yp, _Tp&gt;            // In C++03 we get errors when trying to do SFINAE with the            // delete operator, so we always pretend that it&#x27;s deletable.            // The same happens on GCC.#if !defined(_LIBCPP_CXX03_LANG) &amp;&amp; !defined(_LIBCPP_COMPILER_GCC)            , _If&lt;is_array&lt;_Tp&gt;::value, __is_array_deletable&lt;_Yp*&gt;, __is_deletable&lt;_Yp*&gt; &gt;#endif        &gt;::value    &gt; &gt;    explicit shared_ptr(_Yp* __p) : __ptr_(__p) &#123;        unique_ptr&lt;_Yp&gt; __hold(__p);        typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;        typedef __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT&gt; _CntrlBlk;        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());        __hold.release();        __enable_weak_this(__p, __p);    &#125;        ... template &lt;class _Yp, class _OrigPtr, class = __enable_if_t&lt;        is_convertible&lt;_OrigPtr*, const enable_shared_from_this&lt;_Yp&gt;*&gt;::value    &gt; &gt;    _LIBCPP_HIDE_FROM_ABI    void __enable_weak_this(const enable_shared_from_this&lt;_Yp&gt;* __e, _OrigPtr* __ptr) _NOEXCEPT    &#123;        typedef __remove_cv_t&lt;_Yp&gt; _RawYp;        if (__e &amp;&amp; __e-&gt;__weak_this_.expired())        &#123;            __e-&gt;__weak_this_ = shared_ptr&lt;_RawYp&gt;(*this,                const_cast&lt;_RawYp*&gt;(static_cast&lt;const _Yp*&gt;(__ptr)));        &#125;    &#125;\n\nc++17 前对没初始化的 weak_ptr 的对象调用 shared_from_this 行为未定义行,  C++17 起抛出 std::bad_weak_ptr 异常：\ntry &#123;    Good not_so_good;    std::shared_ptr&lt;Good&gt; gp1 = not_so_good.getptr();&#125; catch(std::bad_weak_ptr&amp; e) &#123;    // C++17 前为未定义行为； C++17 起抛出 std::bad_weak_ptr 异常    std::cout &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;;    &#125;\n\n相关问题什么时候初始化 enable_shared_from_this 中的 weak_ptr？参考实现部分，构造 shared_ptr 的对象时判断是 enable_shared_from_this的时候会初始化。\n能不能非公有继承 enable_shared_from_this ？不能\n非公有继承时候，判断 class 是否是 enable_shared_from_this 会失败就不会去初始化 weak_ptr。\n能不能在构造函数中调用？不能\nshared_ptr 初始化需要调用构造函数，而 weak_ptr 需要 shared_ptr 构造初始化。GG 了。\n参考资料\nstd::enable_shared_from_this\n\n","categories":["C/C++"],"tags":["shared_ptr","智能指针"]},{"title":"std::make_shared vs. new","url":"/2023/02/07/c++/std-make-shared-vs-new/","content":"内存分配std::make_shared 执行一次堆分配，而调用std::shared_ptr 构造函数执行两次。\n在一个典型的实现中 std::shared_ptr 管理两个实体：\n\n控制块（存储元数据，如引用计数、类型擦除删除器等）\n被管理的对象\n\n控制块是一个动态分配的对象，它包含：\n\n指向托管对象的指针或托管对象本身；\n删除器 (类型擦除)\n分配器 (类型擦除)\n拥有被管理对象的 shared_ptr的数量\n引用托管对象的 weak_ptr 的数量\n\nstd::make_shared执行一次堆分配，计算控制块和数据所需的总空间。在另一种情况 std::shared_ptr&lt;Obj&gt;(new Obj(&quot;foo&quot;))下执行两次, new Obj(&quot;foo&quot;)为托管数据调用堆分配，std::shared_ptr构造函数为控制块执行另一个堆分配。\n\n\n异常安全自 C++17 以来，这不是问题，因为函数参数的评估顺序发生了变化。具体来说，函数的每个参数都需要在评估其他参数之前完全执行。\n考虑这个例子:\nf(std::shared_ptr&lt;int&gt;(new int(42)), g())\n因为 C++ 允许对子表达式进行任意顺序的计算，所以一种可能的顺序是：\n\nnew int(42)\ng()\nstd::shared_ptr&lt;int&gt;\n\n现在，假设我们在第 2 步抛出一个异常。然后我们丢失了在步骤 1 分配的内存，因为没有将原始指针传给 std::shared_ptr, 后面没有任何东西有机会清理它。\n解决这个问题的一种方法是在不同的行上执行它们，这样就不会发生这种任意排序。\nauto ptr = std::shared_ptr&lt;int&gt;(new int(42));f(ptr, g());\n\n更方便的的是采用 std::make_shared.\nf(std::make_shared&lt;int&gt;(42), g())\n\nstd::make_shared 的一些缺点weak_ptr内存保活\n通过 std::make_shared 构造的智能指针, 当没有 shared_ptr 引用计数为 0 时只调用析构函数，weak_ptr引用计数为 0 时才释放内存块。\n\nbool logging = false;void* operator new(std::size_t size) &#123;    auto ptr = std::malloc(size);    if (logging) &#123;        std::cout &lt;&lt; &quot;Allocated: &quot; &lt;&lt; (uintptr_t)ptr &lt;&lt; std::endl;    &#125;    return ptr;&#125;void operator delete(void *ptr) noexcept  &#123;    std::free(ptr);    if (logging) &#123;        std::cout &lt;&lt; &quot;Deallocated: &quot; &lt;&lt; (uintptr_t)ptr &lt;&lt; std::endl;    &#125;&#125;struct Widget &#123;    ~Widget() &#123;        std::cout &lt;&lt; &quot;Widget::~Widget()&quot; &lt;&lt; std::endl;    &#125;    int data;&#125;;int main(int argc, char*argv[]) &#123;    logging = true;    test(true);    std::cout &lt;&lt; &quot;---------------------\\n&quot;;    test(false);    return 0;&#125;\n\nAllocated: 105553162522944 //分配一次Widget::~Widget() // 没有 shared_ptr 指针，只调用析构函数No std::shared_ptr&#x27;s anymore.Deallocated: 105553162522944 //没有 `weak_ptr` 释放整个内存块No std::weak_ptr&#x27;s anymore.---------------------Allocated: 105553164599312Allocated: 105553162522944 //分配两次Widget::~Widget()Deallocated: 105553164599312 //立即释放No std::shared_ptr&#x27;s anymore.Deallocated: 105553162522944No std::weak_ptr&#x27;s anymore.\n\n无法访问公共构造函数class A&#123;public:    A(): val(0)&#123;&#125;    // make_shared 无法调用 A(int)     // std::shared_ptr&lt;A&gt; createNext()&#123;     //     return std::make_shared&lt;A&gt;(val+1);     //&#125;        // 可以调用 A(int)     std::shared_ptr&lt;A&gt; createNext()&#123;         return std::shared_ptr&lt;A&gt;(new A(val+1));     &#125;private:    int val;    A(int v): val(v)&#123;&#125;&#125;;\n\n参考资料\nDifference in make_shared and normal shared_ptr in C++\nstd::make_shared 与 new\nmake_shared#Notes\n\n","categories":["C/C++"],"tags":["C++","智能指针"]},{"title":"std::thread 注意事项","url":"/2023/11/03/c++/std-thread-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"join 和 detach\njoin 或者 detach 只能调用一次\n当调用 join 或者 detach 之后会将持有的线程ID置为 0, 再次调用会抛异常。\nvoidthread::join()&#123;    int ec = EINVAL;    if (!__libcpp_thread_isnull(&amp;__t_))    &#123;        ec = __libcpp_thread_join(&amp;__t_);        if (ec == 0)            __t_ = _LIBCPP_NULL_THREAD;    &#125;    if (ec)        __throw_system_error(ec, &quot;thread::join failed&quot;);&#125;voidthread::detach()&#123;    int ec = EINVAL;    if (!__libcpp_thread_isnull(&amp;__t_))    &#123;        ec = __libcpp_thread_detach(&amp;__t_);        if (ec == 0)            __t_ = _LIBCPP_NULL_THREAD;    &#125;    if (ec)        __throw_system_error(ec, &quot;thread::detach failed&quot;);&#125;\n\n\n\nthread 不能拷贝只能移动，但只能移动到没绑定线程的 thread。\n\nclass _LIBCPP_EXPORTED_FROM_ABI thread&#123;    __libcpp_thread_t __t_;    thread(const thread&amp;);    thread&amp; operator=(const thread&amp;);     _LIBCPP_INLINE_VISIBILITY    thread&amp; operator=(thread&amp;&amp; __t) _NOEXCEPT &#123;        if (!__libcpp_thread_isnull(&amp;__t_))            terminate();        __t_ = __t.__t_;        __t.__t_ = _LIBCPP_NULL_THREAD;        return *this;    &#125;    ...&#125;;\n线程析构通过 std::thread 创建的线程**必须调用 join 或者 detach**。线程析构时会先判断线程ID为 0 就抛异常。\nthread::~thread()&#123;    if (!__libcpp_thread_isnull(&amp;__t_))        terminate();&#125;\n\nstd::thread 析构默认不会等待线程结束，在 C++20 可以使用 std::jthread, std::jthread 实际是使用了 RAII 技术， 在内部持有 thread 成员变量，在析构时调用 join 函数。\nclass _LIBCPP_AVAILABILITY_SYNC jthread &#123;..._LIBCPP_HIDE_FROM_ABI ~jthread() &#123;    if (joinable()) &#123;        request_stop();        join();    &#125;&#125;thread __thread_;&#125;;","categories":["C/C++"],"tags":["thread"]},{"title":"可变参数模板","url":"/2023/04/10/c++/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","content":"可变参数模板的需求可变参数模板有助于解决在编译时求值类型安全，不需要宏，不需要显式指定 参数的数量，可以编写可变参数函数模板和可变参数类模板。此外，也有可变参数变量模板和可变 参数别名模板。\n可变参数函数模板可变参数模板以两种方式使用省略号。在参数名称的左侧，表示参数包，在参数名称的右侧，将参数包扩展为单独的名称。\ntemplate &lt;typename T&gt; T min(T a, T b)&#123;  return a &lt; b ? a : b;&#125;template &lt;typename T, typename... Args&gt; T min(T a, Args... args)&#123;  return min(a, min(args...)); &#125;\n\n要在模板参数列表中指定一组参数，如 typename... Args，这称为模板参数包。可以为类型模板、非类型模板和双重模板参数定义的模板参数包。\n函数参数列表中指定一组参数，如 Args...args，这称为函数参数包。\n函数体中展开包，如在 args... 中，可在 min(args...) 中看到，这称为参数包展开。这种展开的结果是一个由零个或多个值 (或表达式) 组成的逗号分隔列表。\n\n参数包\nsizeof... 计算参数包的大小，返回 std::size_t 类型的 constexpr 值。\n\n可变参数类模板折叠表达式\n\n\n折叠方式\n语法\n展开方式\n\n\n\n一元右折叠\n(pack op …)\n(arg1 op (… op (argN-1 op argN)))\n\n\n一元左折叠\n(… op pack)\n(((arg1 op arg2) op …) op argN)\n\n\n二元右折叠\n(pack op … op init)\n(arg1 op (… op (argN-1 op (argN op init))))\n\n\n二元左折叠\n(init op … op pack)\n((((init op arg1) op arg2) op …) op argN)\n\n\n\n一元折叠中，若参数包不包含任何元素，则只允许使用某些操作符。下表列出了这些值，以及 空参数包的值:\n\n\n\n操作符\n空参数包的值\n\n\n\n&amp;&amp; (逻辑 AND)\ntrue\n\n\n&#124;&#124; (逻辑 OR)\nfalse\n\n\n, (逗号操作符)\nvoid()\n\n\n\n\n可变参数别名模板可变参数变量模板","categories":["C/C++"],"tags":["template"]},{"title":"深入了解 C++20 中的 constinit","url":"/2023/12/29/c++/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3C++20%E4%B8%AD%E7%9A%84constinit%E5%85%B3%E9%94%AE%E5%AD%97/","content":"在 C++ 中，存储变量的方式有几种：\n\n存储期（Storage Duration）：存储期是指变量在程序中存在的时间段。在 C++ 中，有三种主要的存储期：\n\n自动存储期（Automatic Storage Duration）：变量在函数或代码块执行时创建，函数执行结束时销毁。\n动态存储期（Dynamic Storage Duration）： 使用 new 或 malloc 分配的内存，直到使用 delete 或 free 手动释放为止。\n静态存储期（Static Storage Duration）： 变量在程序启动时创建，在整个程序运行期间都存在，直到程序结束才销毁。\n\n\n静态存储变量：\n\n\n静态存储变量是在程序启动时创建，一直存在于整个程序运行期间的变量。这类变量有两种主要形式：\n\n全局变量（Global Variables）： 在函数外部声明的变量，可以被程序中的所有函数访问。\n静态局部变量（Static Local Variables）： 在函数内部使用 static 关键字声明的变量，与自动存储期变量不同，它在函数调用之间保持其值。\n\n在 C++ 中，我们经常使用静态存储期变量，包括全局变量和使用 static 关键字声明的局部变量。然而，这些变量并不保证在程序执行前被初始化，除非它们被声明为 const 常量。为了解决这一问题，C++20 引入了 constinit 关键字，它为我们提供了一种保证变量在程序启动时被初始化的方式，从而增强了可预测性和可靠性。\n尽管 constinit 确保变量在程序启动时被初始化，但这并不意味着这些变量是不可修改的常量。相反，这个关键字允许变量在初始化后在运行时或编译时上下文中被修改。\n因此，constinit 关键字为我们提供了一种在使用静态存储期变量时获得初始化保证的方法，同时允许在初始化后对其进行适当的修改。\n\n\nconstinit 和 constexpr 有什么区别？如果一个变量被声明为 constexpr ，那么它隐含地具有了 constinit 的性质。 constexpr 关键字用于指示编译器，在编译时可以计算该变量的值，并要求该变量在程序启动时被静态初始化。因此，constexpr 的变量天然地拥有 constinit 的特性但是反过来并不成立，即如果一个变量被声明为 constinit，并不意味着它就是 constexpr。constinit仅确保变量在程序启动时被静态初始化，但不要求在编译时就能确定其值。相反，constexpr 要求在编译时就能确定变量的值。\n#include &lt;array&gt;constexpr std::size_t getArraySizeBasedOnArchitecture() &#123;    return sizeof(std::size_t) * 100;&#125;constinit auto arrSize2 = getArraySizeBasedOnArchitecture();constexpr auto arrSize1 = getArraySizeBasedOnArchitecture();int main()&#123;     std::array&lt;int, arrSize1&gt; intArray1;  // Ok     std::array&lt;int, arrSize2&gt; intArray2;  // compilation error&#125;\n\n注意：constexpr 和 constinit 不能同时出现在变量上。这会导致编译错误。\nconstinit 有什么作用？\n保证变量在编译时初始化\n当变量不能在编译时初始化时编译器生成错误提示\n处理静态初始化顺序，static-init-order\n\n总结\nconstinit 说明符仅适用于变量\nconstinit 保证变量在编译过程中被初始化，否则我们会得到一个编译错误。\nconstinit 说明符表示静态存储持续时间，但反之则不成立\nconstexpr 变量意味着 constinit ，但反过来并不正确。\n一个变量只能出现 constexpr 和 constinit 说明符之一。\nconstinit 可以应用于 const 限定变量。\n\n","categories":["C/C++"],"tags":["C++20","const"]},{"title":"深入了解 C++20 中的 consteval","url":"/2023/12/29/c++/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3C-20%E4%B8%AD%E7%9A%84consteval%E5%85%B3%E9%94%AE%E5%AD%97/","content":"简介用最简单的术语来说，一个只能应用于函数的 consteval 关键字, 保证它产生一个编译时间常数。否则会导致编译错误。\ncppreference 页面对 consteval 说明符有如下描述：\n\nconsteval 指定函数是立即函数，也就是说，对该函数的每次调用都必须产生一个编译时常量\n\n什么是立即函数？\n\n不能是协程\n函数主体中不能有 throw 语句\n不能有 goto 语句或标签语句，除了 case 和 default\n参数和返回类型必须是LiteralType,简单地说，是一个可以在编译时计算的类型（比如所有可以在 constexpr 上下文中使用的类型）\n\n\n\nconsteval 和 constexpr 方法的区别他们最大的区别：consteval 保证编译时生成，不能编译时生成时会报错，但 constexpr 不一定，当编译时不能生成就转为运行时函数。\n从汇编看 consteval 和 constexpr 函数定义函数对于定义的普通函数、 consteval 函数、 constexpr 函数, 只有普通函数会生成汇编代码\n在编译时上下文调用 consteval 和 constexpr 函数在编译时直接生成结果，不会生成对应的函数汇编代码和调用汇编指令\n在非编译时上下文调用 consteval 和 constexpr 函数会生成 constexpr函数的汇编代码和调用函数汇编指令\n总结\nconsteval 说明符只能应用于函数和构造函数\n带有 consteval 的函数称为立即函数\nconstexpr 函数在编译时上下文中执行时，与consteval 函数行为相同\n当 consteval 函数不能产生编译时错误时，会导致错误，而对于 constexpr 函数则不会。\n当需要对函数的编译时求值进行保证时，首选 consteval\n优先使用 consteval 函数而不是预处理器宏函数。\n\n","categories":["C/C++"],"tags":["C++20","const"]},{"title":"CMake 踩坑记","url":"/2023/04/07/cmake/CMake-%E8%B8%A9%E5%9D%91%E8%AE%B0/","content":"install(CODE) 和 execute_process 配合确保 WORKING_DIRECTORY 存在示例代码: \nset(CMAKE_INSTALL_PREFIX $&#123;PROJECT_BINARY_DIR&#125;/export)install(CODE &quot;    execute_process(COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory folder     WORKING_DIRECTORY \\$&#123;CMAKE_INSTALL_PREFIX&#125;)    &quot;) \n\n注意确保 CMAKE_INSTALL_PREFIX 存在，可能执行这段代码时还没有 install target 导致 CMAKE_INSTALL_PREFIX 还没有生成。\n\n\n注意变量转义不转义容易在 package 时，执行 execute_process 因为路径问题出错。\n示例代码: \nset(CMAKE_INSTALL_PREFIX $&#123;PROJECT_BINARY_DIR&#125;/export)install(CODE &quot;    execute_process(COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory folder    WORKING_DIRECTORY \\$&#123;CMAKE_INSTALL_PREFIX&#125;)    &quot;) \n注意 $&#123;WORKING_DIRECTORY&#125; 之前是有 \\ 转义，当没有转义时，CMAKE_INSTALL_PREFIX会直接替换，此时 CMAKE_INSTALL_PREFIX 表示的 install 路径。 make package时会到一个临时目录处理，其中的 CMAKE_INSTALL_PREFIX 跟  install 路径是不一样的，所以执行 execute_process 会出问题。当转义了表示 execute_process时再去获取 CMAKE_INSTALL_PREFIX, 这时能获取到正确路径。可以在 cmake_install.cmake 查看生成的代码。注意 WORKING_DIRECTORY 的值。\n不转义生成代码：if(CMAKE_INSTALL_COMPONENT STREQUAL &quot;rel&quot; OR NOT CMAKE_INSTALL_COMPONENT)    execute_process(COMMAND /Users/xxx/Qt/Tools/CMake/CMake.app/Contents/bin/cmake -E make_directory folder    WORKING_DIRECTORY &quot;/xxx/xxx/xxxx/export&quot;)endif()\n\n转义生成代码：\nif(CMAKE_INSTALL_COMPONENT STREQUAL &quot;rel&quot; OR NOT CMAKE_INSTALL_COMPONENT)    execute_process(COMMAND /Users/xxx/Qt/Tools/CMake/CMake.app/Contents/bin/cmake -E make_directory folder    WORKING_DIRECTORY $&#123;CMAKE_INSTALL_PREFIX&#125;)endif()\n\n在 MacOS 上 No CMAKE_CXX_COMPILER could be foundsudo xcode-select -s /Applications/Xcode.app/Contents/Developer \n\nCMAKE_OSX_ARCHITECTURES\n设置 macOS和 iOS 的特定架构\n应在第一次 project() 或 enable_language() 命令之前设置\n应设置为 CACHE 条目, 除非策略 CMP0126 设置为 NEW \n在 Apple 以外的平台上被忽略\n\nif (APPLE)    set(CMAKE_OSX_ARCHITECTURES x86_64 CACHE STRING &quot;&quot;)endif()\n\ncmakedefine 的使用例子#cmakedefine 用于 configure_file() 中用于生成头文件的文件中，只有当 CMakeLists.txt 中的同名变量为真时才会在生成的头文件中定义，区别于 #define 无论何时都会定义。\n例如:\n-&gt; cat config.h.cmake#ifndef __CONFIG_H#define __CONFIG_H/* Define to 1 if you have the &lt;mach/mach_time.h&gt; header file. */#cmakedefine HAVE_MACH_MACH_TIME_H 1#endif /* __CONFIG_H */\n\n-&gt; cat CMakeLists.txtinclude(CheckIncludeFiles)check_include_files(&quot;mach/mach_time.h&quot; HAVE_MACH_MACH_TIME_H)configure_file(        $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/config.h.cmake        $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h        NEWLINE_STYLE UNIX)list(APPEND HEADERS $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h)\n\n只有当 mach/mach_time.h 存在时，在 config.h 才会定义 HAVE_MACH_MACH_TIME_H 。\n","tags":["CMake"]},{"title":"HMAC：理解其原理和计算过程","url":"/2025/04/18/cryptographic/HMAC%EF%BC%9A%E7%90%86%E8%A7%A3%E5%85%B6%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/","content":"介绍HMAC（Hash-based Message Authentication Code是一种基于哈希函数的消息认证码（MAC）算法，用于验证数据的完整性和真实性。它通过结合哈希算法与密钥来生成一个认证码，可以防止数据在传输过程中被篡改。HMAC 广泛应用于网络协议（如 TLS、IPSec 等）、数字签名以及 API 认证等场景中。\n在这篇文章中，我们将深入了解 HMAC 的原理，并通过具体的计算过程来说明其如何工作。\n\n\nHMAC的工作原理HMAC 的工作原理可以通过以下几个步骤来描述：\n\n选择哈希算法：HMAC可以使用任何哈希函数，如 MD5、SHA-1、SHA-256等。算法的选择通常取决于安全要求及性能需求。\n\n密钥处理：HMAC 算法需要一个密钥。如果密钥的长度小于哈希函数的块大小，则需要对密钥进行填充，在末尾填充0。如果密钥的长度大于块大小，则首先对密钥进行哈希处理，使得密钥的长度与块大小一致。\n\n内外填充：在 HMAC 中，密钥会被分别与两个常量值（ipad 和 opad）进行组合：\n\nipad（内填充）：一个由 0x36 组成的块（长度等于哈希函数的块大小）。\nopad（外填充）：一个由 0x5C 组成的块（长度等于哈希函数的块大小）。\n\n\n计算过程：HMAC的计算分为两个主要步骤：\n\n内层哈希：首先将密钥与 ipad 进行异或运算，得到一个新的密钥。然后，将该新密钥与消息数据进行连接，并计算哈希值。\n外层哈希：接着，将密钥与 opad 进行异或运算，得到一个新的密钥。然后，将该新密钥与第一步得到的哈希值进行连接，并计算哈希值。最终得到的哈希值就是 HMAC 值。\n\n\n\n$$\\mathrm{HMAC}(K, m) &#x3D; H\\left((K’ \\oplus \\text{opad}) ,|, H\\left((K’ \\oplus \\text{ipad}) ,|, m\\right)\\right)$$\n其中：\n\n( H )：哈希函数（如 SHA-256）\n( K )：原始密钥\n( m )：消息\n( K’ )：处理后的密钥，如果 ( K ) 长度大于块长度，则先哈希再填充，否则直接填充到块长度\n( $\\text{opad}$ )：外部填充常量，重复字节 0x5c\n( $\\text{ipad}$ )：内部填充常量，重复字节 0x36\n( $|$ )：表示字节连接\n( $\\oplus$ )：按位异或\n\n\nHMAC的计算过程下面通过具体的计算例子来详细说明 HMAC 的生成过程。假设我们使用 SHA-256 哈希算法，并且给定一个密钥和消息。\n步骤1：准备工作假设：\n\n密钥：K = &quot;key&quot;\n消息：M = &quot;The quick brown fox jumps over the lazy dog&quot;\n\n首先，SHA-256 的块大小为 64 字节（512 位），因此我们需要将密钥扩展或截断为 64 字节的长度。如果密钥小于 64 字节，则通过补零使其长度达到 64 字节。\n密钥扩展后：\nK = &quot;key&quot; =&gt; 0x6B65790000000000000000000000000000000000000000000000000000000000\n\n步骤2：内层计算将密钥与 ipad（0x36 的重复块）进行异或，得到内层密钥：\nK ⊕ ipad = 0x6B65790000000000000000000000000000000000000000000000000000000000           ⊕ 0x3636363636363636363636363636363636363636363636363636363636363636           ------------------------------------           0x5D3187376C7D2D6C74702C7270657D6E7E7D696F7B7D7C0B68726D786D7E7F7E\n\n接着，将内层密钥与消息M进行拼接，并对拼接后的数据进行 SHA-256 哈希计算：\nH1 = SHA-256(K ⊕ ipad || M)\n\n步骤3：外层计算将密钥与 opad（0x5C 的重复块）进行异或，得到外层密钥：\nK ⊕ opad = 0x6B65790000000000000000000000000000000000000000000000000000000000           ⊕ 0x5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C           ------------------------------------           0x1775744441E8B54D5F7D2A0C7640E45F2B70D1639B4D2B4C4D4D3A2B4F4F49F2\n然后，将外层密钥与第一步计算得到的哈希值 H1 进行拼接，并对拼接后的数据进行 SHA-256 哈希计算：\nHMAC = SHA-256(K ⊕ opad || H1)\n\n最终，得到的 HMAC 就是我们需要的消息认证码。\nHMAC的安全性HMAC 的安全性依赖于两个因素：\n\n哈希函数的安全性：如果选择的哈希函数本身存在安全漏洞（如碰撞攻击），则 HMAC 的安全性也会受到影响。\n\n密钥的管理：HMAC 依赖于密钥的机密性。如果密钥泄露，HMAC 的安全性将大大降低。\n\n\n因此，建议使用强大的哈希算法（如 SHA-256 或更高版本的算法），并采取合适的措施管理密钥。\nHMAC的应用场景HMAC 有许多应用场景，以下是一些常见的例子：\n\nAPI认证：通过 HMAC 可以确保请求的数据未被篡改，并且能够验证请求者的身份。\n\n数字签名：HMAC 可用于签名消息，确保消息的完整性。\n\n加密协议：如 SSL/TLS，HMAC 用于保证数据在传输过程中不被篡改。\n\n\n总结HMAC 是一种简单而强大的消息认证码算法，它结合了哈希函数和密钥的特性，能够有效地验证消息的完整性和真实性。通过理解 HMAC 的工作原理和计算过程，我们可以更好地应用它来增强我们的数据保护能力。\n","categories":["Cryptographic Algorithms"],"tags":["HMAC"]},{"title":"基础密码知识","url":"/2025/04/08/cryptographic/cryptographic_algorithms/","content":"常见加密模式为什么要分模式？对称加密算法（如AES）只能加密固定长度的数据块（比如 AES 的块是 128 位）。如果要加密一个很长的文件，就需要将文件切分成多个块，再逐个加密。\n问题来了：如何让这些块之间产生关联，避免被破解？这就是加密模式的作用！\n\n\n1. ECB模式（电子密码本）\n原理：\n\n把数据切成块，每块独立加密，像查字典一样（比如“A”对应“X”，“B”对应“Y”）。\n致命缺陷：相同的明文块会生成相同的密文块。\n\n\n例子：\n\n加密一张纯色图片（比如全黑），ECB加密后仍能看到轮廓（如下图）。\n\n加密“HelloHello”，两个“Hello”块加密后完全一样。\n  \n\n\n\n\n结论：永远不要用ECB，除非加密单个块（比如一个密码）。\n2. CBC模式（密码块链）\n原理：\n\n初始化向量（IV）：在加密第一个块前，生成一个随机数（IV），与第一个明文块做异或（XOR）。\n链式反应：每个明文块加密前，先与前一个密文块做XOR，再加密。\n\n\n例子：\n\n加密“Hello”：\n\n生成IV（比如“随机数123”），与“Hello”做XOR，再加密。\n第二个块“World”先与第一个块的密文做XOR，再加密。\n\n\n即使两个明文块相同，加密后的结果也不同。\n\n\n\n优点：：安全性高，适合文件加密。\n\n缺点：\n\n需要存储或传输IV（通常明文传输，无需保密）。\n无法并行加密（必须按顺序处理块）。\n\n\n\n3. CTR模式（计数器模式）\n原理：\n\n生成一个计数器（比如从0开始递增：0,1,2,3…）。\n加密计数器，得到一个密钥流（伪随机数）。\n将密钥流与明文块做XOR，得到密文。\n\n\n例子：\n\n加密“Hello”：\n加密计数器0得到密钥流“X3k%”，与“Hello”XOR得到密文。\n加密计数器1得到密钥流“aB9$”，与下一个块XOR。\n\n\n\n\n优点：\n\n支持并行加密和解密（因为不依赖前一个块）。\n\n可以实时加密（比如视频流）。\n\n\n\n缺点：\n\n计数器不能重复（否则安全性崩溃）。\n\n\n\n4. GCM模式（伽罗瓦计数器模式）\n原理：结合CTR模式的高效性，并附加认证标签（MAC），验证数据是否被篡改。\n\n例子：\n\n加密一段消息后，生成一个“指纹”（比如“d8e9f”）。\n\n接收方解密时验证指纹，如果指纹不匹配，说明数据被篡改。\n\n\n\n优点：\n\n加密+认证一步完成（适合网络传输，如HTTPS）。\n高效且安全。\n\n\n缺点：\n\n实现复杂，需要处理计数器溢出问题。\n\n\n\n5. CFB&#x2F;OFB模式（反馈模式）\n原理：\n\n类似于CTR，但生成密钥流的方式不同。\nCFB（密码反馈）：将前一个密文块加密后生成密钥流。\nOFB（输出反馈）：将前一个密钥流加密后生成新的密钥流。\n\n\n用途：\n\n适合流数据（如实时语音），但现代应用更倾向用CTR或GCM。\n\n\n\n加密模式对比表\n\n\n模式\n安全性\n速度\n并行性\n适用场景\n\n\n\nECB\n❌ 低\n⚡快\n✔️ 支持\n已淘汰（仅用于单块加密）\n\n\nCBC\n✔️ 高\n🐢 慢\n❌ 不支持\n文件加密（需顺序处理）\n\n\nCTR\n✔️ 高\n⚡快\n✔️ 支持\n实时数据流（视频、网络传输）\n\n\nGCM\n✔️ 超高\n⚡快\n✔️ 支持\n需要认证的传输（HTTPS、VPN）\n\n\nCFB\n✔️ 中\n🐢 慢\n❌ 不支持\n遗留系统（逐渐被取代）\n\n\n\nECB 是“独狼”，CBC是“链条”，CTR是“流水线”，GCM是“保镖+流水线”\n\n常见对称加密算法\n\n\n算法\n加密模式\n密钥长度\n应用\n优点\n缺点\n\n\n\nAES (Advanced Encryption Standard)\nECB, CBC, CTR, GCM, OFB, CFB\n128, 192, 256位\n数据加密、文件加密、通信加密等\n安全性高，支持多种加密模式，广泛使用\n对于某些模式（如ECB）存在模式相关的安全问题\n\n\nDES (Data Encryption Standard)\nECB, CBC, OFB, CFB, CTR\n56位\n曾用于早期的加密系统\n计算速度快，硬件支持广泛\n密钥长度过短，已不再安全\n\n\n3DES (Triple DES)\nECB, CBC, OFB, CFB\n112位或168位\n用于替代DES的系统，金融领域等\n提供比DES更强的安全性\n效率较低，逐渐被AES替代\n\n\nBlowfish\nECB, CBC, OFB, CFB, CTR\n32位到448位\n用于文件加密、VPN、硬盘加密等\n密钥长度灵活，速度较快，简单高效\n密钥管理不如AES，存在某些漏洞\n\n\nRC4\n流加密模式（Stream Cipher）\n40位到2048位\nWEP加密、SSL&#x2F;TLS协议等\n实现简单，速度较快\n存在已知安全漏洞，逐步被淘汰\n\n\nTwofish\nECB, CBC, OFB, CFB, CTR\n128位、192位、256位\n用于加密文件、通信协议、硬盘加密等\n安全性高，灵活的密钥长度，设计简洁\n相较于AES，使用较少，支持硬件加速较少\n\n\n常见密钥协商算法\n\n\n算法\n原理\n应用\n优点\n缺点\n\n\n\nDiffie-Hellman (DH)\n基于离散对数问题，允许双方在公开通道上协商出共享密钥。\n广泛用于TLS&#x2F;SSL协议。\n安全性较高，理论上不易被破解。\n容易受到中间人攻击（MITM），缺乏身份认证。\n\n\nElliptic Curve DH (ECDH)\n使用椭圆曲线数学结构，提供与DH相同的安全性，但密钥尺寸更小。\n现代加密协议，如TLS、VPN等。\n高效、适合资源有限的设备。\n需要更高的数学理解和实现复杂度。\n\n\nRSA\n基于大整数分解问题，使用接收方的公钥加密会话密钥，接收方使用私钥解密。\n传统的TLS&#x2F;SSL协议，数字签名等。\n安全性较高，已广泛应用。\n加密效率较低，缺乏前向保密性，密钥较大。\n\n\nQuantum Key Distribution (QKD)\n利用量子力学原理（量子纠缠、量子叠加）确保密钥交换的安全性。\n未来的量子计算环境中的密钥交换。\n极高的安全性，即使量子计算机出现也能保证安全。\n目前技术不成熟，基础设施复杂且成本高。\n\n\nPost-Quantum Cryptography (PQC)\n针对量子计算攻击的加密算法，确保在量子计算机时代仍然安全。\n量子计算发展后的加密解决方案。\n为未来量子计算带来的威胁提供抗性。\n当前实现不成熟，标准尚在制定中。\n\n\nKerberos\n基于对称密钥的认证协议，使用中心认证服务器（KDC）进行身份验证和密钥分发。\n企业环境中网络身份验证。\n提供安全的身份验证，支持单点登录（SSO）。\n需要配置复杂的KDC基础设施。\n\n\nSecure Remote Password (SRP)\n基于密码的认证协议，避免密码直接传输，双方使用共享密钥进行加密通信。\n基于密码的应用，如安全远程登录。\n提供无密码传输的安全验证，适合基于密码的应用。\n实现复杂，性能上相对较差。\n\n\nAES-GCMAES-GCM（Advanced Encryption Standard - Galois/Counter Mode）是一种结合加密和认证的对称加密模式，广泛应用于需要高效保密性和数据完整性的场景（如TLS、IPSec）。以下是其核心步骤的详细分解：\n1. 参数初始化\n密钥（Key）：128/192/256位的 AES 密钥，用于加密和生成认证标签。\n初始向量（IV）：通常为 12 字节（推荐长度），需全局唯一，避免重复。\n附加认证数据（AAD）：可选明文数据，参与认证但不加密。\n明文（Plaintext）：待加密的数据。\n\n2. 生成初始计数器块（J₀）\nIV 处理：\n若 IV 为 12 字节：直接作为前 12 字节，后接4字节计数器（0x00000001），组成 16 字节的 $J_0$ 。\n若 IV 非 12 字节：通过 GHASH 计算生成 $J_0$（见步骤6）。\n\n\n\n3. 加密过程（CTR模式）\n生成密钥流：\n\n初始计数器块：$J_0$ 的31位最低有效位（LSB）递增，生成计数器序列 J₀+1, J₀+2, ...。\n对每个计数器块进行 AES 加密，生成密钥流块。\n\n\n生成密文：\n\n明文分块（每块16字节）与对应密钥流异或，得到密文。\n\n\n\n4. 认证过程（GHASH）GHASH 核心操作：在 Galois 域 $\\mathrm{GF}(2^{128})$ 上的乘法，使用哈希子密钥 H,（由加密全0块得到, $H &#x3D; \\mathrm{AES\\text{-}Encrypt}(\\mathrm{Key}, \\mathbf{0}^{128})$）。\n步骤：\n\n处理AAD：\n\n将 AAD 填充为 16 字节的倍数，不够补零，分块为 $A_1, A_2, \\ldots, A_m$。\n计算 GHASH：初始为X = 0（128位全0），依次与 AAD 块异或后乘 H。\n\n $$ X &#x3D; (X \\oplus A_i) \\otimes H $$\n\n处理密文：\n\n将密文填充为 16 字节的倍数，不够补零，分块为 $C_1, C_2, \\ldots, C_m$。\n继续 GHASH 计算，与密文块异或后乘 H。\n\n $$ X &#x3D; (X \\oplus C_i) \\otimes H $$\n\n处理长度块：\n\n拼接 AAD 长度和密文长度（各64位），组成 16 字节块。\n\n（1）单位必须为比特（bit）\n（2）64 位无符号整数表示\n（3）前 8 字节为 AAD 长度，后 8 字节为密文长度 的顺序拼接\n\n\n最后与长度块异或后乘 H，得到 GHASH 输出 S 。\n\n\n $$ \\begin{aligned} \\text{Len} &amp;&#x3D; \\text{len}(\\text{AAD})\\ \\texttt{||} \\ \\text{len}(\\text{Ciphertext}) \\ S &amp;&#x3D; (X \\oplus \\text{Len}) \\otimes H \\end{aligned} $$\n\n\n📘 符号说明：\n\n$\\texttt{||}$ 表示拼接（concatenation）\n$\\oplus$ 表示异或（XOR）\n$\\otimes$ 表示伽罗瓦域乘法（$\\mathrm{GF}(2^{128})$）\nlen(...) 表示比特长度，通常为 64 位整数（如 GCM 中的定义）\nX 是前一轮 GHASH 累加值\nH 是 GHASH 中的密钥（通常由 AES 加密 0 块得出）\n\n5. 生成认证标签（Tag）\n加密 $J_0$：$T &#x3D; \\mathrm{AES\\text{-}Encrypt}(J_0) \\oplus S$\n截断 T 为指定长度（通常16字节）作为最终认证标签。\n\n6. 输出结果\n密文（Ciphertext）：加密后的数据。\n认证标签（Tag）：用于验证数据完整性和真实性的签名。\n\n安全注意事项\nIV 唯一性：重复IV会导致密钥流复用，破坏安全性。\n密钥管理：定期更换密钥，避免泄露。\n认证失败处理：标签验证失败时需丢弃数据，防止篡改攻击。\n\n+---------------------+| 初始化参数           || - Key               || - IV                || - AAD               || - Plaintext         |+---------------------+          |          v+---------------------+| 生成初始计数器块 J₀  | → 若IV=12字节: J₀ = IV || 0x00000001|                     | → 否则: J₀ = GHASH(IV)+---------------------+          |          v+---------------------+       +---------------------+| CTR模式加密          |       | GHASH认证过程       || 1. J₀+1, J₀+2,...    |       | 1. 计算H = AES(0)   || 2. 生成密钥流        |       | 2. 处理AAD → X      || 3. 明文异或密钥流 → 密文 |   | 3. 处理密文 → X     ||                     |       | 4. 处理长度块 → S    |+---------------------+       +---------------------+          |                             |          |                             v          +------------+  +-------------+                       |  |                       v  v+---------------------+| 生成认证标签         || T = AES(J₀) ⊕ S      || 截断T为Tag           |+---------------------+          |          v+---------------------+| 输出结果             || - 密文               || - Tag               |+---------------------+\n\n","categories":["Cryptographic Algorithms"],"tags":["密码","加密"]},{"title":"深入理解 HKDF：HMAC 密钥派生函数","url":"/2025/04/18/cryptographic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-HKDF%EF%BC%9AHMAC-%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0/","content":"介绍在加密领域，密钥派生函数（KDF）是通过从一个初始密钥（通常称为“种子密钥”或“主密钥”）生成多个密钥的算法。HKDF（HMAC-based Key Derivation Function）是一种基于 HMAC 的密钥派生函数，它被设计用于从一个或多个输入密钥材料中生成多个安全的输出密钥。HKDF 是一个简洁且具有高度安全性的 KDF，广泛用于生成加密协议中的密钥（如 TLS、IPSec 等）。\n在这篇文章中，我们将深入探讨 HKDF 的原理、计算过程以及应用场景，帮助你更好地理解这个关键的密码学工具。\n\n\nHKDF 的工作原理HKDF 是一种伪随机函数（$PRF$），其核心思想是从一个初始的种子密钥（或称主密钥）中生成多个密钥，并且能够提供高度的安全性。HKDF 通过两步过程实现密钥派生：提取（Extract） 和 扩展（Expand）。\n1. 提取（Extract）提取过程是将输入的密钥材料（通常是随机的）和一个盐（$salt$）进行处理，得到一个固定大小的伪随机输出。盐的作用是增加随机性，避免相同的输入产生相同的输出，从而增加安全性。\n\n输入：\n\n$IKM（Input Key Material）$：初始密钥材料，通常是一个主密钥或其他随机数据。\n$salt$（盐）：一个可选的随机值，通常是由一个非秘密值（例如，固定值或随机生成的值）组成。盐可以为空，但为空时应使用特定的默认值（如全零，长度则为所采用哈希函数的散列值长度）。\n\n\n输出：\n\n$PRK（Pseudorandom Key）$：一个固定长度的伪随机密钥（$PRK$），通常使用 HMAC 作为提取过程的核心操作。\n\n\n\nHMAC 算法将在提取过程中发挥作用，用盐和输入密钥材料（$IKM$）生成伪随机密钥（$PRK$）。\n$$\\begin{aligned}&amp;\\mathrm{PRK} &#x3D; \\mathrm{HMAC}(\\text{salt},\\ \\text{IKM}) \\\\end{aligned}$$\n2. 扩展（Expand）扩展过程使用从提取步骤得到的伪随机密钥（$PRK$）和一些额外的参数（如输出的密钥长度和上下文信息），进一步生成所需数量的密钥。扩展步骤是通过连续应用 HMAC 来逐步生成所需的密钥。\n\n输入：\n\n$PRK$（伪随机密钥）：提取过程的输出。\n$info$（上下文信息）：可选的额外数据（如协议标识符、会话信息等），用于区分不同的密钥生成需求。\n$L$（所需密钥长度）：所需的输出密钥长度，单位是字节 $L \\leq 255 \\times \\text{HashLen}$\n\n\n输出：\n\n${OKM}$: 输出密钥材料，长度为 $L$ 字节\n\n\n\n扩展阶段通过反复调用 HMAC 来生成一个或多个块，每个块的大小为 HMAC 输出长度（HashLen），直到输出满足总长度 L。公式如下：\n$$\\begin{aligned}&amp; T_0 &#x3D; \\text{空字符串（zero-length）} \\\\&amp; T_1 &#x3D; \\mathrm{HMAC}(PRK,\\ T_0\\ \\texttt{||}\\ \\text{info}\\ \\texttt{||}\\ \\texttt{0x01}) \\\\&amp; T_2 &#x3D; \\mathrm{HMAC}(PRK,\\ T_1\\ \\texttt{||}\\ \\text{info}\\ \\texttt{||}\\ \\texttt{0x02}) \\\\&amp; T_3 &#x3D; \\mathrm{HMAC}(PRK,\\ T_2\\ \\texttt{||}\\ \\text{info}\\ \\texttt{||}\\ \\texttt{0x03}) \\\\&amp; \\vdots \\\\&amp; OKM &#x3D; T_1\\ \\texttt{||}\\ T_2\\ \\texttt{||}\\ T_3\\ \\cdots \\quad (\\text{直到达到所需长度 L})\\end{aligned}$$\nHKDF 的详细计算过程我们以 使用 SHA-256（HashLen &#x3D; 32 字节）且需要输出 64 字节密钥 为例。\n步骤 1：提取（Extract）首先，我们使用 HMAC 对 $IKM$ 和 $salt$ 进行计算，得到伪随机密钥（$PRK$）。\n$$\\mathrm{PRK} &#x3D; \\mathrm{HMAC}(\\text{salt},\\ \\text{IKM})$$\nHMAC 会根据 $SHA-256$ 哈希函数对 $salt$ 和 $IKM$ 进行计算，得到固定长度的输出，即伪随机密钥（$PRK$）。\n步骤 2：扩展（Expand）接下来，使用 $PRK$ 和 $info$ 来生成最终的密钥。在这个过程中，我们会多次使用 HMAC 来生成所需的密钥。\n1. 初始化：\n$T_0 &#x3D; “”（空字符串）$\n$PRK$ &#x3D; 来自提取阶段的 HMAC 输出（32 字节）\n$info$ &#x3D; 可选上下文信息（比如 b&quot;context info&quot;）\n\n2. 计算第一个区块 $T_1$$$T_1 &#x3D; \\mathrm{HMAC}(\\mathrm{PRK},\\ T_0\\ \\texttt{||}\\ \\text{info}\\ \\texttt{||}\\ \\texttt{0x01})$$\n\n$T_0 &#x3D; “”$\n\n拼接内容为：$info + 0x01$\n\n调用 HMAC: $HMAC(PRK, info + 0x01)$\n\n输出 $T_1$（32 字节）\n\n\n3. 计算第二个区块 $T_2$$$T_2 &#x3D; \\mathrm{HMAC}(\\mathrm{PRK},\\ T_1\\ \\texttt{||}\\ \\text{info}\\ \\texttt{||}\\ \\texttt{0x02})$$\n\n拼接内容为：$T_1 + info + 0x02$\n\n调用 HMAC: $HMAC(PRK, T_1 + info + 0x0)$\n\n输出 $T_2$（32 字节）\n\n\n4. 拼接输出$$\\mathrm{OKM} &#x3D; T_1\\ \\texttt{||}\\ T_2 &#x3D; 64\\ \\text{字节}$$\n如果需要更多字节（如 80 字节），则继续生成 $T_3$：\n$$T_3 &#x3D; \\mathrm{HMAC}(\\mathrm{PRK},\\ T_2\\ \\texttt{||}\\ \\text{info}\\ \\texttt{||}\\ \\texttt{0x03})$$\n依此类推，直到拼接够 $L$ 字节为止。\nHKDF 的安全性HKDF 的安全性依赖于 HMAC 的安全性和良好的输入选择。由于 HMAC 基于强大的哈希函数（如 $SHA-256$），并且能够有效地防止碰撞攻击、重放攻击等，它本身是非常安全的。使用高质量的盐和上下文信息（$info$）可以进一步增加安全性，防止生成相同的密钥。\n盐的作用盐（$salt$）的作用是防止相同的输入材料（$IKM$）生成相同的伪随机密钥（$PRK$）。如果不同的密钥材料没有使用盐，可能会导致同样的密钥材料每次生成相同的派生密钥，降低安全性。因此，使用随机或不可预测的盐是非常重要的。\ninfo 参数$info$ 参数的作用是提供额外的上下文信息，使得即使相同的主密钥和盐被用于生成不同的密钥，也能确保它们的差异性。例如，在 TLS 中，可以将会话ID作为 $info$ 参数，保证不同会话中生成的密钥不同。\nHKDF 的应用场景HKDF 在许多加密协议和应用中都有广泛的应用。以下是一些典型场景：\nTLS/SSL：在 TLS 连接中，HKDF 用于派生会话密钥，保证每次连接都有不同的密钥，增加安全性。\nIPSec：用于加密和认证的密钥派生。\n密码学协议：例如，密钥交换协议中，HKDF 用于从共享密钥材料中派生密钥。\nAPI 密钥生成：从主密钥生成多个 API 密钥，以便对不同的应用进行认证。\n总结HKDF 是一种非常强大的密钥派生函数，它结合了 HMAC 和两步提取、扩展的过程，能够生成高度安全的密钥。通过从主密钥材料中提取出伪随机密钥，再通过扩展生成所需的多个密钥，HKDF 提供了一个灵活且可靠的密钥派生方案。无论是在加密协议、密钥交换还是 API 认证中，HKDF 都是一个非常有用的工具。\n参考文献\nHMAC-based Extract-and-Expand Key Derivation Function (HKDF)\n\n","categories":["Cryptographic Algorithms"],"tags":["HMAC","HKDF"]},{"title":"CSS Layout","url":"/2023/09/04/css/CSS-Layout/","content":"Gridfrgrid-template-columns: 1fr, 1fr, 1fr, 1fr;grid-template-columns: repeat(4, 1fr);grid-template-columns: 1fr, 1fr, 1fr, auto;\n\ngrid-columngrid-column: 1grid-column: 1 / 4;grid-column: 1 / span 3;grid-column: 1 / -1;\n","tags":["css"]},{"title":"Reactor pattern","url":"/2023/03/06/design/reactor-pattern/","content":"什么是Reactor模式Reactor模式结构\nHandles:\nSynchronous Event Demultiplexer\nInitiation Dispatcher\nEvent Handler\nConcrete Event Handler\n\nReactor模式模块之间的交互Reactor模式实现Reactor模式优点Reactor模式的缺点\nEfficiency\nProgramming simplicity\nPortability\n\n","categories":["Design"],"tags":["Reactor"]},{"title":"Effective C++ 1：将C++视作一系列的语言","url":"/2020/12/07/effecitve-cpp/effective-cpp-1/","content":"\nItem 1: View C++ as a federation of languages\n\n一开始，Ｃ++ 只是 Ｃ 加上一些面向对象特性，Ｃ++ 最初的名称 Ｃ with Classes 也反映了这个血缘关系。现在这个语言逐渐成熟，已经是一个多重泛型编程语言(multiparadigm programming language)。同时支持过程形式(procedural)、面向对象形式(object-oriented)、函数形式(functional)、泛型形式(generic)、元编程形式(metaprogramming)\n将 C++ 视为一个由相关语言组成的联邦而非单一的语言。\nC++ 主要４个子语言：\n\nC。说到底Ｃ++仍是以Ｃ为基础。许多时候Ｃ++对问题的解法其实不过就是较高级的Ｃ的解法如item2、item13。当只使用C++中C的那部分语法，　会发现C语言的缺陷：没有模板、没有异常、没有重载。\nObject-Oriented。面向对象程序设计也是C++的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。\nTemplate C++。这是C++的泛型编程部分，大多数程序员经验最少的部分。TMP模板元编程（template metaprogramming）也是一个新兴的程序设计范式。\nSTL。STL是一个特殊的模板库，它将容器、迭代器和算法优雅地结合在一起。\n\nC++ 程序设计的惯例并非一成不变，而是取决于你使用 C++ 语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触 Object-Oriented C++ 时会发现，传常量指针是更好的选择。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。 但是你如果又碰到了STL，其中的迭代器和函数对象都是基于C语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 10：赋值运算符要返回自己的引用","url":"/2021/11/01/effecitve-cpp/effective-cpp-10/","content":"\nItem 10：Have assignment operators return a reference to *this.\n\n赋值运算符要返回自己的引用只是个协议，并无强制性。这份协议被所有内置类型和标准程序库提供的类型如string, vector, complex std::shared_ptr等共同遵守。可以用来支持链式的赋值语句。\nint x, y, z;x = y = z = 15; //赋值连锁形式\n\n相当于:\nx = ( y = ( z = 15 ) );\n\n我们自定义的对象最好也能支持链式的赋值，这需要重载&#x3D;运算符时返回当前对象的引用：\nclass Widget &#123;public:    Widget&amp; operator=(const Widget&amp; rhs)&#123;         return *this;                             &#125;    //这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算 +=, -=, *=, etc.    Widget&amp; operator+=(const Widget&amp; rhs)&#123;         return *this;    &#125;&#125;;\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 11：赋值运算符需要考虑自我赋值问题","url":"/2021/11/01/effecitve-cpp/effective-cpp-11/","content":"\nItem 11: Handle assignment to self in operator&#x3D;\n\n我们在重载一个类的赋值运算符时要考虑自我赋值的问题。有了指针和引用自我赋值不总是第一时间能够识别出来。\na[i] = a[j];*px = *py;class Base &#123; ... &#125;;class Derived: public Base &#123; ... &#125;;void doSomething(const Base&amp; rb, Derived* pd);// rb和女pd 有可能其实是同一对象rb = pd;\n\n自我赋值主要考虑到 自我赋值安全性 和 异常安全性\nclass Bitmap &#123; ... &#125;;class Widget &#123;private:    Bitmap* pb; //指针，指向一个从heap 分配而得的对象&#125;;\n\n既不自我赋值安全性也不异常安全性, 当 rhs &#x3D;&#x3D; *this时，delete pb使得rhs.pb成为空值，接下来 new 的数据便是空的。\nWidget&amp; Widget::operator=(const Widget&amp; rhs) &#123;    delete pb;    pb = new Bitmap(*rhs.pb);    return *this;&#125;\n\n判断两个地址是否相同，如果是自我赋值，就不做任何事。但开始就delete pb， 但 new 出现异常， pb就会置空出现风险。  \nWidget&amp; Widget::operator=(const Widget&amp; rhs) &#123;    if (this == &amp;rhs) return this;  // 证同测试    delete pb;    pb = new Bitmap(*rhs.pb);    return *this;&#125;\n\n在C++中仔细地排列语句顺序通常可以达到异常安全， 比如我们可以先申请空间，最后再delete：\nWidget&amp; Widget::operator=(const Widget&amp; rhs) &#123;    Bitmap *pOrig = pb;      pb = new Bitmap(*rhs.pb);    delete pOrig;    return *this;&#125;\n\n一个更加通用的技术便是复制和交换（copy and swap）：\nclass Widget &#123;    void swap(Widget&amp; rhs); // 交换*this rhs 的数据&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;    Widget temp(rhs); //rhs 数据制作一份复件(副本)    swap (temp); //*this 数据和上述复件的数据交换    return *this;&#125;","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 12：复制对象时勿忘其每一个成分","url":"/2021/11/02/effecitve-cpp/effective-cpp-12/","content":"\nItem 12: Copy all parts of an object\n\n正确拷贝函数实现：\nclass Customer&#123;  string name;public:  Customer(const Customer&amp; rhs): name(rhs.name)&#123;&#125;  Customer&amp; operator=(const Customer&amp; rhs)&#123;    name = rhs.name;                     // copy rhs&#x27;s data    return *this;                        // see Item 10  &#125;  &#125;;\n\n情形一： 新添加了一个数据成员，忘记了更新拷贝函数class Customer&#123;  string name;  Date lastTransaction;public:  Customer(const Customer&amp; rhs): name(rhs.name)&#123;&#125;  Customer&amp; operator=(const Customer&amp; rhs)&#123;    name = rhs.name;                     // copy rhs&#x27;s data    return *this;                        // see Item 10  &#125;  &#125;;\n\n这时 lastTransaction 便被你忽略了，编译器也不会给出任何警告（即使在最高警告级别）\n情形二： 继承父类忘记了拷贝父类的部分class PriorityCustomer: public Customer &#123;    int priority;public:  PriorityCustomer(const PriorityCustomer&amp; rhs)  : priority(rhs.priority)&#123;&#125;    PriorityCustomer&amp;   operator=(const PriorityCustomer&amp; rhs)&#123;    priority = rhs.priority;  &#125;  &#125;;\n\n正确写法:\nclass PriorityCustomer: public Customer &#123;    int priority;public:  PriorityCustomer(const PriorityCustomer&amp; rhs)  : Customer(rhs), priority(rhs.priority)&#123;&#125;    PriorityCustomer&amp;   operator=(const PriorityCustomer&amp; rhs)&#123;    Customer::operator=(rhs);    priority = rhs.priority;  &#125;  &#125;;","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 13：以对象管理资源","url":"/2021/11/02/effecitve-cpp/effective-cpp-13/","content":"\nItem 13: Use objects to manage resources.\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 14：在资源管理类中小心 copying 行为","url":"/2021/11/05/effecitve-cpp/effective-cpp-14/","content":"\nItem 14: Think carefully about copying behavior in resource-managing classes.\n\n设计一个 RAII 对象：\nclass Lock &#123;public:    explicit Lock(Mutex *pm):mutexPtr(pm)&#123;        lock(mutexPtr);    &#125;    ~Lock()&#123; unlock(mutexPtr); &#125;private:    Mutex *mutexPtr;&#125;;\n客户对Lock的使用：\nMutex m;...&#123;    Lock ml(&amp;m);        ...&#125;\n\n当一个 RAII 对象被复制，会发生什么事？ 不确定？\nLock ml1(&amp;m);Lock ml2(&amp;ml1)\n\n记住资源管理对象的拷贝行为取决于资源本身的拷贝行为，同时资源管理对象也可以根据业务需要来决定自己的拷贝行为。一般有如下四种方式：\n\n禁止复制。参考若不想使用编译器自动生成的函数，就该明确拒绝。对Lock而言看起来是这样：\n  class Lock : private Uncopyable &#123;public:    ...&#125;\n引用计数，采用 shared_ptr 的逻辑。shared_ptr 构造函数提供了第二个参数 deleter，当引用计数到 0 时被调用。 所以 Lock 可以通过聚合一个 shared_ptr 成员来实现引用计数：\n  class Lock&#123;public:     explicit Lock(Mutex *pm): mutexPtr(pm, unlock)&#123;        lock(mutexPtr.get());    &#125;private:     std::shared_ptr&lt;Mutex&gt; mutexPtr; //shared_ptr替换 raw pointer&#125;;\n   Lock 的析构会引起 mutexPtr 的析构，而 mutexPtr 计数到0时unlock(mutexPtr.get()) 会被调用。\n\n拷贝底部资源。复制资源管理对象时，进行的是深拷贝。比如 string 的行为：内存存有指向对空间的指针，当它被复制时会复制那片空间。\n\n转移底部资源的拥有权。auto_ptr 就是这样做的，把资源移交给另一个资源管理对象，自己的资源置空。\n\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 16：使用同样的形式来new和delete","url":"/2021/11/08/effecitve-cpp/effective-cpp-16/","content":"\nItem 16: Use the same form in corresponding uses of new and delete.\n\n如果你用 new 申请了动态内存，请用 delete 来销毁；如果你用 new xx[] 申请了动态内存，请用 delete[] 来销毁: \n举个栗子：\nstd::string* stringPtrl = new std::string;std::string* stringPtr2 = new std::string[lOO];...delete stringptrl;      // 删除一个对象delete [] stringPtr2;  // 删除一个由对象组成的数组\n\n上面很容易理解但需要注意typedef:\ntypedef std::string AddressLines[4];    //每个人的地址有四行，                                        //每行是一个string\n\n由于 AddressLines 是个数组，如果这样使用 new:\nstd::string *pal = new AddressLines;     //注意. &quot;new AddressLines&quot; 返回                                         //一个 string*，就像 &quot;new string[4]&quot; 一样\n那就必须匹配 “数组形式“的 delete:\ndelete pal;         //行为未有定义!delete [] pal;     //很好。\n\n为避免诸如此类的错误，最好尽量不要对数组形式做 typedefs 动作。可以使用更加面向对象的vector、string等对象。\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 15：在资源管理类中提供对原始资源的访问","url":"/2021/11/05/effecitve-cpp/effective-cpp-15/","content":"\nItem 15: Provide access to raw resources in resource-managing classes.\n\nAPIs 往往要求访问原始资源(raw resources)，所以每一个RAII class 应该提供提供对原始资源访问的方法。获取资源的方式有两类：隐式地获取和显式地获取。 显式的资源获取会更安全，它最小化了无意中进行类型转换的机会。\n\n显示获取\n\nshared_ptr 提供了 get 方法来得到资源。\nshared_ptr&lt;Investment&gt; pInv;void daysHeld(Investment *pi);int days = daysHeld(pInv.get());\n\n为了让 pInv 表现地更像一个指针，shared_ptr还重载了解引用运算符（dereferencing operator） operator-&gt;和 operator*：\nclass Investment&#123;public:     bool isTaxFree() const;&#125;;shared_ptr&lt;Investment&gt; pi1(createInvestment());bool taxable1 = !(pi1-&gt;isTaxFree());bool texable2 = !((*pi1).isTaxFree());\n\n我们封装了Font来管理资源：\nclass Font&#123;FontHandle f;public:    explicit Font(FontHandle fh): f(fh)&#123;&#125;    ~Font()&#123; releaseFont(f); &#125;;    FontHandle get() const &#123; return f; &#125;&#125;;\n通过get方法来访问FontHandle：\nFont f(getFont());int newFontSize;changeFontSize(f.get(), newFontSize);\n\n\n隐式地获取\n\n可以隐式类型转换运算符将 Font 转换为 FontHandle:\nclass Font&#123;    operator FontHandle() const&#123; return f;&#125;&#125;;changeFontSize(f, newFontSize);\n\n然而问题也随之出现：\nFontHandle h2 = f1;\n无意间 h2 并没有被资源管理起来，这将会引发意外的资源泄漏。所以隐式转换在提供便利的同时， 也引起了资源泄漏的风险。 \n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 17：在单独的语句中将 new 的对象放入智能指针","url":"/2021/11/08/effecitve-cpp/effective-cpp-17/","content":"\nItem 17: Store newed objects in smart pointers in standalone statements.\n\n以单独的语句将 new 的对象放入智能指针内。这是为了防止由于其他表达式抛出异常而导致的资源泄漏。\n举个栗子：\nprocessWidget(shared_ptr&lt;Widget&gt;(new Widget), priority());\n\n上述代码中，在 processWidget 函数被调用之前参数会首先得到计算。可以认为包括三部分的过程：\n\n执行 new Widget\n构造 shared_ptr&lt;Widget&gt;\n调用 priority()\n\n因为C++不同于其他语言，函数参数的计算顺序很大程度上决定于编译器，编译器认为顺序应当是1, 3, 2，即：\n\n执行 new Widget\n调用 priority()\n构造 shared_ptr&lt;Widget&gt;\n\n那么如果 priority抛出了异常，新的 Widget 便永远地找不回来了。虽然我们使用了智能指针，但资源还是泄漏了！\n于是更加健壮的实现中，应当将创建资源和初始化智能指针的语句独立出来：\nshared_ptr&lt;Widget&gt; pw = shared_ptr&lt;Widget&gt;(new Widget);processWidget(pw, priority());","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 19：设计 class 犹如设计 type","url":"/2021/11/11/effecitve-cpp/effective-cpp-19/","content":"\nItem 19: Teat class design as type design.\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 2：尽量以const, enum, inline 替换 &#35;define","url":"/2020/12/14/effecitve-cpp/effective-cpp-2/","content":"\nItem 2: Prefer consts, enums, and inlines to #defines\n\n我们先看看#deifne 有哪些的问题:\n不利于调试#define ASPECT_RATION 1.653\n在预处理时候 ASPECT_RATION 可能就被移走了,ASPECT_RATION 没有进入 符号表, 运行此常量获得编译错误信息时, 可能会疑惑。因为这个错误信息总是提到 1.653，而不是ASPECT_RATION ， 如果 ASPECT_RATION 定义不是自己写的头文件中，可能对 1.653 的来源毫无概念，将因追踪它浪费时间，解决之道是以一个常量替换上述宏 。\nconst double AspectRatio = 1.653 //大写名称通常用于宏                                 //因此这里改变名称写法\n作为一个语言常量，ASPECT_RATION 肯定会被编译器看到，当然会进入记号表内。此外对于浮点常量(floating point constant)而言，使用常量可能比使用#define 导致较少量的码。\n不重视scope无法利用 #define 创建class专属常量。一旦宏定义，它就在其后的编译过程中有效（除非在某处 #undef ）。而 const 可以。\nclass GamePlayer &#123;private:    static const int NumTurns; //常量声明式    int scores[NumTurns];      //使用该常量&#125;\n\nenum 比 const 更好用旧式编译器也许不支持上述语法，　它们不允许static在声明式上获得初值，此外所谓的“in-classs　初值设定”也只运行对整数常量进行，　如果编译器不支持上述语法，可以将初值放在定义式\nclass CostEstimate &#123;public:    static const double FudgeFactor;  //staitc class　常量声明位于头文件内&#125;const double CostEstimate::FudgeFactor = 1.35; //staitc class　常量定义位于实现文件内\n如果使用emnu就很简单：\nclass GamePlayer &#123;private:    enum &#123; NumTurns = 5 &#125;;    int scores[NumTurns];　//the enum hack&#125;\n　\n不易理解#define CALL_WITH_MAX(a, b)  f((a) &gt; (b) ? (a) : (b))int a = 5, b =0;CALL_WITH_MAX(++a, b);     　//ａ被累加二次CALL_WITH_MAX(++a, b + 10);　//ａ被累加一次\n\n\n必须记住为宏的所有实参加上小括号\n在这里调用ｆ之前，ａ的递增次取决与“它被拿来与谁比较”\n\n更好的做法是使用　template inline　函数。\ntemplate &lt;typename T&gt;inline void callWithMax(const T &amp;a, const T &amp;b)&#123;    return (a &gt; b ? a : b);&#125;\n\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 20：传常量引用比传值更好","url":"/2022/03/23/effecitve-cpp/effective-cpp-20/","content":"\nItem 20: Prefer pass-by-reference-to-const to pass-by-value.\n\n缺省情况下C++ 用传值得方式(一个继承自C的方式)传递对象至(或来自)函数。除非你另外指定，否则函数参数都是以实际实参的复件(副本)为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件(副本)系由对象的copy构造函数产出。\n尽量以传常量引用替换传值前者通常比较高效，并可避免切割问题 (slicing problem)，但是内置类型和 STL 迭代器，还是传值更加合适。。\n\n\n性能问题:class Person &#123;public:    Person ();    virtual -Person();private:    std::string name;    std::string address;&#125;class Student: public Person &#123;public:    Student();    -Student();private:    std::string schoolName;&#125;\n\n现在考虑以下代码，其中调用函数 validateStudent ，后者需要一个 Student(by value) 并返回它是否有效:\nbool validateStudent(Student s);           // function taking a Student by valueStudent plato;                             // Plato studied under Socratesbool platoIsOK = validateStudent(plato);   // call the functio\n\n在调用 validateStudent() 时进行了 6 个函数调用：\n\nPerson 的拷贝构造函数，为什么 Student 的拷贝构造一定要调用 Person 的拷贝构造请参见：Item:12 复制对象时勿忘其每一个成分\nStudent 的拷贝构造函数\nname, address, schoolName, schoolAddress 的拷贝构造函数\n\n解决办法便是传递常量引用：\nbool validateStudent(const Student&amp; s);\n\n首先以引用的方式传递，不会构造新的对象，避免了上述例子中 6 个构造函数的调用。 同时 const 也是必须的：传值的方式保证了该函数调用不会改变原来的 Student， 而传递引用后为了达到同样的效果，需要使用 const 声明来声明这一点，让编译器去进行检查!\n截断问题class Window &#123;public:...std::string name() const;           // return name of windowvirtual void display() const;       // draw window and contents&#125;;class WindowWithScrollBars: public Window &#123;public:...virtual void display() const;&#125;;\n\n现在假设你希望写个函数打印窗口名称，然后显示该窗口:\nvoid printNameAndDisplay(Window w)    std::cout &lt;&lt; w.name();    w.display() ;&#125;WindowWithScrollBars wwsb;printNameAndDisplay(wwsb);\n\n当调用 printNameAndDisplay 时参数类型从 WindowWithScrollBars 被隐式转换为 Window。 该转换过程通过调用 Window 的拷贝构造函数来进行。 导致的结果便是函数中的 w 事实上是一个 Window 对象， 并不会调用多态子类 WindowWithScrollBars 的 display()。\n正确做法：\n// fine, parameter won&#x27;t be slicedvoid printNameAndDisplay(const Window&amp; w)&#123;     std::cout &lt;&lt; w.name();    w.display();&#125;\n\n特殊情况一般情况下相比于传递值，传递常量引用是更好的选择。但也有例外情况，比如 内置类型 和 STL 迭代器和函数对象。\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 21：需要返回对象时，不要返回引用","url":"/2022/03/23/effecitve-cpp/effective-cpp-21/","content":"\nItem 21: Don’t to return a reference when you must return an object.\n\nItem 20 中提到，多数情况下传引用比传值更好。但不要无脑追求这一点，一定不要返回空引用或指针。\n\n\n举个栗子：\nclass Rational&#123;  int n, d;public:  Raitonal(int numerator=0, int denominator=1);&#125;;// 返回值为什么是const请参考Item 3friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);Rational a, b;Rational c = a*b;\n这个版本的 operator* 返回的是一个实例，a*b时便会调用operator*()， 返回值被拷贝后用来初始化c。\n不考虑编译器优化和 C11 的 move ,这个过程涉及到多个构造和析构过程：\n\noperator*调用结束前，返回值被拷贝，调用拷贝构造函数\noperator*调用结束后，返回值被析构\nc 被初始化，调用拷贝构造函数\n\n我们能否通过传递引用的方式来避免这些函数调用？这要求在函数中创建那个要被返回给调用者的对象，而函数只有两种办法来创建对象：在栈空间中创建、或者在堆中创建。\n在栈空间中创建显然是错误的：\nconst Rational&amp; operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;  Rational result(lhs.n*rhs.n, lhs.d*rhs.d);  return result;&#125;\n我们的目标是要避免调用构造函数，而 result 却必须像任何对象一样地由构造函数构造起, 而且得到的 result 永远是空。因为 result 是一个 local 对象，当函数调用结束后 result即被销毁。\n在堆中创建也会问题:\nconst Rational&amp; operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;  Rational *result  = new Rational(lhs.n*rhs.n, lhs.d*rhs.d);  return *result;&#125;\n\n首先还是得必须付出一个”构造函数调用”代价， 并且谁去 delete?\nRational w, x, y, z;w = x*y*z;\n\n上面这样合理的代码都会导致内存泄露。\n使用静态变量的方式：\nconst Rational&amp; operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;    static Rational result; // static 对象，此函数将返回    result = ... ; // lhs 乘以 rhs. 并将结果置于 result 内。    return result;&#125;\n\n静态变量首先便面临着线程安全问题，除此之外当我们需要不止一个的返回值同时存在时也会产生问题：\nif((a*b) == (c*d))&#123;  // ...&#125;\n\n如果operator*的返回值是静态变量，那么上述条件判断恒成立，因为等号两边是同一个对象。所以我们还是老老实实返回对象实例就好，并且考虑到编译器优化和move语意，拷贝构造返回值带来的代价没那么高。\n永远不要返回局部对象的引用或指针或堆空间的指针，如果需要多个返回对象时也不能是局部静态对象的指针或引用。Item:4 确定对象被使用前已先被初始化， 对于单例模式，返回局部静态对象的引用也是合理的。\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 18：让接口容易被正确使用，不易被误用","url":"/2021/11/08/effecitve-cpp/effective-cpp-18/","content":"\nItem 18: Make interfaces easy to use correctly and hard to use incorrectly.\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 22：将成员变量声明为private","url":"/2022/03/23/effecitve-cpp/effective-cpp-22/","content":"\nItem 22: Declare data members private.\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 23：用非成员函数、非友元函数替换成员函数","url":"/2022/04/09/effecitve-cpp/effective-cpp-23/","content":"\nItem 23: Prefer non-member non-friend functions to member functions\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 24：若所有参数皆需类型转换，请采用非成员函数","url":"/2022/04/09/effecitve-cpp/effective-cpp-24/","content":"\nItem 24: Declare non-member functions when type conversions should apply all parameters.\n\n令 classes 支持隐式转换通常是糟糕的设计，但也有例外，最常见的是在建立数值类型时。 比如设计一个有理数 class 允许整数隐式转换。\n\n\nclass Rational &#123;public:    Rational(int numerator = 0, int denominator = 1); //构造函数刻意不使用 explicit; 允许 int-to-Rational 隐式转换。    int numerator() const;    int denominator() const;private:    ...&#125;;\n\n这时我们想设计一个乘法，该使用 member 函数，还是 non-member 函数， 还是 non-member-friend 函数？\n我们先采用 member 函数看有什么问题？\nclass Rational &#123;public:    ...    const Rational operator* (const Rational&amp; rhs) const;&#125;;\n\n我们使用如下没有什么问题：\nRational oneEighth(1, 8);Rational oneHalf(1, 2);Rational result = oneEighth * oneHalf; //okresult = result * oneEighth;  // ok\n\n但当我们想支持混合运算，那 Rational 和 ints 相乘, 就只有一半行的通。\nresult = oneHalf * 2; //ok  隐式转换result = 2 * oneHalf;  // no\n\n当我们设计成 non-member 函数就都支持：\nclass Rational &#123;    ...&#125;;const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs) &#123;    return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator(), rhs.denominator());&#125;    \n\nRational oneFourth(1, 4);Rational result;result = oneFourth * 2;  // okresult = 2 * oneFourth;  // ok \n\n如果需要为某个函数的所有参数进行类型转换，那这个函数必须是 non-member\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 25：设计一个不抛异常的 swap 函数","url":"/2022/04/09/effecitve-cpp/effective-cpp-25/","content":"\nItem 25: Consider support for a non-throwing swap.\n\nswap 函数能置换两对象值，功能很重要!\n\n异常安全性编程\n处理自我赋值可能性：赋值运算符需要考虑自我赋值问题\n\nstd 的缺省基本实现如下：\nnamespace std &#123;    template &lt;typename T&gt;    void swap(T&amp; a, T&amp; b) &#123;        T temp(a);        a = b;        b = temp;    &#125;&#125;\n\n\n类的 swap只要类型 T 支持 copying运算(拷贝构造和拷贝赋值运算)就能使用。 但缺省实现会有多次拷贝，在某些情况下不是性能最好的实现。比如针对 pimpl 手法实现的 class, 不仅要复制三次 Widget 还需要复制三次 WdigetImpl, 非常缺乏效率。\nclass WidgetImpl &#123;public:    ...private:    int a, b, c;    std::vector&lt;double&gt; v;    ...&#125;;class Widget &#123;public:    Widget(const Widget&amp;);    Widget&amp; operator= (const Widget&amp; rhs) &#123;        ...        *pImpl = *(rhs.pImpl);        ...    &#125;private:    WidgetImpl *pImpl;&#125;;\n\n其实我们发现这种情况只需要将 pImpl 指针交换就好， 我们可以将 std::swap 对 Widget 的特化来实现.\nnamespace std &#123;    template &lt;&gt;    void swap&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;        swap(a.pImpl, b.pImpl);    &#125;&#125;\n但上述代码不能通过编译， 因为 pImpl 是私有变量， 所以，Widget 应当提供一个 swap 成员函数或友元函数。 惯例上会提供一个成员函数：\nclass Widget &#123;public:    ...        void swap(Widget&amp; other) &#123;        using std::swap; // 为何要这样？请看下文        swap(pImpl, other.pImpl);    &#125;    ...&#125;;namespace std &#123;  template&lt;&gt;  void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;      a.swap(b);              // 调用成员函数  &#125;&#125;\n上述实现与 STL 容器是一致的：提供公有 swap 成员函数， 并特化 std::swap 来调用那个成员函数。\n类模板的 swap如果 Widget 和 WidgetImpl 是 class templates 而非 classes, 按照上面的 swap 实现方式，你可能会这样写：\ntemplate&lt;typename T&gt;class Widget&#123;  ... &#125;;template&lt;typename T&gt;class WidgetImpl&#123; ... &#125;;namespace std &#123;    template&lt;typename T&gt;    void swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;        a.swap(b);    &#125;&#125;\n\n但上述代码不能通过编译， c++ 允许偏特化类模版，却不允许偏特化函数模版(虽然有的编译器中可以编译)。那我们继续尝试重载 std::swap  函数：\nnamespace std&#123;    template&lt;typename T&gt;    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;        return a.swap(b);    &#125;&#125;\n\n这里我们重载了 std::swap，相当于在 std 命名空间添加了一个函数模板。但这在 C++ 标准中是不允许的！ C++ 标准中，客户只能特化 std 中的模板，但不允许在 std 命名空间中添加任何新的模板。 上述代码虽然在有些编译器中可以编译，但会引发未定义的行为，所以不要这么做。所以我们最终可以把 swap 定义在 Widget 所在的命名空间中：\nnamespace WidgetStuff &#123;    template&lt;typename T&gt;     class Widget &#123; ... &#125;;    template &lt;typename T&gt;    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;        return a.swap(b);    &#125;&#125;\n\n任何地方在两个 Widget 上调用 swap 时，C++ 根据其 argument-dependent lookup（又称 Koenig lookup） 会找到 WidgetStuff 命名空间下的具有 Widget 参数的 swap。\n其实类的 swap 也可以在同一命名空间下定义 swap 函数，而不必特化 std::swap。 但有人可能直接写 std::swap(w1, w2)，特化 std::swap 可以让你的类更加健壮。\n在成员函数中不要直接调用 swap(pImpl, other.pImpl); 因为指定了调用 std::swap，argument-dependent lookup 便失效了，WidgetStuff::swap 不会得到调用。\n如果希望优先调用 WidgetStuff::swap，如果未定义则取调用 std::swap，那么应该如何写呢？ 看代码：\ntemplate&lt;typename T&gt;void doSomething(T&amp; obj1, T&amp; obj2)&#123;  using std::swap;           // 使得 std::swap 在该作用域内可见  swap(obj1, obj2);          // 现在，编译器会帮你选最好的 swap&#125;\n\n此时，C++ 编译器还是会优先调用指定了 T 的 std::swap，其次是 obj1 的类型 T 所在命名空间下的对应 swap 函数， 最后才会匹配 std::swap 的默认实现。\n总结如何实现 swap 呢？\n\n提供一个更加高效的，不抛异常的公有成员函数（比如 Widget::swap）。\n在你类（或类模板）的同一命名空间下提供非成员函数 swap，调用你的成员函数。\n如果你写的是类而不是类模板，也可以特化 std::swap，同样地在里面调用你的成员函数。\n调用时，请首先用 using 使 std::swap 可见，然后直接调用 swap。\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 26：尽可能推迟变量的定义","url":"/2022/04/15/effecitve-cpp/effective-cpp-26/","content":"\nItem 26:Postpone variable definitions as long as possible.\n\n推迟变量的定义有两个好处：\n\n改善程序效率，减少无用的构造和析构。\n增加程序流程清晰度。\n\n这条规则看似简单，但存在流程控制语句的时候容易疏忽。如：\nstring encryptPassword(const string&amp; password)&#123;    string encrypted;    if (password.length() &lt; MinimumPasswordLength) &#123;        throw logic_error(&quot;Password is too short&quot;);    &#125;    encrypted = password;    encrypt(encrypted);    return encrypted;&#125;\n\n\n\n推迟到需要构造时执行当 encryptPassword 抛出异常时，encrypted 是无用的, 根本不需要构造它。所以更好的写法是推迟 encrypted 的构造：\nstring encryptPassword(const string&amp; password)&#123;    if (password.length() &lt; MinimumPasswordLength) &#123;        throw logic_error(&quot;Password is too short&quot;);    &#125;    string encrypted;       // 默认构造函数    encrypted = password;   // 赋值运算符    encrypt(encrypted);    return encrypted;&#125;\n\n推迟到有构造参数时 “尽可能延后” 的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的 default 构造行为。\nstring encryptPassword(const string&amp; password)&#123;    if (password.length() &lt; MinimumPasswordLength) &#123;       throw logic_error(&quot;Password is too short&quot;);    &#125;    string encrypted(password);     // 拷贝构造函数    encrypt(encrypted);    return encrypted;&#125;\n\n循环中的变量循环中的变量定义也是一个常见的争论点。常有两种写法：\n写法 A，在循环外定义：\nWidget w;for (int i = 0; i &lt; n; ++i)&#123;   w = some value dependent on i;  ...                           &#125;                  \n\n写法 B ，在循环内定义：\nfor (int i = 0; i &lt; n; ++i) &#123;    Widget w(some value dependent on i);    ...&#125;\n\n\nA：1 个构造函数，1 个析构函数，n 个赋值运算符\nB：n 个构造函数，n 个析构函数\n\n但 A 使得循环内才使用的变量进入外部的作用域，不利于程序的理解和维护。软件工程中倾向于认为人的效率比机器的效率更加难得， 所以推荐采用 B 来实现。除非：\n\n这段代码是性能的关键.\n赋值比一对构造&#x2F;析构更加廉价。\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 3：尽可能使用 const","url":"/2021/01/05/effecitve-cpp/effective-cpp-3/","content":"\nItem3: Use const whenever possible.\n\n常量的声明指针的常量声明：\nchar greeting[] = &quot;Hello&quot;;char* p = greeting;                 //non-const pointer, non-const dataconst char* p = greeting;           //non-const pointer, const datachar* const p = greeting;           //const pointer, non-const dataconst char* const p = greeting;     //const pointer, const data\n如果 const 出现在*左边，表示被指物为常量;　如果出现在*右边，表示指针自身为常量；如果出现在*两边，表示被指物和指针两者都是常量。\n如果被指物是常量，const 放在类型之前和放在类型之后*之前表示的意义一样：\nvoid f1(const Widget* p);　//f1　获得一个指针，指向一个常量Ｗidget对象void f2(widget const *p);　//f2 也是\n\n\nSTL的iterator 系以指针塑模出来，所以iterator的作用像个T*指针。如果希望指针是常量，可以声明为 const iterator，如果希望被指物为常量，需使用 const_iterator\nstd::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();    //iter的作用像个Ｔ* const*iter = 10;                                             //没问题，改变iter所指物  ++iter;　　　　　　　　　　　　　　　　　　　　　　 　　　　     //错误，iter是conststd::vector&lt;int&gt;::const_iterator cIter = vec.begin();   //cIter的作用像个const Ｔ**cIter = 10;                                            //错误，*cIter是const++cIter;                                                //没问题，　改变cIter\n返回值声明为常量，可以降低代码被错误使用:\nclass Rational　&#123;...&#125;;const Rational operator*&#123;const Rational&amp; lhs, const Rational&amp; rhs&#125;;\n当我们本来想做个比较，错误地输入=\nif (a * b = c) ...\n编译器就会报错误：不可给常量赋值。\nconst 成员函数声明const 成员函数，是为了确认该成员函数可以作用与const对象，也使class接口比较容易理解，可以得知哪些函数可以改动对象内容，哪些不可以。\n成员函数只是常量性不同是可以被重载。\nclass TextBlock &#123;public:  ...  const char&amp; operator[](std::size_t position) const   // operator[] for  &#123; return text[position]; &#125;                           // const objects  char&amp; operator[](std::size_t position)               // operator[] for  &#123; return text[position]; &#125;                           // non-const objectsprivate:   std::string text;&#125;;TextBlock tb(&quot;Hello&quot;);const TextBlock ctb(&quot;World&quot;);tb[0] = &#x27;x&#x27;;             // fine — writing a non-const TextBlockctb[0] = &#x27;x&#x27;;            // error! — writing a const TextBlock\n\nbitsise constness 和　logical constnessbitsise constness: 成员函数只有在不改变对象的任何非静态成员变量时才可以被称为常量函数。也是C++对常量性的定义。\nclass TextBlock&#123;   public:    char&amp; operator[](std::size_t position) const&#123;        return pText[position];    &#125;private:    char* pText;&#125;;const TextBlock tb;char *p = &amp;tb[1];*p = &#x27;a&#x27;;\n\n\n\n在const和non-const成员函数中避免重复当const和non-const成员函数有着实质等价的实现时，令non-const函数调用const函数可以避免代码重复。不可以反着来。\nconst char&amp; operator[](std::size_t position) const &#123;    ...    return text[position]&#125;char&amp; operator[](std::size_t position) &#123;    return const_cast&lt;char&amp;&gt;(        static_cast&lt;const TextBlock&amp;&gt;(*this)            [position]        )&#125;\n\n\n*this 的类型是 TextBlock，先把它强制隐式转换为 const TextBlock，这样我们才能调用那个常量方法。\n调用 operator[](std::size_t) const，得到的返回值类型为 const char&amp;。\n把返回值去掉 const 属性，得到类型为 char&amp; 的返回值。\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 4：确定对象被使用前已先被初始化","url":"/2021/01/13/effecitve-cpp/effective-cpp-4/","content":"\nItem 4: Make sure that objects are initialized before they’re used.\n\n手工初始化内置对象为内置对象进行手工初始化，因为C++不保证初始化他们。\nint x = 0;                                  //对 int 进行手工初始化const char *text = &quot;A C-style string&quot;;      //对指针进行手工初始化double d;std::cin &gt;&gt; d;                              //以读取 input stream 的方式完成初始化\n\n构造函数最好使用成员初值列class PhoneNumber &#123; ... &#125;class ABEntry &#123;public:    ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phones);private:    std::string theName;    std::string theAddress;    std::list&lt;PhoneNumber&gt; thePhones;    int numTimesConsulted;&#125;ABEntry::ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phones) &#123;    theName = name;             //这些都是赋值    theAddress = address;       //而非初始化    thePhones = phones;    numTimesConsulted = 0; &#125;\n\n构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在class中的声明次序相同。\nABEntry::ABEntry(const std::string &amp;name, const std::string &amp;address, const std::list&lt;PhoneNumber&gt; &amp;phones) : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) &#123;&#125;\n\nlocal static 对象替换 non-local static 对象。为免除”\b跨单元之初始化次序“问题，请以 local static 对象替换 non-local static 对象。\nclass FileSystem &#123;public:    ...    std::size_t numDisks() const;    ...&#125;extern FileSystem tfs;     \n\nclass Directory &#123;public:    Directory( params );    ...&#125;Directory::Directory( params) &#123;    ...    std::size_t disks = tfs.numDisks();    ...    &#125;\n客户使用使用：\nDirectory tempDir( params );\n现在初始化次序的重要性体现出来了，除非 tfs 在 tempDir 之前先被初始化，否则tempDir的构造函数会用到尚未初始化的tfs。但tfs和tempDir是不同的人在不同的时间于不同的源文件建立起来的，它们是定义于不同编译单元内的 non-local static 对象。它们初始化相对次序并无明确定义。但我们可以将 local static 对象替换non-local static 对象来解决。这也是Singleton模式的常见实现手法。\n这个手法的基础在于：C++保证，函数内的 local static 对象会在调用该函数时首次遇上该对象的定义式时被初始化。\nclass FileSystem &#123; ... &#125;FileSystem&amp; tfs() &#123;    static FileSystem fs;    return fs;&#125;    \n\nclass Directory &#123; ... &#125;Directory::Directory( params) &#123;    ...    std::size_t disks = tfs().numDisks();    ...    &#125;Directory&amp; tempDir()&#123;    static Directory td;    return td;&#125;\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 5：了解c++默默编写并调用哪些函数","url":"/2021/10/24/effecitve-cpp/effective-cpp-5/","content":"\nItem 5: Know what functions C++ silently writes and calls\n\n默认函数在 C++ 中，一个类有八个默认函数：\nclass Empty &#123;    Empty () &#123;&#125; //默认构造函数        Empty (const Empty &amp;) &#123;&#125; // 默认拷贝构造函数    Empty (const Empty &amp;&amp;) &#123;&#125; // 默认移动构造函数(`C++11`)    ~Empty() &#123;&#125; // 默认析构函数    Empty&amp; operator=(const Empty&amp;) &#123;&#125; // 默认重载赋值运算符函数    Empty&amp; operator=(const Empty&amp;&amp;)&#123;&#125; // 默认重载移动赋值操作符函数函数    Empty* operator &amp;() &#123;&#125; // 默认重载取址运算符函数    const Empty* operator &amp;() const &#123;&#125; // 默认重载取址运算符 `const` 函数&#125;;\n\n调用时机只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。\n引用成员如果你打算在一个“内含引用成员”或者“内含const成员”的类内支持赋值操作，就必须定义自己的默认拷贝赋值操作符。因为 C++ 本身不允许引用改指不同的对象，也不允许更改 const 成员。\nclass Person &#123;public:    string &amp; name;    Person(string &amp;str):name(str) &#123;&#125;&#125;;string s1 = &quot;hello&quot;, s2 = &quot;world&quot;;Person p1(s1), p2(s2);p1 = p2;\n\nerror: object of type &#x27;Person&#x27; cannot be assigned because its copy assignment operator is implicitly deleted","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 28：避免返回 handles 指向对象内部成分","url":"/2022/04/16/effecitve-cpp/effective-cpp-28/","content":"\nItem28: Avoid returning “handles” to object internals.\n\n避免返回 handles (包括 references 、指针、迭代器)指向对象内部。\n\n\n破坏封装性const 函数不再是 const, 修改了私有成员变量。\nclass Point &#123;public:    Point(int x, int y);    ...    void setX(int x);    void setY(int y);    ...&#125;;struct RectData &#123;    Point ulhc;    Point lrhc;&#125;;class Rectangle &#123;    ...    Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;    Point&amp; lowerRight() const &#123; return pData-&gt;lrhc; &#125;    ...private:    std::shared_ptr&lt;RectData&gt; pData;&#125;\n虽然这样的设计可通过编译，但却是错误的。upperLeft 和 lowerRight 被声明为 const 成员函数，但是可以更改内部数据。\nPoint coord1(0, 0);Point coord2(100, 100); const Rectangle rec(coord1, coord2); // rec是个const矩形, 从 (0 ，0) 到 (100 ， 100)rec.upperLeft( ) .setX(50);  // 现在rec却变成从 (50 ， 0) 到 (100 ， 100)\n\n\n成员变量的封装性最多只等于”返回其 reference“ 的函数的访问级别。\n如果 const 成员函数传出一个 reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。(bitwise constness原因)\n\n悬空问题虽然我们可以修改函数，达到不能修改私有成员变量。\nconst Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;\n但也不能解决悬空问题。如下：\nclass GUIObject &#123; ... &#125;;const Rectangle boundingBox(const GUIObject&amp; obj); //以 by value 方式返回一个矩形\n\n现在，客户有可能这么使用这个函数:\nGUIObject* pgo; // 让pgo指向某个GUIObject...const Point* pUpperLeft = &amp;(boundingBox(*pgo) .upperLeft()); // 取得一个指针指向外框左上点\n\npUpperLeft 被悬空了，boundingBox(*pgo) 返回的是一个临时变量，在语句执行结束后就会销毁，导致 pUpperLeft 指针失效。\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝","url":"/2021/10/25/effecitve-cpp/effective-cpp-6/","content":"\nItem 6: Explicitly disallow the use of compiler-generated functions you do not want.\n\n在C++中，编译器会自动生成一些你没有显式定义的函数。可以参考:了解c++默默编写并调用哪些函数然而有时候我们希望禁用掉这些函数，可以通过把自动生成的函数设为 private 来禁用它或者在 c++11 中使用 delete 关键字。\n比如我们禁用拷贝的功能：\nclass HomeForSale&#123;public:    ...    private:    HomeForSale(const HomeForSale &amp;);  // 只有声明    HomeForSale&amp; operator=(const HomeForSale&amp;) = delete； // c++11&#125;;\n\n我们可以专门设计一个阻止copying 的类\nnamespace noncopyable_ &#123;    class noncopyable &#123;        protected:            noncopyable() &#123;&#125;            ~noncopyable()&#123;&#125;            /** C++11            noncopyable() = default;            ~noncopyable() = default;            */        private:            noncopyable(const noncopyable&amp;);            noncopyable&amp; operator=( const noncopyable&amp; );            /** C++11            noncopyable( const noncopyable&amp; ) = delete;            noncopyable&amp; operator=( const noncopyable&amp; ) = delete;            */    &#125;;&#125;\n\nclass HomeForSale : private noncopyable_::noncopyable&#123;&#125;;HomeForSale p1, p2;p1 = p2;error: object of type &#x27;HomeForSale&#x27; cannot be assigned because its copy assignment operator is implicitly deleted    p1 = p2;       ^","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 7：为多态基类声明 virtual 析构函数","url":"/2021/10/25/effecitve-cpp/effective-cpp-7/","content":"\nItem 7: Declare destructors virtual in polymorphic base classes.\n\n析构函数声明为虚函数目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。 否则子类部分的内存将会泄漏，正确的用法如下：\n// 基类class TimeKeeper&#123;public:    virtual ~TimeKeeper();    ...&#125;;TimeKeeper *ptk = getTimeKeeper():  // 可能返回任何一种子类...delete ptk;\n\n\npolymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。\nClasses 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性(polymorphically) ，就不该声明 virtual 析构函数。\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 8：析构函数不要抛出异常","url":"/2021/10/25/effecitve-cpp/effective-cpp-8/","content":"\nItem 8: Prevent exceptions from leaving destructors.\n\nC++ 本身不阻止在析构函数抛出异常，但在析构函数中抛出的异常往往会难以捕获，引发程序非正常退出或未定义行为。例如：\nclass Widget &#123;public:    ...    ~Widget() &#123; ... &#125; //假设这里可能抛出异常&#125;;void doSomething()&#123;  std::vector&lt;Widget&gt; v;  // v 这里被自动析构&#125;\n\n当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。\n不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在 C++ 中，不要让析构函数抛出异常！\n但是如果析构函数所使用的代码可能无法避免抛出异常呢？\nclass DBConnection&#123;                   //某用来建立数据库连接的类  public:    ...    static DBConnection create();     //建立一个连接    void close();                     //关闭一个连接，假设可以抛出异常&#125;;class DBConn&#123;                         //创建一个资源管理类来提供更好的用户接口  public:    ....    ~DBConn&#123; db.close(); &#125;            //终止时自动调用关闭连接的方法  private:    DBConnection db;&#125;;...&#123;                                   DBConn dbc(DBConnection::create()); //创建一个DBConn类的对象  ...                                 //使用这个对象&#125;                                     //对象dbc被释放资源          \n\n析构函数所调用的 close() 方法可能会抛出异常，那么有什么方法来解决呢？\n吞掉异常\nDBConn::~DBConn()&#123;  try&#123;     db.close();  &#125;catch(...)&#123;    //记录访问历史  &#125;&#125;\n\n主动关闭程序\nDBConn::~DBConn()&#123;  try&#123;     db.close();  &#125;catch(...)&#123;    //记录访问历史    std::abort();  &#125;&#125;\n\n把可能抛出异常的代码移出析构函数\n客户在需要关闭的时候主动调用 close() 函数\nclass DBConn&#123;  public:    ...    ~DBConn();    void close();        //当要关闭连接时，手动调用此函数  private:    ...    closed = false;      //显示连接是否被手动关闭&#125;;void DBConn::close()&#123;    //当需要关闭连接，手动调用此函数  db.close();  closed = true;&#125;DBConn::~DBcon()&#123;  if(!closed)            //析构函数还是要留有备用，但不用每次都承担风险了    try&#123;      db.close();    &#125;catch(...)&#123;      //记录访问历史      //消化异常或者主动关闭    &#125;&#125;\n\n\n\n析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。\n如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数(而非在析构函数中)执行该操作。\n\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective C++ 9：绝不在构造和析构过程中调用 virtual 函数","url":"/2021/11/01/effecitve-cpp/effective-cpp-9/","content":"\nItem 9: Never call virtual functions during construction or destruction.\n\n在构造和析构期间不要调用 virtual 函数，因为这类调用不会下降至 derived class(比起当前执行构造函数和析构函数的那层)。\nclass Transaction &#123;                               // base class for allpublic:                                           // transactions    Transaction()&#123;                                // base class ctor                   logTransaction();                         // as final action, log this                   &#125;    virtual void logTransaction() const = 0;      // make type-dependent&#125;;  class BuyTransaction: public Transaction &#123;        // derived classpublic:    virtual void logTransaction() const;          // how to log trans-&#125;;...BuyTransaction b;\n\nb 在构造时，调用到父类Transaction的构造函数，其中对 logTransaction 的调用会被解析到 Transaction 类。 那是一个纯虚函数，因此程序会非正常退出。\n在derived class 对象的 base class 构造期间，对象的类型是 base class 而不是 derived classo 不只 virtual 函数会被编译器解析至(resolve to) base class ，若使用运行期类型信息 RTTI(runtime type information, 例如 dynamic_cast  typeid) ，也会把对象视为 base class 类型。\nclass Transaction&#123;public:    Transaction()&#123;        cout&lt;&lt;typeid(this).name()&lt;&lt;endl;    &#125;&#125;;class BuyTransaction: public Transaction&#123;public:    BuyTransaction()&#123;        cout&lt;&lt;typeid(this).name()&lt;&lt;endl;    &#125;&#125;;void main()&#123;    BuyTransaction b;&#125;\n\n输出\nP11TransactionP14BuyTransaction\n\n相同道理也适用于析构函数.\n","categories":["Effective-C++"],"tags":["C++","Effective-C++"]},{"title":"Effective-STL 21：总是让比较函数在等值情况下返回 false","url":"/2023/03/10/effective-stl/effective-stl-21/","content":"\nItem 21: Always have comparison functions return false for equal values.\n\n严格弱序( strict weak ordering )先补充下严格弱序的概念: 对两个变量 x 和 y：\n\nx &gt; y 等同于 y &lt; x\nx == y 等同于 !(x &lt; y) &amp;&amp; !(x &gt; y)\n\n要想严格弱序，就需要遵循如下规则：\n\n每个变量值必须等于其本身（irreflexivity）：x &lt; x 永远不能为 true\n不对称性（asymmetry）：如果 x &lt; y，那么 y &lt; x 就不能为 true\n有序性必须可传递性：如果 x &lt; y 并且 y &lt; z，那么 x &lt; z\n值相同必须具有可传递性：如果 x == y 并且 y == z，那么 x == z\n\n\n\n为什么？1. 关联容器中的比较算法比如我们创建一个 set ， 用 less_euqal 作为比较类型，然后插入两个 10 ：\nset&lt;int, less_equal&lt;int&gt;&gt; s;s.insert(10);s.insert(10);\n\n我们将第一个 10 记为 10A, 第二个 10 记为 10B, 我们在插入 10B 的时候会检查是否与 10A 相同, 我们用的是 less_equal，下面的表达式会为假，就会重复插入，显然不合理。:\n!(10A &lt;= 10B) &amp;&amp; !(10B &lt;= 10A) //  !(true) &amp;&amp; !(true)\n\n另外在 multiset 中也不行: \nmultiset&lt;int, less_equal&lt;int&gt;&gt; s;s.insert(10); // 插入10As.insert(10); // 插入10B\n\n当我们想要一个 equal_range, 10A 和 10B 同样认为是不等，永远不会在同一个区间。\n2. sort 算法对于 std::sort，当容器里面元素个数大于 _S_threshold 的值时（16），就会使用快速排序，会将所有的元素与中间值比较是无边界保护的，实现如下：\ntemplate&lt;typename _RandomAccessIterator, typename _Tp, typename _Compare&gt;     _RandomAccessIterator     __unguarded_partition(_RandomAccessIterator __first,               _RandomAccessIterator __last,               _Tp __pivot, _Compare __comp)&#123;    while (true)    &#123;       while (__comp(*__first, __pivot)) // &lt;-------------------         ++__first;       --__last;       while (__comp(__pivot, *__last))         --__last;       if (!(__first &lt; __last))         return __first;       std::iter_swap(__first, __last);       ++__first;    &#125;&#125;\n\n如果传入的 vector 中，后面的元素完全相等， __comp()函数一直返回 true ，在进行快速排序的时候，++first 就可能越界失效，导致 coredump。\n","categories":["Effective-STL"],"tags":["C++","Effective-STL","stl"]},{"title":"Effective-STL 9：慎重选择删除元素的方法","url":"/2023/02/16/effective-stl/effective-stl-9/","content":"\nItem9. Choose carefully among easing options.\n\n一、删除特定值\n对于 vector、 string 或 deque\n 最好使用 erase-remove习惯用法: \n c.erase(remove(c.begin(), c.end(), 1963, c.end()));\n对于 list 容器\n 直接使用 remove 方法:\n c.remove(1963);\n对于标准关联容器\n 直接使用 erase 方法:\n c.erase(1963)\n\n\n二、删除满足特定判定条件的值bool badValue(int) &#123; return true; &#125; // 返回x是否为&quot;坏值&quot;\n\n\n对于 vector、 string 或 deque 使用 erase-remove-if方法: \n c.erase(remove_if(c.begin(), c.end(), badValue, c.end()));\n对于 list 容器 直接使用 remove_if 方法:\n c.remove_if(badValue);\n\n对于标准关联容器\n 把当前的i传给erase，i后缀递增\n for (AssocContainer&lt;int&gt;::iterator i = c.begin(); i != c.end();) &#123;    if (badValue(*i)) c3.erase(i++);     else ++i;                     &#125;\n\n三、循环内部删除对象之外还要做某些事void doSomething(int) &#123; ... &#125;\n\n对于 vector、 string 或 deque\n 接收 erase返回的迭代器值。\n for (SeqContainer&lt;int&gt;::iterator i = c.begin(); i != c.end();) &#123;    if(badValue(*i)) &#123;        doSomething(*i);        i = c.rease(i);    &#125; else ++i;&#125;\n对于 list 容器\n 虽然也可以采用标准关联容器方法，但建议采用跟 vector、 string 或 deque 一致。\n\n对于标准关联容器\n for (SeqContainer&lt;int&gt;::iterator i = c.begin(); i != c.end();) &#123;    if(badValue(*i)) &#123;        doSomething(*i);        c.rease(i++);    &#125; else ++i;&#125;\n\n","categories":["Effective-STL"],"tags":["C++","Effective-STL","stl"]},{"title":"Git 备忘录","url":"/2024/09/13/git/Git-%E5%A4%87%E5%BF%98%E5%BD%95/","content":"如何修改 Git提交历史中的 author 等信息修改上次提交的commit信息git commit --amend --author=&quot;newname&lt;newmail&gt;&quot;// 不想修改提交信息，则添加--no-editgit commit --amend --author=&quot;newname&lt;newmail&gt;&quot; --no-edit\n\ncherry-pick 冲突在 Git 中，若想选择性保留冲突文件的原始版本（当前分支的版本）或合并来的版本（被 cherry-pick 的提交版本），可以通过以下命令实现：\n1. 保留当前分支的原始版本# 针对特定冲突文件（例如你的 xxx.cpp）git checkout --ours src/xxx.cpp# 标记冲突已解决git add src/xxx.cpp# 继续完成 cherry-pick 流程git cherry-pick --continue\n2. 保留合并来的版本（冲突文件以被 cherry-pick 的提交内容为准）# 针对特定冲突文件git checkout --theirs src/xxx.cpp# 标记冲突已解决git add src/xxx.cpp# 继续完成 cherry-pick 流程git cherry-pick --continue\n\n关键概念说明：\n–ours：代表当前分支的版本（即你在执行 cherry-pick 时的本地原始状态）。\n\n–theirs：代表被 cherry-pick 的提交的版本（即你要合并进来的修改）。\n\n\n补充说明：如果多个文件冲突，可以批量操作：\n# 保留所有文件的当前分支版本git checkout --ours .# 或保留所有文件的合并来的版本git checkout --theirs .\n（操作后仍需 git add 并 git cherry-pick --continue）\n如果中途想彻底放弃整个 cherry-pick，仍可用：\ngit cherry-pick --abort\n","categories":["Git"],"tags":["Git"]},{"title":"Linux命令之tr","url":"/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/","content":"Linux 中 tr 命令用于转换或删除文件中的字符。\n语法$ tr [OPTION] SET1 [SET2]\n\n选项-c, --complerment：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换;-d, --delete：删除所有属于第一字符集的字符；-s, --squeeze-repeats：把连续重复的字符以单独一个字符表示；-t, --truncate-set1：先删除第一字符集较第二字符集多出的字符;\n\n参数\n字符集1(SET1)：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数 “字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；\n字符集2(SET2)：指定要转换成的目标字符集。\n\n实例\n小写字母转换为大写字母:\n ➜ echo &quot;HELLO WORLD&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;hello world\n\n删除字符：\n ➜ echo &quot;hello 123 world 456&quot; | tr -d &#x27;0-9&#x27;hello  world➜ echo &quot;hello 123 world 456&quot; | tr -cd &#x27;0-9&#x27;123456\n压缩字符\n ➜ echo &quot;hello          world&quot; | tr -s &#x27;[:space:]&#x27;hello world➜  share echo &quot;hellooooo worldddddddddddd&quot; | tr -s &#x27;od&#x27; hello world\n\n常用的字符类[:alnum:]：字母和数字[:alpha:]：字母[:cntrl:]：控制（非打印）字符[:digit:]：数字[:graph:]：图形字符[:lower:]：小写字母[:print:]：可打印字符[:punct:]：标点符号[:space:]：空白字符[:upper:]：大写字母[:xdigit:]：十六进制字符  ","categories":["Linux"],"tags":["Linux"]},{"title":"解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY","url":"/2022/04/19/linux/NO_PUBKEY/","content":"➜ sudo apt update 命中:1 https://pro-driver-packages.uniontech.com eagle InRelease获取:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease [269 kB]                                 命中:3 http://packages.microsoft.com/repos/code stable InRelease                                             命中:4 https://home-packages.chinauos.com/home plum InRelease                                                命中:5 https://home-packages.chinauos.com/home plum/beta InRelease   命中:6 https://home-packages.chinauos.com/printer eagle InRelease错误:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease  由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C命中:7 https://home-store-img.uniontech.com/appstore eagle InRelease正在读取软件包列表... 完成W: GPG 错误：http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93CE: 仓库 “http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease” 没有数字签名。N: 无法安全地用该源进行更新，所以默认禁用该源。N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。\n\n执行：\n➜ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 871920D1991BC93C","categories":["Linux"],"tags":["Linux","apt"]},{"title":"SUSE Linux 系统记录","url":"/2024/03/07/linux/SUSE-Linux-%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/","content":"最近接触到 SUSE Linux 操作系统，一些命令不一样，这里记录下:\n包管理器 zypper\n包的安装\n\nsudo zypper install 包名\n\n\n搜索包\n\nsudo zypper search 包名\n老旧版本系统的包查找我用的系统是 SUSE 12 SP5 基本没有可用的在线 Repositories, 一些包很难找到了，可以通过SUSE Linux Enterprise Software Development Kit 下载对应的 SDK ISO 安装里面的 rpm。\n参考资料\nSUSE 12 SP3 的源管理相关\n\n"},{"title":"文件MIME类型","url":"/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/","content":"什么是 MIME 类型？MIME（多用途 Internet 邮件扩展）的类型来识别文件格式。 MIME 类型构成了 Internet 上对文件类型进行分类的标准方法。\n\nMIME Type是用于描述文件的类型的一种表述方法，其将文件划分为多种类型，方便对其进行统一的管理。\nMIME Type指定了文件的类型名称、描述、图标信息，同时通过与.desktop应用程序描述文件整合，指定了文件的打开方式。\n\n\nMIME 类型名字遵循指定的格式：\n类型和子类型， 在 MIME 类型中，类型和子类型不区分大小写。\nmedia-type/subtype-identifier\n\n目前，有十种注册类型：application，audio，example，font，image，message，model，multipart，text和video。\n例如：\nmultipart/form-datatext/xmltext/csvtext/plainapplication/xmlapplication/zipapplication/pdf\n\n完整MIME 类型示例：\napplication/vnd.api+json\n\napplication作为类型，api作为子类型，vnd是厂商前缀，+json是后缀，表示可以解析为JSON。\n获取文件的 MIME 类型xdg-mime命令\n显示文件的MIME类型：\n  xdg-mime query filetype &#123;file&#125;\n  例如：\n  ➜ xdg-mime query filetype one.jpg image/jpeg\n\n显示MIME 类型的默认应用程序\n  xdg-mime query default &#123;mimetype&#125;\n  例如：\n  ➜ xdg-mime query default image/jpeg/usr/share/applications/deepin-image-viewer.desktop\n显示文件默认应用程序的语法\n  xdg-mime query default &quot;$(xdg-mime query filetype &#123;file&#125;)&quot;\n\n  例如：\n  xdg-mime query default \\    `xdg-mime query filetype &quot;$(find ~ / -iname &#x27;*.png&#x27; -print -quit)&quot;`\n\n设置MIME 类型的默认打开应用程序\n  xdg-mime default dekstop filetype\n\n  例如：\n  xdg-mime default dde-file-manager.desktop inode/directtory\n\nfile 命令\n查询文件类型：\n  file --mime-type INPUT_FILE\n\n  例如：\n  ➜ file --mime-type one.jpg one.jpg: inode/symlink\n\n自定义的 MIME 类型如需为系统上的所有用户添加一个自定义的 MIME 类型，并为该 MIME 类型注册一个默认的应用程序，您需要在 /usr/share/mime/packages/ 目录下创建一个新的 MIME 类型说明文件，在 /usr/share/applications/ 目录下创建一个 .desktop 文件。\n比如我们创建一个application/x-newtype类型：\n\n创建 &#x2F;usr&#x2F;share&#x2F;mime&#x2F;packages&#x2F;application-x-newtype.xml 文件\n &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;mime-info xmlns=&quot;http://www.freedesktop.org/standards/shared-mime-info&quot;&gt;&lt;mime-type type=&quot;application/x-newtype&quot;&gt;    &lt;comment&gt;new mime type&lt;/comment&gt;    &lt;glob pattern=&quot;*.xyz&quot;/&gt;&lt;/mime-type&gt;&lt;/mime-info&gt;\n 上述 application-x-newtype.xml 文件定义了一种新的 MIME 类型application/x-newtype，并指定拓展名是 .xyz 的文件为该 MIME 类型。\n\n创建一个名为例如 myapplication1.desktop 的新的 .desktop 文件，并将它放置在 /usr/share/applications/ 目录下：\n [Desktop Entry]Type=ApplicationMimeType=application/x-newtypeName=My Application 1Exec=myapplication1\n\n请以 root 身份更新 MIME 数据库以使您的更改生效：\n ➜ update-mime-database /usr/share/mime\n\n请以 root 身份更新应用程序数据库：\n ➜ update-desktop-database /usr/share/applications\n\n如需为个别用户添加自定义的 MIME 类型，并为该MIME 类型注册一个默认的应用程序，您需要在 ~/.local/share/mime/packages/ 目录下创建一个新的 MIME 类型说明文件，并在 ~/.local/share/applications/ 目录下创建一个 .desktop 文件。\n参考资料\n配置文件关联\n\nfile-mime-types\n\nmime-apps-spec\n\n\n","categories":["Linux"],"tags":["Linux","mime"]},{"title":"ARM64汇编入门","url":"/2023/03/18/macos/ARM64%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/","content":"ARM 指令概要介绍\nA64 指令集只能运行在 aarch64 环境中\n所有的A64汇编指令都是 32bits 宽\nA64 支持全部是大写或者全部是小写的书写方式\n\n寄存器名：\n\n\n\nName\nSize\nEncoding\nDescription\n\n\n\nWn\n32 bits\n0-30\nGenral-purpose register 0-30\n\n\nXn\n64 bits\n0-30\nGenral-purpose register 0-30\n\n\nWZR\n32 bits\n31\nZero register\n\n\nXZR\n64 bits\n31\nZero register\n\n\nWPS\n32 bits\n31\nCurrent stack pointer\n\n\nSP\n64 bits\n31\nCurrent stack pointer\n\n\n\n\nARM 指令的分类\n内存加载和存储指令\n多字节内存加载和存储\n算术和位移指令\n移位操作\n位操作\n条件操作\n跳转指令\n独占访存指令\n内存屏障指令\n异常处理指令\n系统寄存器访问指令\n\nARM 指令的一般编码格式一条典型的 ARM64 指令语法格式如下所示：\n&lt;opcode&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125; &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt;\n\n\n&lt;opcode&gt;：是指令助记符，如 ADD 表示算术加操作指令。\n&#123;&lt;cond&gt;&#125;：表示指令执行的条件。\n&#123;S&#125;：决定指令的操作是否影响 CPSR 的值。\n&lt;Rd&gt;：表示目标寄存器。\n&lt;Rn&gt;：表示包含第 1 个操作数的寄存器。\n&lt;shifter_operand&gt;：表示第 2 个操作数。\n\n","categories":["汇编"],"tags":["arm64"]},{"title":"Disk Arbitration","url":"/2023/02/16/macos/Disk-Arbitration/","content":"介绍Disk Arbitration framework 是一个基于 Core Foundation 的低级框架。会在磁盘出现和消失时通知您的应用程序，并让您的应用程序影响该过程。借助 Disk Arbitration，我们可以：\n\n检测何时出现新磁盘\n阻止挂载\n使用不同的标志或在不同的安装点上安装卷\n卸载卷\n观察卷的变化\n\n\n\n使用磁盘仲裁通知和批准回调\n通过调用创建会话对象 DASessionCreate。\n如果您想知道磁盘相关事件何时发生，请注册通知回调；如果您想积极参与仲裁过程，请注册批准回调。\n在运行循环或调度队列上安排会话对象（并在必要时启动运行循环或调度队列）。\n处理您的应用收到的任何回调。\n当应用程序不再需要接收回调时，取消调度会话对象并释放它。\n\n创建会话编写磁盘仲裁通知客户端时必须做的第一件事是创建一个会话 (DASessionRef)。要创建磁盘仲裁会话，请调用DASessionCreate，如下所示：\nDASessionRef session;session = DASessionCreate(kCFAllocatorDefault);\n\n注册通知和批准磁盘仲裁支持两种类型的回调。通知回调告诉您发生了某些事情。批准回调允许您阻止挂载、卸载或弹出操作发生。\n通知回调\nDADiskAppearedCallback—出现磁盘或出现分区时调用\nDADiskDescriptionChangedCallback—当磁盘的描述发生变化时调用（在 OS X v10.7 及更高版本中，当首次安装卷时）\nDADiskDisappearedCallback—弹出可移动磁盘时调用\nDADiskPeekCallback—在首次探测磁盘时、自动挂载开始之前以及发送任何其他通知之前调用\n\n注册函数\nDARegisterDiskAppearedCallback\nDARegisterDiskDescriptionChangedCallback\nDARegisterDiskDisappearedCallback\nDARegisterDiskPeekCallback\n\n这些注册函数中的大多数都采用匹配字典。您通常应该传递 NULL``（以匹配所有磁盘）或传递标准匹配字典，例如kDADiskDescriptionMatchMediaUnformatted. 这些匹配字典的详细匹配行为如下所示:\n\n\n\n标准字典\n内容\n描述\n\n\n\nkDADiskDescriptionMatchMediaUnformatted\nkDADiskDescriptionMediaSizeKey价值为0\n匹配未格式化的媒体（如空白 DVD）。\n\n\nkDADiskDescriptionMatchMediaWhole\nkDADiskDescriptionMediaWholeKey有价值true\n仅匹配整盘媒体（&#x2F;dev&#x2F;disk0例如 ）。\n\n\nkDADiskDescriptionMatchVolumeMountable\nkDADiskDescriptionVolumeMountableKey有价值true\n匹配可安装的卷。\n\n\nkDADiskDescriptionMatchVolumeUnrecognized\nkDADiskDescriptionVolumeMountableKey有价值false\n匹配不可挂载的磁盘。\n\n\n例如，要限制与 USB 连接媒体的匹配，您可以创建一个匹配字典，如下所示：\nCFMutableDictionaryRef matchingDict =    CFDictionaryCreateMutable(        kCFAllocatorDefault,        0,        &amp;kCFTypeDictionaryKeyCallBacks,        &amp;kCFTypeDictionaryValueCallBacks); CFDictionaryAddValue(matchingDict,    kDADiskDescriptionDeviceProtocolKey,    CFSTR(kIOPropertyPhysicalInterconnectTypeUSB));\nIOStorageProtocolCharacteristics.h User-Space Reference中描述了其他互连类型和其他相关常量。最后，只要磁盘事件与指定的匹配字典（或多个字典）和使用上下文指针的事件类型匹配，您就可以将任意数据传递给回调。通过传递不同的上下文指针，您可以使用不同的匹配字典多次注册相同的回调，并向回调提供指示哪个注册匹配的信息。如果您不需要提供此类上下文信息，只需传递NULL此参数即可。\n每个回调的详细信息在以下部分中有更详细的描述。\n注销通回调当您不再需要通知回调时，通过调用取消注册 DAUnregisterCallback。例如：\nDAUnregisterCallback(session, mycallbackfuntion, NULL);\n请务必传入注册函数时使用的原始上下文指针值。\n批准回调通过三种方式在磁盘仲裁中注册批准回调，具体取决于您希望何时收到通知。\n\n如果您希望在弹出磁盘之前获得许可，请调用 DARegisterDiskEjectApprovalCallback.\n如果您希望在安装卷之前获得许可，请调用 DARegisterDiskMountApprovalCallback.\n如果您希望在卸载卷之前获得许可，请调用 DARegisterDiskUnmountApprovalCallback。\n\nDADissenterRef allow_mount(DADiskRef disk, void *context); ... session = DASessionCreate(kCFAllocatorDefault); DARegisterDiskMountApprovalCallback(session,                NULL, /* Match all disks */                allow_mount,                NULL); /* No context */ ... DADissenterRef allow_mount(        DADiskRef disk,        void *context)&#123;        int allow = 0;         if (allow) &#123;                /* Return NULL to allow */                fprintf(stderr, &quot;allow_mount: allowing mount.\\n&quot;);                return NULL;        &#125; else &#123;                /* Return a dissenter to deny */                fprintf(stderr, &quot;allow_mount: refusing mount.\\n&quot;);                return DADissenterCreate(                        kCFAllocatorDefault, kDAReturnExclusiveAccess,                        CFSTR(&quot;It&#x27;s mine!&quot;));        &#125;&#125;\n注销批准回调当您不再需要批准回调时，您应该通过调用取消注册 DAUnregisterApprovalCallback。例如：\nDAUnregisterApprovalCallback(session, mycallbackfuntion, NULL);\n请务必传入注册函数时使用的原始上下文指针值。\n使用调度队列/* Schedule the session on a dispatch queue. */DASessionSetDispatchQueue(session, queue); /* Unschedule the session on a dispatch queue. */DASessionSetDispatchQueue(session, NULL); /* Clean up the session resources. */CFRelease(session);\n使用运行循环/* Schedule a disk arbitration session. */DASessionScheduleWithRunLoop(session, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode); /* Start the run loop.  (Don&#x27;t do this if you already have   a running Core Foundation or Cocoa run loop.) */CFRunLoopRun(); /* Clean up a session. */DASessionUnscheduleFromRunLoop(session,    CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);CFRelease(session);\n\n操作磁盘和卷获取磁盘对象在您可以操作磁盘或卷之前，您必须DADiskRef为该磁盘或卷获取一个对象。通过四种方式获取对象：\n\n作为传递给事件回调的参数（在使用磁盘仲裁通知和批准回调中描述）\n通过调用从 io_service_t用户空间引用到有效设备切片的对象 IOMediaDADiskCreateFromIOMedia\n您可以通过调用或io_service_t来获取对象的用户空间引用。\n从 BSD 设备名称（disk1s1例如）使用 DADiskCreateFromBSDName\n从挂载点调用 DADiskCreateFromVolumePath\n\n如果您有一个io_service_t对象或一个 BSD 设备名称，您的应用程序可以创建一个DADiskRef对象，如下所示：\nDASessionRef按照创建会话中的描述创建一个对象。\n\n按照Scheduling the Session with the Run Loop or Dispatch Queue中的描述安排它。确保您的调度队列或运行循环正在运行。\n创建磁盘对象。\n根据需要操纵它们。\n\n获取磁盘信息盘仲裁提供三个函数来获取有关磁盘和分区的附加信息：DADiskCopyDescription 、DADiskGetBSDName 和DADiskCopyIOMedia。通常，您可以通过调用 获得关于特定磁盘的几乎所有信息 DADiskCopyDescription。然而，对于一些相当深奥的信息，您可能必须IOMedia为磁盘获取一个对象并查询该对象。\n如果您需要磁盘或分区的 BSD 设备名称（disk1s1例如）作为 C 字符串（通常在使用 POSIX 级 API 时使用），请调用 DADiskGetBSDName.对于大多数其他信息，请调用DADiskCopyDescription，如获取描述字典中所述。如果无法通过 获得您需要的信息 DADiskCopyDescription，请调用DADiskCopyIOMedia。\n获取描述字典DADiskCopyDescription方法返回一个 CFDictionaryRef 对象，其中包含有关磁盘或分区的几十条信息。一些常用的数据包括：\n\n挂载点和卷名\nBSD 设备节点名称和主要和次要编号\n有关硬件的信息（设备 ID 、供应商 ID 、GUID 等）\n连接信息（总线名称和路径\n\n您可以在磁盘仲裁框架的标头中找到完整的属性列表 DADisk.h Reference.，以及每个键值的预期数据类型的描述。\n从 I/O Kit 获取附加信息在极少数情况下，您可能需要获取有关磁盘的其他信息，而不是磁盘仲裁提供的信息。如果这样做，您可以调用DADiskCopyIOMedia以获取一个 io_service_t对象，该对象是对象的用户空间表示 IOMedia。您可以像操作任何 I/O Registry 对象一样操作此对象。\n例如，您可以通过调用 IORegistryEntryCreateCFProperties结果对象来获取具有媒体 I/O 注册表属性的 Core Foundation 字典。\nI/O Registry 字典中的属性在 I/O Kit Framework 中定义。有关详细信息，请参阅I&#x2F;O Kit Framework Reference。\n安装和卸载卷\nDADiskMount\n\nDADiskMountWithArguments\n  unsigned char *mppath = &quot;/mnt/mydisk&quot;;path = CFURLCreateFromFileSystemRepresentation(    kCFAllocatorDefault,    mppath,    strlen(mppath),    true);DADiskMountWithArguments(disk, path, kDADiskMountOptionDefault,    mount_complete_callback, NULL,    NULL);\nDADiskUnmount\n  void unmount_done(DADiskRef disk,DADissenterRef dissenter,void *context); ...DADiskUnmount(disk, kDADiskUnmountOptionDefault,    unmount_done, NULL);...void unmount_done(DADiskRef disk,    DADissenterRef dissenter,    void *context)&#123;    if (dissenter) &#123;        /* Unmount failed. */        char buf[MAXPATHLEN];        if (CFURLGetFileSystemRepresentation(fspath, false, (UInt8 *)buf, sizeof(buf))) &#123;            fprintf(stderr, &quot;Unmount failed (Error: 0x%x Reason: %s).  Retrying.\\n&quot;,                DADissenterGetStatus(dissenter),                buf);        &#125; else &#123;            /* Something is *really* wrong. */        &#125;    &#125; else &#123;        /* Do something. */    &#125;&#125;\n\n弹出磁盘在弹出磁盘之前，您必须卸载磁盘上的所有卷。首先调用 DADiskUnmount，将整个磁盘分区作为磁盘参数传递，并kDADiskUnmountOptionWhole 在卸载选项中设置标志。然后调用 DADiskEject\nvoid unmount_done(DADiskRef disk,    DADissenterRef dissenter,    void *context);void eject_done(DADiskRef disk,    DADissenterRef dissenter,    void *context); ... /* Unmount all volumes */DADiskRef wholedisk = DADiskCopyWholeDisk(partition);DADiskUnmount(wholedisk, kDADiskUnmountOptionWhole,    unmount_done, NULL);CFRelease(wholedisk); ... /* In the unmount callback, eject the volume. */void unmount_done(DADiskRef disk,    DADissenterRef dissenter,    void *context)&#123;    if (dissenter) &#123;        ...    &#125; else &#123;        DADiskEject(disk, kDADiskEjectOptionDefault,            eject_done, NULL);    &#125;&#125; /* Eject callback. */void eject_done(DADiskRef disk,    DADissenterRef dissenter,    void *context)&#123;    if (dissenter) &#123;        ...    &#125; else &#123;        ...    &#125;&#125;\n参考资料\nDisk Arbitration Programming Guide\n\n","categories":["MacOS"],"tags":["MacOS","Disk"]},{"title":"Mac 终端设备控制","url":"/2025/02/24/macos/Mac-%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6/","content":"AirDrop\n打开  launchctl load /System/Library/LaunchAgents/com.apple.sharingd.plist\n关闭  launchctl unload /System/Library/LaunchAgents/com.apple.sharingd.plist\n\nBluetooth\n关闭  defaults write /Library/Preferences/com.apple.Bluetooth.plist ControllerPowerState 0killall bluetoothdkillall blued\n\nCD\neject  for (DRDevice *device in [DRDevice devices]) &#123;    [device ejectMedia];&#125;\n\nUSB使用 Disk Arbitration framework\nDisk Arbitration framework 是一个基于 Core Foundation 的低级框架。会在磁盘出现和消失时通知您的应用程序，并让您的应用程序影响该过程。借助 Disk Arbitration，我们可以：\n\n检测何时出现新磁盘\n阻止挂载\n使用不同的标志或在不同的安装点上安装卷\n卸载卷\n观察卷的变化\n\n"},{"title":"MacOS文件监控","url":"/2024/10/25/macos/MacOS%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7/","content":"1. 文件系统事件：文件变动的探测器文件系统事件是macOS提供的一个API，可以帮助我们监听文件或目录的变更。只要文件或目录发生变化，这个API就会发出通知。\n2. 如何在macOS上实施文件监控？在macOS上进行文件监控，你可以使用以下两种方法：\n2.1 FSEvents APIFSEvents API是一个低级的C语言API，可以让你直接与文件系统事件驱动程序进行交互。这种方法非常高效，但它也比较复杂。\n2.2 Cocoa NSFilePresenter APICocoa NSFilePresenter API是一个更高层次的API，它封装了FSEvents API，使用起来更加简单。但它可能不如FSEvents API那么高效。\n/*USB设备类型：DAVolumeKind = msdos、exfat、hfs;msdos：MS-DOSexfat：EXFAThfs：Mac OS 日志式、加密式共享文件类型：DAVolumeKind = smbfs;*/\n","categories":["macOS"],"tags":["macOS"]},{"title":"@executable path, @load path 和 @rpath","url":"/2023/08/25/macos/executable-path-load-path-%E5%92%8C-rpath/","content":"在 macOS 上，动态链接器使用特定的路径变量来解析运行时的库位置。这些路径变量包括：绝对路径、 @executable_path、@loader_path 和 @rpath。\n绝对路径对于安装在系统中共享位置的框架很有用，一般是 /Library/Frameworks/xxx、 /usr/lib/xxx, 但是查找嵌入在应用内部的动态库就很难使用，应用安装的位置都不固定，所以引出新的方式。\n@executable path@executable_path 是用于指代当前正在执行的程序或应用的路径。当你的应用程序或其动态库需要引用位于与可执行文件相同路径（或其子目录）下的其他动态库时，这会非常有用。\n\n举例说明: \nMyApp/|-- MyApp.app/    |-- Contents/        |-- MacOS/            |-- MyApp (可执行文件)            |-- libA.dylib (动态库A)        |-- Frameworks/            |-- libB.dylib (动态库B)\n\n假设 MyApp 依赖于 libA.dylib，而 libA.dylib 依赖于 libB.dylib。如果你希望 libA.dylib 在运行时找到 libB.dylib，可以设置 libB.dylib 的安装名称为 @executable_path/../Frameworks/libB.dylib。当 MyApp 启动并加载 libA.dylib 时，@executable_path 将解析为 MyApp.app/Contents/MacOS/，因此 libA.dylib 会正确地找到 libB.dylib 在 MyApp.app/Contents/Frameworks/ 目录下。\n@load path加载的动态库的路径。在很多情况下，这个路径是基于正在加载该库的模块，因此它可能会随着加载该库的不同模块而变化。\n举例说明:\nMyApp/|-- MyApp.app/    |-- Contents/        |-- MacOS/            |-- MyApp (主应用程序)            |-- libMain.dylib (主应用的动态库)        |-- Plugins/            |-- PluginA.bundle/                |-- PluginA (插件)                |-- libPluginA.dylib (插件的动态库)\n在这个例子中，MyApp 依赖 libMain.dylib，而 PluginA 依赖 libPluginA.dylib。\n\n使用 @executable_path：\n如果 libMain.dylib 需要引用与其位于同一目录下的另一个库，如 libHelper.dylib，它可以使用 @executable_path/libHelper.dylib 作为路径。但是，这对 PluginA 中的库不起作用，因为 @executable_path 总是指向 MyApp.app/Contents/MacOS/，不考虑加载它的实际模块。\n\n使用 @loader_path：\n如果 libPluginA.dylib 需要引用与其位于同一目录下的另一个库，如 libHelper.dylib，它可以使用 @loader_path/libHelper.dylib 作为路径。这样，不管 libPluginA.dylib 被哪个模块加载，它都会正确地引用到相对于加载它的模块的库。\n\n\n如果是一个应用程序，那么 @load path 与 @executable_path 相同。\n@rpath@rpath (Runtime Search Path) 提供了一种动态方式来指定和查找动态库。它的主要优势是提供了更多的灵活性，尤其是在面对多种可能的库位置或多个版本的库时。\n举例说明:\nMyApp/|-- MyApp.app/    |-- Contents/        |-- MacOS/            |-- MyApp (可执行文件)        |-- Frameworks/            |-- libA.dylib (动态库A版本1)        |-- Plugins/            |-- PluginA/                |-- libA.dylib (动态库A版本2)\n\n假设 MyApp 可能需要加载两个版本中的任何一个 libA.dylib，具体取决于特定的运行时情境。使用 @rpath 可以轻松管理这种情况。\n\n设置 @rpath:\n  在构建 MyApp 时，你可以设置多个运行时搜索路径（rpaths）:\n\n@executable_path/../Frameworks\n@executable_path/../Plugins/PluginA\n\n\n使用 @rpath 在动态库中:\n  设 libA.dylib 的安装名称为 @rpath/libA.dylib。\n\n运行时解析:\n  当 MyApp 需要加载 libA.dylib 时，它会沿着 rpath 列表搜索。首先在 Frameworks 文件夹中查找，然后在 PluginA 文件夹中查找。\n\n\n这种方法的好处是，你可以轻松地将相同的库放在多个位置，而不需要为每个位置硬编码路径。此外，应用程序的用户或开发人员可以通过修改 rpath 来改变库的搜索顺序或位置。\ninstall_name_tool要查看或修改一个可执行文件或动态库的 rpath，你可以使用 otool 和 install_name_tool 这两个命令行工具。\n➜ otool -l WeChat...Load command 104          cmd LC_LOAD_DYLIB      cmdsize 64         name /usr/lib/swift/libswiftsimd.dylib (offset 24)   time stamp 2 Thu Jan  1 08:00:02 1970      current version 9.0.0compatibility version 1.0.0Load command 105          cmd LC_LOAD_DYLIB      cmdsize 64         name /usr/lib/swift/libswiftFoundation.dylib (offset 24)   time stamp 2 Thu Jan  1 08:00:02 1970      current version 1.0.0compatibility version 1.0.0Load command 106          cmd LC_RPATH      cmdsize 32         path /usr/lib/swift (offset 12)Load command 107          cmd LC_RPATH      cmdsize 48         path @executable_path/../Frameworks (offset 12)...\n\n添加 rpath:\ninstall_name_tool -add_rpath @executable_path/. a.out\n\n修改 rpath:\ninstall_name_tool -change libFoo @rpath/libFoo a.out","categories":["MacOS"],"tags":["DYLD"]},{"title":"macOS Ventura App 管理","url":"/2024/01/04/macos/macOS-Ventura-App-%E7%AE%A1%E7%90%86/","content":"从 macOS Monterey 开始，如果应用程序被未由相同开发团队签名且未由 NSUpdateSecurityPolicy 允许的东西修改，macOS 将阻止修改并通知用户应用程序希望管理其他应用程序。点击通知会将用户发送到系统设置，他们可以在那里允许应用程序更新和修改其他应用程序。\n\n\n\n\n从 macOS Ventura 开始，Gatekeeper 将检查所有经过公证的应用程序的完整性，而不仅仅是隔离的应用程序。\n从 macOS Ventura 开始，如果您的认证应用程序的签名不再有效，Gatekeeper 将在首次启动时阻止其运行。\nmacOS Monterey 及更早版本仅在修改后的已认证应用程序仍处于隔离状态时才会阻止首次启动。\n\n\n从 macOS Ventura 开始，Gatekeeper 还将阻止应用以某些方式修改您的应用程序。\n完全磁盘访问自动包含应用程序管理权限。即使在系统设置中禁用了应用程序管理权限。\n应用程序如何更新\n由同一开发者帐户或团队有效签名的应用程序将继续能够互相更新。这将自动进行。\n要允许另一个开发团队更新您的应用程序或限制仅由您的更新程序更新，需要在 info-plist，添加 NSUpdateSecurityPolicy 。在 NSUpdateSecurityPolicy 内部，添加”AllowProcesses“，一个将团队标识符映射到签名标识符数组的字典。\n\n\n\n参考资料\nWhat’s new in privacy\nHow macOS Ventura App Management works and doesn’t work\n\n","categories":["macOS"],"tags":["macOS"]},{"title":"macOS 完全磁盘访问权限","url":"/2024/01/05/macos/macOS-%E5%AE%8C%E5%85%A8%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/","content":"","categories":["macOS"],"tags":["macOS"]},{"title":"macOS 设置面板快捷链接","url":"/2023/12/28/macos/macOS-%E8%AE%BE%E7%BD%AE%E9%9D%A2%E6%9D%BF%E5%BF%AB%E6%8D%B7%E9%93%BE%E6%8E%A5/","content":"Accessibility Preference PaneMain    x-apple.systempreferences:com.apple.preference.universalaccessDisplay x-apple.systempreferences:com.apple.preference.universalaccess?Seeing_DisplayZoom    x-apple.systempreferences:com.apple.preference.universalaccess?Seeing_ZoomVoiceOver   x-apple.systempreferences:com.apple.preference.universalaccess?Seeing_VoiceOverDescriptions    x-apple.systempreferences:com.apple.preference.universalaccess?Media_DescriptionsCaptions    x-apple.systempreferences:com.apple.preference.universalaccess?CaptioningAudio   x-apple.systempreferences:com.apple.preference.universalaccess?HearingKeyboard    x-apple.systempreferences:com.apple.preference.universalaccess?KeyboardMouse &amp; Trackpad    x-apple.systempreferences:com.apple.preference.universalaccess?MouseSwitch Control  x-apple.systempreferences:com.apple.preference.universalaccess?SwitchDictation   x-apple.systempreferences:com.apple.preference.universalaccess?SpeakableItems\n\n\nSecurity &amp; Privacy Preference PaneMain    x-apple.systempreferences:com.apple.preference.securityGeneral x-apple.systempreferences:com.apple.preference.security?GeneralFileVault   x-apple.systempreferences:com.apple.preference.security?FDEFirewall    x-apple.systempreferences:com.apple.preference.security?FirewallAdvanced    x-apple.systempreferences:com.apple.preference.security?AdvancedPrivacy x-apple.systempreferences:com.apple.preference.security?PrivacyPrivacy-Camera x-apple.systempreferences:com.apple.preference.security?Privacy_CameraPrivacy-Microphone  x-apple.systempreferences:com.apple.preference.security?Privacy_MicrophonePrivacy-Automation  x-apple.systempreferences:com.apple.preference.security?Privacy_AutomationPrivacy-AllFiles    x-apple.systempreferences:com.apple.preference.security?Privacy_AllFilesPrivacy-Accessibility   x-apple.systempreferences:com.apple.preference.security?Privacy_AccessibilityPrivacy-Assistive   x-apple.systempreferences:com.apple.preference.security?Privacy_AssistivePrivacy-Location Services   x-apple.systempreferences:com.apple.preference.security?Privacy_LocationServicesPrivacy-SystemServices  x-apple.systempreferences:com.apple.preference.security?Privacy_SystemServicesPrivacy-Advertising x-apple.systempreferences:com.apple.preference.security?Privacy_AdvertisingPrivacy-Contacts    x-apple.systempreferences:com.apple.preference.security?Privacy_ContactsPrivacy-Diagnostics &amp; Usage x-apple.systempreferences:com.apple.preference.security?Privacy_DiagnosticsPrivacy-Calendars   x-apple.systempreferences:com.apple.preference.security?Privacy_CalendarsPrivacy-Reminders   x-apple.systempreferences:com.apple.preference.security?Privacy_RemindersPrivacy-Facebook    x-apple.systempreferences:com.apple.preference.security?Privacy_FacebookPrivacy-LinkedIn    x-apple.systempreferences:com.apple.preference.security?Privacy_LinkedInPrivacy-Twitter x-apple.systempreferences:com.apple.preference.security?Privacy_TwitterPrivacy-Weibo   x-apple.systempreferences:com.apple.preference.security?Privacy_WeiboPrivacy-Tencent Weibo   x-apple.systempreferences:com.apple.preference.security?Privacy_TencentWeibo\n\nmacOS Catalina 10.15Privacy-ScreenCapture   x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapturePrivacy-DevTools    x-apple.systempreferences:com.apple.preference.security?Privacy_DevToolsPrivacy-InputMonitoring x-apple.systempreferences:com.apple.preference.security?Privacy_ListenEventPrivacy-DesktopFolder   x-apple.systempreferences:com.apple.preference.security?Privacy_DesktopFolderPrivacy-DocumentsFolder x-apple.systempreferences:com.apple.preference.security?Privacy_DocumentsFolderPrivacy-DownloadsFolder x-apple.systempreferences:com.apple.preference.security?Privacy_DownloadsFolderPrivacy-NetworkVolume   x-apple.systempreferences:com.apple.preference.security?Privacy_NetworkVolumePrivacy-RemovableVolume x-apple.systempreferences:com.apple.preference.security?Privacy_RemovableVolumePrivacy-SpeechRecognition   x-apple.systempreferences:com.apple.preference.security?Privacy_SpeechRecognition\nDictation &amp; Speech Preference PaneDictation   x-apple.systempreferences:com.apple.preference.speech?DictationText to Speech  x-apple.systempreferences:com.apple.preference.speech?TTSSharing Preference PaneMain    x-apple.systempreferences:com.apple.preferences.sharingScreen Sharing  x-apple.systempreferences:com.apple.preferences.sharing?Services_ScreenSharingFile Sharing    x-apple.systempreferences:com.apple.preferences.sharing?Services_PersonalFileSharingPrinter Sharing x-apple.systempreferences:com.apple.preferences.sharing?Services_PrinterSharingRemote Login    x-apple.systempreferences:com.apple.preferences.sharing?Services_RemoteLoginRemote Management   x-apple.systempreferences:com.apple.preferences.sharing?Services_ARDServiceRemote Apple Events x-apple.systempreferences:com.apple.preferences.sharing?Services_RemoteAppleEventInternet Sharing    x-apple.systempreferences:com.apple.preferences.sharing?InternetBluetooth Sharing   x-apple.systempreferences:com.apple.preferences.sharing?Services_BluetoothSharing","categories":["macOS"],"tags":["macOS"]},{"title":"Mach-O 相关记录","url":"/2023/03/10/macos/mach-o/","content":"介绍结构","categories":["MacOS"],"tags":["Mach-O"]},{"title":"在MacOS平台上符号化崩溃报告","url":"/2022/07/26/macos/%E5%9C%A8MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A/","content":".dSYM.dSYM (debugging SYMbols) 又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的 DWARF（Debugging With Attributed Record Formats），其在.xcarchive目录中的层次结构为：\n.xcarchive--dSYMs  |--Your.app.dSYM    |--Contents      |--Resources        |--DWARF\n\n如果在XCode中设置了带有 dSYM 文件的 DWARF 选项，则编译器会生成 dSYM 文件，并将其存储在您的构建中。\n\n确定符号表和崩溃日志的一致性崩溃日志中获取UUID崩溃日志比较靠下的位置有个 Binary Images 模块，其第一行内容如下：\nBinary Images:0x109724000 - 0x109cf7fff Your &lt;19a667b1-8910-3890-a0b0-03befee8876e&gt; /Library/Application Support/YourApp/*/YourApp.app/Contents/MacOS/YourApp\n\n代码段的起终地址: 0x109724000 - 0x109cf7fff\n应用的UUID：19a667b1-8910-3890-a0b0-03befee8876e（不区分大小写）\n\n从符号表中获取UUID➜ dwarfdump --uuid Your.app.dSYM\n或者：\n➜ dwarfdump --uuid Your.app.dSYM/Contents/Resources/DWARF/Your\n\n崩溃日志中和符号表中的UUID一致，才能正确解析\n计算崩溃符号表地址符号表堆栈地址计算方式Thread 0::  Dispatch queue: com.apple.main-thread0   libsystem_kernel.dylib        \t    0x7ff8159e775e write + 101   libapr-1.0.dylib              \t    0x10a6c1cee apr_file_write + 2862   liblog4cxx.10.0.0.dylib       \t    0x10a369531 log4cxx::helpers::FileOutputStream::write(log4cxx::helpers::ByteBuffer&amp;, log4cxx::helpers::Pool&amp;) + 813   Your      \t                        0x10a3ae877❶  0x10a340000❷ + 452727❸\n\n\n❶ 运行时堆栈地址\n❷ 运行时起始地址\n❸ 偏移量\n\n运行时堆栈地址 = 运行时起始地址 + 偏移量\n\n崩溃堆栈中的起始地址和崩溃地址均为运行时地址，根据虚拟内存偏移量不变原理，只要提供了符号表TEXT段的起始地址，再加上偏移量就能得到符号表中的堆栈地址，即：\n符号表堆栈地址 = 符号表起始地址 + 偏移量\n\n符号表中TEXT段的起始地址可以通过以下命令获得：使用 otool 查找 LC_SEGMENT_64 段和 vmaddr 条目\n➜ otool -l Your.app.dSYM/Contents/Resources/DWARF/Your\n\nLoad command 4      cmd LC_SEGMENT_64  cmdsize 232  segname __TEXT   vmaddr 0x0000000100000000·   vmsize 0x0000000000004000  fileoff 0 filesize 0  maxprot 0x00000005 initprot 0x00000005   nsects 2    flags 0x0\n其中的vmaddr 0x0000000100000000字段即为TEXT段的起始地址。\n使用 LLDB 进行符号化crashlog➜ xcrun lldb(lldb) command script import lldb.macosx.crashlog(lldb) crashlog &lt;path/to/crashlog.crash&gt;\nTarget(lldb) target create --no-dependents --arch &lt;architecture&gt; &lt;path/to/dSYMs/App.app.dSYM/Contents/Resources/DWARF/App&gt;(lldb) image lookup --address &lt;symboladdress&gt;\n\n使用 ATOS 符号化符号表崩溃地址的解析方式➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; -l &lt;load address&gt; &lt;stack address 1&gt; &lt;stack address 2&gt; ...\n\n无需符号表崩溃地址的解析方式➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; &lt;symboladdress&gt;\n\n使用 Dwarfdump 符号化➜ dwarfdump --arch x86_64 Your.app.dSYM --lookup symboladdress\n","categories":["MacOS"],"tags":["MacOS","Crash"]},{"title":"存储和加载指令","url":"/2023/03/18/macos/%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4/","content":"存储和加载指令ldr 指令寻址之1： 地址偏移模式 (unsigned offset)LDR Xd, [Xn, $offset]\n首先在 Xn 寄存器的内容上加上一个 offset 偏移量后作为内存地址，加载此地址的内容到 Xd 寄存器。\nldr 指令寻址之2： 变基模式\n前变基模式（pre-index 模式）： 先更新偏移地址然后再访问内存。\n后变基模式（post-index 模式）：先访问内存地址然后再更新偏移地址。\n\nLDR X0, [X1, #8]! // 前变基模式。先更新X1 的值为 X1+8，然后义新的X1值为地址，加载内存的值到X0LDR X0, [X1], #8  // 后变基模式。以x1的值为地址，加载该内存地址的值到X0，然后在更新X1寄存器为X1+8\n\nldr 指令寻址之3： 标签（literal）PC + label offset\nldr 伪指令LDR x7, =MY_LABEL\n\nmove 指令\n16位立即数\n16立即数左移16，32，48位\n\n多字节加载和存储指令 ldp 和stp","categories":["汇编"],"tags":["arm64"]},{"title":"mongodb 入门-Aggregate","url":"/2023/08/31/mongodb/mongodb-%E5%85%A5%E9%97%A8-Aggregate/","content":"聚合操作","categories":["mongodb"],"tags":["mongodb"]},{"title":"mongodb 入门-CRUD","url":"/2023/08/27/mongodb/mongodb-%E5%85%A5%E9%97%A8-CRUD/","content":"文档主键文档主键 _id文档主键 _id 是每篇文档必备的字段,具有以下特性:\n\n文档主键的唯一性\n支持所有数据类型(数组除外)\n复合主键\n\n对象主键 ObjectId当我们不提供主键，MongoDB 自动为我们生成的默认对象主键 ObjectId\n\n默认的文档主键\n可以快速生成的 12 字节 id\n包含创建时间\n\nObjectId 默认值\ntest&gt; ObjectId()ObjectId(&quot;64eeed51b64b9d7e95e6b8ea&quot;)\n手动设置 ObjectId 的值\ntest&gt; ObjectId(&quot;123456789011123456789011&quot;)ObjectId(&quot;123456789011123456789011&quot;)\n\n提取 ObjectId 的创建时间\ntest&gt; ObjectId(&quot;123456789011123456789011&quot;).getTimestamp()ISODate(&quot;1979-09-05T22:51:36.000Z&quot;)\n\n复合主键使用文档作为文档主键\n举个例子:\ndb.accounts.insert(&#123;    _id: &#123;accountNo: &quot;001&quot;, type: &quot;savings&quot;&#125;,    name: &quot;irene&quot;,    balance: 100&#125;)\n复合主键仍然要满足文档主键的唯一性，需要字段值和顺序完全一致才算重复。\n下面是不同的 _id:\n_id: &#123;accountNo: &quot;001&quot;, type: &quot;savings&quot;&#125;\n_id: &#123; type: &quot;savings&quot;, accountNo: &quot;001&quot;&#125;\n\n创建文档创建单个文档db.&lt;collection&gt;.insertOne(    &lt;document&gt;,    &#123;        writeConcern: &lt;document&gt;    &#125;)\n\n&lt;collection&gt;： 文档集合名\n&lt;document&gt;： 准备写入数据库的文档\nJson 文档格式  &#123;    _id: &quot;account1&quot;,    name: &quot;alice&quot;,    balance: 100&#125;\n\n\nwriteConcern： 文档定义了本次文档创建操作的安全写级别简单来说，安全写级别用来判断一次数据库写入操作是否成功。安全写级别越高，丢失数据的风险就越低，然而写入操作的延迟也可能更高。如果不提供writeConcern 文档，MongoDB 使用默认的安全写级别\n\n举个例子:\ndb.accounts.insertOne(    &#123;        _id: &quot;account1&quot;,        name: &quot;alice&quot;,        balance: 100    &#125;)\n\n\ninsertOne、insetMany、insert 会自动创建相应集合\n\n_id 字段不能重复，省略创建文档中的 _id 字段，会自动生成 _id。\n\n\n创建多个文档db.&lt;collection&gt;.insertMany(    [&lt;document1&gt;, &lt;document2&gt;, ...],    &#123;        writeConcern: &lt;document&gt;,        ordered: &lt;boolean&gt;    &#125;)\n\n\nordered: MongoDB 是否按照顺序来写入这些文档。默认为 true。\n\n举个例子:\ndb.accounts.insertMany(    [        &#123;name: &quot;charlie&quot;, balance: 500&#125;,        &#123;name: &quot;david&quot;, balance: 200&#125;    ])\n\n错误处理在顺序写入时，一旦遇到错误，操作便会退出，剩余的文档无论正确与否，都不会被写入。 \n在乱序写入时，即使某些文档造成了错误，剩余的正确文档仍然会被写入\n创建单个或多个文档db.&lt;collection&gt;.insert(    &lt;document or array of documents&gt;,    &#123;        writeConcern: &lt;document&gt;,        ordered: &lt;boolean&gt;    &#125;)\ninsert 命令既可以提供单个 document 也可以提供 document 数组, 返回结果不同， 正确返回 WriteReult 对象\n举个例子:\ndb.accounts.insert(    &#123;        name: &quot;george&quot;,        balance: 1000    &#125;)\n\n返回结果:\nWriteResult(&#123; &quot;nInserted&quot;: 1 &#125;)// nInserted: 插入数量\n\n三个命令的区别\n返回结果不同\ninsertOne 和 insertMany 命令不支持 db.collection.explain() 命令，insert 命令支持。\n\nsavedb.&lt;collection&gt;.save(    &lt;document&gt;,    &#123;        writeConcern: &lt;document&gt;    &#125;)\n\n当 db.collection.save() 命令处理一个新文档的时候，会调用 db.collection.insert() 命令\n读取文档db.&lt;collection&gt;.find(&lt;query&gt;, &lt;projection&gt;)\n\n&lt;query&gt;: 查询文档\n&lt;projection&gt;: 定义了对读取结果进行的投射\n\n读取全部文档既不筛选，也不使用投射\ndb.accounts.find()\n\n格式友好:\ndb.accounts.find().pretty()\n\n筛选文档匹配查询db.accounts.find(&#123;name: &quot;alice&quot;, balance: 100&#125;)\n嵌入文档的查询:\ndb.accounts.find(&#123;&quot;_id.type&quot;: &quot;savings&quot;&#125;)\n\n比较操作符常用的比较操作符包括:\n\n$eq 匹配字段值相等的文档\n$ne 匹配字段值不等的文档\n也会筛选出不包含查询字段的文档\n\n\n$gt 匹配字段值大于查询值的文档\n$gte 匹配字段值大于或等于查询值的文档\n$le 匹配字段值小于查询值的文档\n$lte 匹配字段值小于或等于查询值的文档\n\n操作命令格式:\n&#123; &lt;field&gt;: &#123;$&lt;operator&gt;: &lt;value&gt; &#125;&#125;\n\n举个例子:\n读取 alice 的文档：\ndb.accounts.find(&#123; name: &#123; $eq: &quot;alice&quot; &#125;&#125;)\n读取余额大于 100 的文档：\ndb.accounts.find(&#123; balance: &#123; $gt: 100 &#125;&#125;)\n\n\n$in 匹配字段值与任一查询值相等的文档\n$nin 匹配字段值与任何查询值都不相等的文档\n也会筛选出不包含查询字段的文档\n\n\n\n操作命令格式:\n&#123; &lt;field&gt;: &#123; $in: [&lt;value1&gt;, &lt;value2&gt;, ...] &#125;&#125;\n\n举个例子:\n读取 alice 和 charlie 的银行账户文档:\ndb.accounts.find(&#123; name: &#123; $in: [&quot;alice&quot;, &quot;charlie&quot;] &#125;&#125;)\n逻辑操作符\n$not 匹配筛选条件不成立的文档\n操作命令格式:  &#123; &lt;field&gt;: &#123; $not: &#123;&lt;operator-expression&gt; &#125; &#125;&#125;\n也会筛选出不包含查询字段的文档\n\n\n$and 匹配筛选条件全部成立的文档\n操作命令格式: &#123; $and: [&#123;&lt;operator-expression1&gt;&#125;, &#123;&lt;operator-expression2&gt;&#125;, ...]&#125;\n\n\n$or 匹配筛选条件至少一个成立的文档\n操作命令格式:  &#123; $or: [&#123;&lt;operator-expression1&gt;&#125;, &#123;&lt;operator-expression2&gt;&#125;, ...]&#125;\n当所有的筛选条件都是 $eq 操作符时，$or 和 $in 效果一样\n\n\n$nor 匹配多个筛选条件全部不成立的文档\n操作命令格式:  &#123; $nor: [&#123;&lt;operator-expression1&gt;&#125;, &#123;&lt;operator-expression2&gt;&#125;, ...]&#125;\n也会筛选出不包含查询字段的文档\n\n\n\n举个例子：\n读取余额不小于 500 的银行账户文档：\ndb.accounts.find(    &#123;balance: &#123;$not: &#123;$lt: 500 &#125;&#125;&#125;)\n\n读取余额大于 100 且用户姓名排在 fred 之后的银行账户文档：\ndb.accounts.find(    &#123; and: &#123;        &#123;balance: &#123;$gt: 100&#125;&#125;,        &#123;name: &#123;$lt: &quot;fred&quot; &#125;&#125;    &#125;&#125;)\n\n当筛选条件应用在不同字段上时，可以省略 $and 操作符, 上面等价于:\ndb.accounts.find(    &#123;balance: &#123;$gt: 100&#125;&#125;,    &#123;name: &#123;$lt: &quot;fred&quot; &#125;&#125;)\n\n当筛选条件应用在同一字段上时，也可以省略 $and 操作符。例如：\n查询余额大于 100 并且小于 500 的银行账户:\ndb.accounts.find(    &#123;balance: &#123;$gt: 100, $lt: 500 &#125;&#125;)\n\n字段操作符\n$exists \n查询包含字段值的文档\n操作命令格式:  &#123; field: &#123; $exists: &lt;boolean&gt; &#125;&#125;\n\n\n\n举个例子:读取文档主键 _id.type 存在并且不等于 checking\ndb.accounts.find(    &#123;&quot;_id.type&quot;: &#123; $ne: &quot;checking&quot;, $exists: true &#125;&#125;)\n\n\n$type \n查询包含字段值类型的文档\n操作命令格式:  &#123; field: &#123; $type: &lt;BSON type&gt; &#125;&#125;&#123; field: &#123; $type: [&lt;BSON type1&gt;, &lt;BSON type2&gt;, ... ]&#125;&#125;\n\n\n\n举个例子:\n读取文档主键是字符串的银行账户文档\ndb.accounts.find(    &#123;_id: &#123; $type: &quot;string&quot; &#125;&#125;)\n\n读取文档主键是对象主键或者是复合主键的银行账户文档\ndb.accounts.find(    &#123;_id: &#123; $type: [&quot;ObjectId&quot;, &quot;object&quot;] &#125;&#125;)\n\n也可以使用 BSON 类型序号作为 $type 操作符的参数\ndb.accounts.find(    &#123;_id: &#123; $type: 2 &#125;&#125;)\n数组操作符\n$all \n筛选数组中包含所有的查询值的文档\n操作命令格式:  &#123; field: &#123; $all: [&lt;value1&gt;, &lt;value2&gt;, ... ]&#125;&#125;\n\n\n$elemMatch \n筛选数组中任一一个元素满足查询条件\n操作命令格式:  &#123; field: &#123; $elemMatch: &#123;&lt;query1&gt;, &lt;query2&gt;, ... &#125;&#125;&#125;\n\n\n\n举个例子\ndb.accounts.find(    &#123;contact: &#123; $elemMatch: &#123; $gt: 100, %lt: 200 &#125;&#125;&#125;)\n$all 可以 与 $elemMatch 结合使用:读取包含一个在 1000 至 2000 之间和一个在 2000 至 3000 之间的联系电话的银行账户文档:\ndb.accounts.find(    &#123;contact: &#123; $all: [        &#123;$elemMatch:&#123;$gt: 1000, $lt: 2000&#125;&#125;,        &#123;$elemMatch:&#123;$gt: 2000, $lt: 3000&#125;&#125;,    ]&#125;&#125;)\n\n运算操作符$regex正则表达式，操作命令格式:\n&#123; &lt;field&gt;: &#123; : /pattern/, : &#x27;&lt;options&gt;&#x27;&#125;&#125;&#123; &lt;field&gt;: &#123; : /pattern/&lt;options&gt; &#125;&#125;\n\n兼容 PCRE v8.41 正则表达式库\n在和 $in 操作符一起使用时，只能使用 /pattern/&lt;options&gt; 方式\n举个例子:\n读取用户姓名以 c 或者 j 开头的银行账户文档:\ndb.accounts.find(&#123;name: &#123;$in: [ /^c/, /^j/ ]&#125;&#125;)\n\n读取用户姓名包含 ALI (不区分大小写)的银行账户文档:\ndb.accounts.find(&#123;name: &#123;$regex: /ALI/, $options: &quot;i&quot;&#125;&#125;)\n文档游标db.collection.find() 返回一个文档集合游标\n在不迭代游标的情况下，只列出前 20 个文档\ntest&gt; var myCursor = db.accounts.find(); myCursor\n可以使用游标下标直接访问文档集合中的某一个文档\ntest&gt; var myCursor = db.accounts.find(); myCursor[0]\n\n遍历完游标中所有的文档之后，或者在 10 分钟之后，游标会自动关闭， 可以使用 noCursorTimeout() 函数来保持游标一直有效\ntest&gt; var myCursor = db.accounts.find().noCursorTimeout()\n主动关闭游标\ntest&gt; myCursor.close()\n游标函数\ncursor.hasNext()\ncursor.next()\ncursor.forEach()\ncursor.limit()\nlimit(0) 相当于没有 limit\n\n\ncursor.skip()\ncursor.count()\n默认情况下 applySKipLimit 为 false, 即 count 不会考虑 skip 和 limit 的效果\n不提供筛选条件时， count 会从集合的元数据 Metadata 中取得结果，当数据库分布式结构较为复杂时，元数据中的文档数量可能不正确，这时更建议使用聚合管道来计算文档数量\n\n\ncursor.sort()\ndocument 定义排序要求，1 表示正向排序， -1 表示逆向排序\n&#123;field: ordering&#125;\n\n\n\n不管命令顺序，执行的顺序永远是 sort &gt; skip &gt; limit\n文档投影db.&lt;collection&gt;.find(&lt;query&gt;, &lt;projection&gt;)\n不使用投影时， find 返回符合条件的完整文档，而使用投影可以有选择性的返回文档中的部分字段\nprojection 格式:\n&#123; filed: inclusion &#125;\n1 表示返回字段，0 表示不返回字段， 没有设置主键默认会返回\n举个例子:\n只返回银行账户的用户姓名\ndb.accounts.find(&#123;&#125;, &#123;name: 1&#125;)\n\n只返回银行账户的用户姓名(不包含主键)\ndb.accounts.find(&#123;&#125;, &#123;name: 1, _id: 0&#125;)\n\n除了文档主键外，不可以在投影文档上混合使用包含和不包含这两种投影操作\n🙅\ndb.accounts.find(&#123;&#125;, &#123;name: 1， balance: 0&#125;)\n\n数组字段上使用投影$slice$slice 操作符可以返回数组字段中的部分元素\n&#123;$slice : n| -n | [i, j]&#125;\n\nn: 数组前 n 个元素\n-n: 数组后 n 个元素\n[i, j]: 跳过 i 个元素,返回接下来 j 个元素\n\n只返回 contact 数组中的第一个元素\ndb.accounts.find(&#123;&#125;, &#123;_id : 0, name: 1, contact: &#123;$slice: 1&#125;&#125;)\n\n$eleeMatch &amp; $$eleeMatch 和 $操作符返回数组中满足筛选条件的第一个元素\ndb.accounts.find(&#123;&#125;, &#123;_id : 0, name: 1, contact: &#123;$elemMatch: &#123;$gt: &quot;Alabama&quot;&#125;&#125;&#125;)\n\n与下等同: \ndb.accounts.find(&#123;contact: &#123; $gt: &quot;Alabama&quot;&#125;&#125;, &#123;_id : 0, name: 1, contact: &quot;contact.$: 1&quot;&#125;)\n\n更新文档db.collection.update(&lt;query&gt;, &lt;update&gt;, &lt;options&gt;)\n\n&lt;query&gt; 筛选条件\n&lt;update&gt; 更新文档\n&lt;options&gt; 设置参数\n\n更新整篇文档如果 &lt;update&gt; 文档不包含任何更新操作符，db.collection.update() 将会使用 &lt;update&gt;文档直接替换集合中符合 &lt;query&gt; 文档筛选条件的文档\ndb.account.update(&#123;name:&quot;alice&quot; &#125;, &#123;name : &quot;alice&quot;, &quot;balance&quot;:123&#125;)\n\n注意问题: \n\n文档主键 _id 是不可以更改的\n只有第一篇符合 &lt;query&gt; 文档符合筛选条件的文档会被更新\n\n更新特定字段更新文档特定字段，需要使用到文档更新操作符，如下:\n\n$set 更新或新增字段\n$unset 删除字段\n$rename 重命名\n$inc 加减字段值\n$mul 相乘字段值\n$min 比较减小字段值\n$max 比较增大字段值\n\n$set&#123; $set: &#123; &lt;filed1&gt;: &lt;value1&gt;, ...&#125;&#125;\n\n举个例子: \ndb.accounts.update(    &#123;name: &quot;jack&quot;&#125;,    &#123;        $set:         &#123;            balance: 3000,            info: &#123;                dateOpened: new Date(&quot;2016-05-18T16:00:00Z&quot;),                branch: &quot;branch1&quot;             &#125;,        &#125;    &#125;)\n\n更新或新增内嵌文档的字段db.accounts.update(    &#123;name: &quot;jack&quot;&#125;,    &#123;        $set:         &#123;            &quot;info.dateOpened&quot;: new Date(&quot;2017-01-01T16:00:00Z&quot;)        &#125;    &#125;)\n\n更新或新增数组字段在 $set 中使用数组名加下标，如果向现有数组字段范围以外的位置添加新值，数组字段的长度会被扩大，未被赋值的数组成员将被设置为 null\n举个例子 jack的  contact 数组中默认有 3 个元素: \n\n更新  jack的 contact 数组中第一个元素\n  db.accounts.update(    &#123;name: &quot;jack&quot;&#125;,    &#123;        $set:         &#123;            &quot;contact.0&quot;: &quot;666666&quot;        &#125;    &#125;)\n更新 jack的 contact 数组中第四元素\n  在 $set 中使用数组名加下标 3， 默认只有 3 个，这个操作会在数组后边新增一个元素.\n  db.accounts.update(    &#123;name: &quot;jack&quot;&#125;,    &#123;        $set:         &#123;            &quot;contact.3&quot;: &quot;77777&quot;        &#125;    &#125;)\n\n更新  jack的 contact 数组中第六个元素\n  在 $set 中使用数组名加下标 5， 现在只有 4 个，这个操作会在数组后边新增两个元素，第五个元素为 null 值，第六个为新增值\n  db.accounts.update(    &#123;name: &quot;jack&quot;&#125;,    &#123;        $set:         &#123;            &quot;contact.5&quot;: &quot;99999&quot;        &#125;    &#125;)\n\n$unset删除字段, 传入任何值都一样，默认设置为 &quot;&quot;, 格式如下:\n&#123; $unset: &#123;field1: &quot;&quot;, ...&#125;&#125;\n\n例如删除 jack 的银行账户余额和开户地点:\ndb.accounts.update(    &#123;name:&quot;jack&quot;&#125;,    &#123;        $unset:        &#123;            balance: &quot;&quot;,            &quot;info.branch&quot;: &quot;&quot;        &#125;    &#125;)\n\n\n删除内嵌文档的字段\n同更新内嵌文档字段方式\n\n\n删除数组内的字段\n同更新内嵌文档字段方式。删除数组中元素成功时，这个元素不会被删除，只会被赋以 null 值，而数组的长度不会改变。\n\n\n\n如果 $unset 命令中的字段不存在，那么文档内容将保持不变\n$rename重命名文档字段\n&#123; $rename: &#123;&lt;field1&gt;: &lt;newName1&gt;, &lt;field2&gt;:&lt;newName2&gt;, ...&#125;&#125;\n\n\n如果 $rename 命令中的字段不存在，那么文档内容将保持不变\n如果新的字段名已经存在，那么原有的这个字段会被覆盖\n\n当 $rename 命令中的新字段存在时，$rename 命令会先 $unset 旧字段，然后再 $set 新字段\n\n重命名内嵌文档的字段\n普通重命名字段名\n同更新内嵌文档字段方式\n\n\n更新内嵌文档中字段的位置  db.accounts.update(    &#123;name: &quot;karen&quot; &#125;    &#123;        $rename:        &#123;            &quot;info.branch&quot;: &quot;branch&quot;,            &quot;balance&quot;: &quot;info.balance&quot;        &#125;    &#125;)\n\n\n\n$rename 命令中的旧字段和新字段都不可以指向数组元素\n$inc &amp; $mul更新字段值, $inc 加减字段值(正负数)，$mul 相乘字段值，格式如下：\n&#123; $inc: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;&#123; $mul: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;\n\n举个例子 david 账户的 notYetExist 值加  10:\ndb.accounts.update(    &#123;name: &quot;david&quot;&#125;，    &#123;        $inc:        &#123;            notYetExist: 10        &#125;    &#125;)\n使用注意: \n\n$inc、 $mul 只能应用在数字字段上\n当更新字段不存在时\n$inc 会创建字段，并且将字段值设定为命令中的增减值\n$mul 会创建字段，但是把字段值设为 0\n\n\n\n$min &amp; $max比较后更新值，$min 比较后保留较小字段值 $max 比较后保留较大字段值：\n&#123; $min: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;&#123; $max: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;\n\n举个例子:\n会将 info.balance 的当前值同 5000 比较，保留较小的值。\ndb.accounts.update(    &#123;name: &quot;david&quot;&#125;，    &#123;        $min:        &#123;            &quot;info.balance&quot;: 5000        &#125;    &#125;)\n\n使用注意: \n\n可以在任何可以比较大小的字段上使用\n当更新字段不存在时\n$min 和 $max 都会创建字段，并且将字段值设定为命令中的更新值。\n\n\n被更新的字段类型和更新值类型不一致\n$min 和 $max会按照 BSON 数据类型排序规则进行比较。\n不同 BSON 类型的值时，MongoDB 使用以下从低到高的比较顺序：    MinKey (internal type)  Null  Numbers (ints, longs, doubles, decimals)  Symbol, String  Object  Array  BinData  ObjectId  Boolean  Date  Timestamp  Regular Expression  MaxKey (internal type)\n\n\n\n\n\n更新数组操作符\n$addToSet 向数组中增添元素\n$pop 从数组中移除元素\n$pull 从数组中有选择性的移出元素\n$pullAll 从数组中有选择性的移出元素\n$push 向数组中增添元素\n\n以上字段只能用到数组字段上，否则会收到错误\n$addToSet$addToSet 向数组中增添元素:\n&#123; $addToSet: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;\n\n如果要插入的值不存在数组字段中\n新增字段会被添加到原文档中\n\n\n如果要插入的值已经存在数组字段中\n$addToSet 不会再添加重复值。 使用 $addToSet插入数组和文档时，插入值中的字段顺序和已有值重复时，才被算着重复值被忽略\n\n\n\n$addToSet 会将数组插入被更新的数组字段中，成为内嵌数组。\ndb.accounts.update(    &#123;name: &quot;karen&quot;&#125;,    &#123;        $addToSet: &#123;contact: [&quot;contact1&quot;, &quot;contact2&quot;]&#125;    &#125;)\n如果想要将多个元素直接添加到数组字段中，则需要使用 $each 操作符\ndb.accounts.update(    &#123;name: &quot;karen&quot;&#125;,    &#123;        $addToSet: &#123;contact: &#123; $each:   [&quot;contact1&quot;, &quot;contact2&quot;] &#125;&#125;    &#125;)\n\n$pop$pop 从数组字段中删除元素, 只能删除数组中的第一个(-1)和最后一个元素(1), 删除掉数组中最后一个元素后，会留下空数组。\n&#123; $pop: &#123; &lt;field&gt;: &lt; -1 | 1 &gt;, ...&#125;&#125;\n\n从 karen 的账户文档中删除最后一个联系方式:\ndb.accounts.update(    &#123;name: &quot;karen&quot;&#125;,    &#123; $pop: &#123; contact: 1 &#125;&#125;)\n\n$pull$pull 从数组中删除符合值或者条件的元素\n&#123; $pull: &#123; &lt;field1&gt;: &lt;value|condition&gt;, ... &#125;&#125;\n\n从 karen的联系方式中删除包含 hi字母的元素:\n针对数组顶级元素的筛选无需使用 $elemMatch, 下面是错误的：\ndb.accounts.update(    &#123; name: &quot;karen&quot;&#125;,    &#123; $pull: &#123; contact: &#123; $elemMatch: &#123;$regex: /hi/ &#125;&#125;&#125;&#125;)\n\n应该是：\ndb.accounts.update(    &#123; name: &quot;karen&quot;&#125;,    &#123; $pull: &#123; contact: &#123; $regex: /hi/ &#125;&#125;&#125;)\n\n要删除数组元素是内嵌数组，可以使用 $elemMatch 对内嵌数组进行筛选:\n从 karen的联系方式中删除包含 22222222的内嵌数组元素:\ndb.accounts.update(    &#123; name: &quot;karen&quot;&#125;,    &#123; $pull: &#123; contact: &#123; $elemMatch: &#123; $eq: &quot;22222222&quot; &#125;&#125;&#125;&#125;  )\n\n$pullAll&#123; $pullAll: &#123; &lt;field1&gt;: [&lt;value1, value2&gt;, ...], ... &#125;&#125;\n\n其实\n&#123; $pullAll: &#123; &lt;field1&gt;: [&lt;value1, value2&gt;] &#125;&#125;\n\n相当于\n&#123; $pull: &#123; &lt;field1&gt;: &#123;$in: [&lt;value1, value2&gt;] &#125;&#125;&#125;\n\n如果要删除的元素是一个数组，数组的元素的值和排列顺序都必须和要被删除的数组完全一样。\n举个例子:\ndb.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $pullAll: &#123;contact: [[&quot;333333&quot;, &quot;222222&quot;]]&#125;&#125;)\n\n如果删除的元素是一个文档\n\n$pullAll 命令只会删除字段和排列顺序都完全匹配的文档元素\n$pull 命令会删除匹配的文档元素，模糊度更高(形成包含关系，或者能通过字段名找到)。\n\n现有文档格式:\ntest&gt; db.accounts.find()[  &#123;    _id: ObjectId(&quot;64ef4c42cb559b034e8de6a0&quot;),    contact: [      &#x27;1&#x27;,      [ &#x27;2&#x27;, &#x27;3&#x27; ],      &#123;        primaryEmail: &#x27;xxx@gmail.com&#x27;,        secondaryEmail: &#x27;yyy@gmail.com&#x27;      &#125;    ],    name: &#x27;alice&#x27;  &#125;]\npullAll 不完全匹配无法删除：\ntest&gt; db.accounts.update( &#123;name:&quot;alice&quot;&#125;, &#123;$pullAll: &#123;contact:[&#123;&quot;scondaryEmail&quot;:&quot;yyy@gmail.com&quot;&#125;]&#125;&#125;)&#123;  acknowledged: true,  insertedId: null,  matchedCount: 0,  modifiedCount: 0,  upsertedCount: 0&#125;\npull 不完全匹配可以删除：\ntest&gt; db.account.update( &#123;name:&quot;alice&quot;&#125;, &#123;$pull: &#123;contact : &#123;&quot;secondaryEmail&quot; : &quot;yyy@gmail.com&quot;&#125;&#125;&#125;)&#123;  acknowledged: true,  insertedId: null,  matchedCount: 0,  modifiedCount: 0,  upsertedCount: 0&#125;\n$push$push 向数组中添加元素\n&#123; $push: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;\n\n$push 和 addTosSet命令相似地方:\n\n如果要插入的值不存在数组字段中\n\n新增字段会被添加到原文档中\n\n\n可以搭配 $each\n  db.accounts.update(     &#123;name: &quot;lawrence&quot;&#125;,     &#123; $push: &#123;         newArray: &#123;             $each:[2, 3, 4]         &#125;     &#125;&#125; )\n$push 比 addTosSet增强地方:\n\n搭配 $each 实现更复杂的操作\n\n使用 $position 操作符将元素插入到数组的指定位置, $position 的值 0 表示 从数组第一个位置开始插入，-2 表示从数组最后一个元素往前走 2 个开始插入。\n  db.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[&quot;pos1&quot;, &quot;pos2&quot;],            $position: 0        &#125;    &#125;&#125;)\n使用 $sort 排序\n  db.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[&quot;sort1&quot;],            $sort: 1        &#125;    &#125;&#125;)\n如果插入的元素是内嵌文档，也可以根据内嵌文档的字段值排序\n  db.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[&#123;key: &quot;sort&quot;, value: 100&#125;, &#123;key: &quot;sort1&quot;, value: 200&#125;],            $sort: &#123; value: -1 &#125; // 只排序插入的内嵌文档        &#125;    &#125;&#125;)\n不想插入，只想对数组中的字段进行排序:\n  db.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[],            $sort: -1        &#125;    &#125;&#125;)\n使用 $slice 截取部分数组\n  插入 slice1 元素后，保留从后往前数 8 个元素:\n  db.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[&quot;slice1&quot;],            $slice: -8        &#125;    &#125;&#125;)\n不想插入，只想截取部分数组:\n  保留数组中的前 6 个元素:\n  db.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[],            $slice: 6        &#125;    &#125;&#125;)\n\n\n\n$position, $sort, $slice 可以一起使用, 他们的执行顺序是 $position &gt; $sort &gt;  $slice。写在命令中的操作顺序并不重要，并不会影响命令的执行顺序。\ndb.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123; $push: &#123;        newArray: &#123;            $each:[&quot;push1&quot;, &quot;push2&quot;],            $position: 2,            $sort: -1,            $slice: 5        &#125;    &#125;&#125;)\n\n$ 占位符$ 是数组中第一个符合筛选条件的数组元素的占位符, 搭配更新操作符使用，可以对满足筛选条件的数组元素进行更新。\ndb.collection.update(    &#123; &lt;array&gt;: &lt;query selector&gt; &#125;,    &#123; &lt;update operator&gt; : &#123; &quot;&lt;array&gt;.$&quot;: value &#125;&#125;)\n\n举个例子，将 lawrence 中 newArray 中的 pos2 替换为 updated:\ndb.accounts.update(    &#123;        name: &quot;lawrence&quot;,        newArray: &quot;pos2&quot;    &#125;,    &#123;        $set: &#123;            &quot;newArray.$&quot;: &quot;updated&quot;        &#125;    &#125;)\n\n$[] 占位符$[] 指代数组中的所有元素\n&#123; &lt;update operator&gt; : &#123; &quot;&lt;array&gt;.$[]&quot;: value &#125;&#125;\n\n举个例子，将 lawrence 账户中的 contact数组中的第一个内嵌数组，全部替换为 999999:\ndb.accounts.update(    &#123;name: &quot;lawrence&quot;&#125;,    &#123;        $set: &#123;            &quot;contact.0.$[]&quot;: 999999        &#125;    &#125;)\noptionsmulti&#123; multi: &lt;boolean&gt; &#125;\n\n默认情况下，即使筛选条件对应了多篇文档，update 命令仍然只会更新一篇文档\n设置 multi 为 true 选项可以更新所有符合筛选条件的文档, 注意，MongoDB 只能保证单个文档操作的原子性，不能保证多个文档操作的原子性。多个文档操作时的原子性需要 MongoDB 4.0 版本引入的事务功能进行操作。\n举个例子：\ndb.accounts.update(    &#123;&#125;,    &#123;        $set: &#123;            currency: &quot;USD&quot;        &#125;,        &#123; multi: true&#125;    &#125;)\n\nupsert&#123; upsert: &lt;boolean&gt; &#125;\n\n更新或者创建文档\n在默认情况下，如果 update 命令中的筛选条件没有匹配任何文档，则不会进行任何操作\n将 upsert 设置为 true， 如果 update 命令中的筛选条件没有匹配任何文档，则会创建新文档\n举个例子:\ndb.accounts.update(    &#123;name: &quot;maggie&quot;&#125;,    &#123;        $set: &#123;            balance: 700        &#125;,        &#123; upsert: true&#125;    &#125;)\n\n如果筛选条件中能推断出确定的字段，新创建的文档会包含筛选条件设计的字段\nsavedb.&lt;collection&gt;.save(&lt;document&gt;)\n\n如果 document 文档中包含 _id 字段， save() 命令将会调用 db.collection.update() 命令(upsert: true), _id 值存在就更新，不存在就创建新文档。\n举个例子:\ndb.accounts.save(    &#123; _id : &quot;account1&quot;, name: &quot;alice&quot;, balance: 100 &#125;)\n\n删除\n删除集合\n删除特定文档\n\n删除文档db.&lt;collection&gt;.remove(&lt;query&gt;, &lt;options&gt;)\n\n&lt;query&gt; 筛选条件\n\n&lt;options&gt; 设置参数\n\n在默认情况下，remove 命令会删除所有复合筛选条件的文档\n\n如果只想删除复合筛选条件的第一篇文档，可以使用 justOne 选项\n  db.accounts.remove(    &#123;balance: &#123; $lt: 100&#125; &#125;,    &#123;justOne: true &#125;)\n\n删除集合内的所有文档\n  db.accounts.remove(&#123;&#125;)\n\n举个例子, 删除 balance 等 50 的文档:\ndb.accounts.remove(    &#123;balance: 50 &#125;)\n\n删除集合remove 只会删除集合内所有的文档，但不会删除集合\ndrop 命令可以删除整个集合，包括集合中的所有文档，以及集合的索引\ndb.&lt;collection&gt;.drop(&#123; writeConcern: &lt;document&gt; &#125;)\n\nwriteConcern 定义了本次集合删除操作的安全写级别\n\n举个例子:\ndb.accounts.drop()\n\n\n如果集合中的文档数量较多，使用 remove 命令删除所有的文档效率不高，这种情况下推荐，使用 drop 命令删除集合，然后再创建空集合并创建索引。\n\n","categories":["mongodb"],"tags":["mongodb"]},{"title":"mongodb 入门-索引","url":"/2023/08/26/mongodb/mongodb-%E5%85%A5%E9%97%A8-%E7%B4%A2%E5%BC%95/","content":"索引\n对文档部分内容进行排序的数据结构\n加快文档查询和文档排序的速度\n复合键索引只能支持前缀子查询\n\n索引操作创建索引db.&lt;collection&gt;.createIndex(&lt;keys&gt;, &lt;options&gt;)\n\n&lt;keys&gt; 文档指定了创建索引的字段\n&lt;options&gt; 创建索引的参数和设定索引的特性\n\n创建一个单键索引db.accountWithIndex.createIndex(&#123;name: 1&#125;)\n创建一个复合键索引db.accountWithIndex.createIndex(&#123;name: 1, balance: -1&#125;)\n创建一个多键索引，创建在数组字段上, 数组字段中的每一个元素都会在多键索引中创建一个键db.accountWithIndex.createIndex(&#123;currency: 1&#125;)\n列出集合中的索引db.accountWithIndex.getIndexes()\n\n删除索引如果需要更改某些字段上已经创建的索引必须首先删除原有索引，再重新创建新索引，否则新索引不会包含原有字段\n使用索引名字删除db.accountWithIndex.dropIndex(&quot;name_1&quot;)\n使用索引定义删除db.accountWithIndex.dropIndex( &#123; name: 1, balance: -1 &#125;)\n\n\n索引类型\n单键索引\n复合键索引\n多键索引\n\n索引特性唯一性db.accountWithIndex.createIndex(&#123;balance:1&#125;,&#123;unique:true&#125;)\n\n如果已有文档中的某个字段出现了重复性，就不可以在这个字段上创建唯一性索引\n如果新增的文档不包含唯一性索引字段，只有第一篇缺失该字段的文档可以被写入数据库，索引中该文档的键值被默认为null\n稀疏性只将包含索引字段的文档加入到索引中(即使索引键字段为null)\ndb.accountWithIndex.createIndex(&#123;balance:1&#125;, &#123; sparse:true&#125;)\n如果同一个索引既具有唯一性，又具有稀疏性，就可以保存多篇缺失索引键值的文档了 \ndb.accountWithIndex.createIndex(&#123;balance:1&#125;, &#123; sparse:true, unique:true&#125;)\n复合键索引也可以具有稀疏性，在这种情况下，只有在缺失复合键所包含的所有字段的情况下，文档才不会加入到索引中\n生存时间db.accountWithIndex.createIndex(&#123;lastAccess:1&#125;,&#123;expireAfterSeconds:20&#125;)\n\n复合键索引不具有生存时间特性，当索引键是包含日期元素的数组字段时，数组中最小的的日期将被用来计算文档是否过期。数据库使用一个后台线程来监测和删除过期文档，删除操作可能有一定的延迟。\n查询分析检视索引的效果 explain()\n命令操作格式:\n  db.&lt;collection&gt;.explain().&lt;method(...)&gt;\n可以使用 explain() 进行分析的命令包括 aggregate()，count()，distinct()，find()，group()，remove()，update()\n\nexplain()返回结果中包含的 winningPlan字段表示数据库的查询方法\n\nstage\nCOLLSCAN 完整查询整个集合\nFETCH IXSCAN 通过索引查询，返回完整文档  - PROJECTION_COVERED  IXSCAN, 直接使用索引存在的字段，无序完整文档，没有 FETCH 阶段\n\n\n\n\n\n没有 IXSCAN 阶段，都耗费资源\n举个例子，explain 排序:\ndb.accountWithIndex.explain().find().sort(&#123;name:1, balance: -1&#125;)\n索引的选择\n如何创建一个合适的索引\n索引对数据库写入操作的影响\n\n","categories":["mongodb"],"tags":["mongodb"]},{"title":"HTTP 代理原理","url":"/2024/07/22/network/HTTP-%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/","content":"1. 引言在网络通信中，HTTP 代理是一个常见的工具，用于在客户端和服务器之间中转HTTP请求和响应。它可以用于多种目的，包括提升安全性、管理网络流量、提高访问速度等。\n2. HTTP代理的基本概念代理服务器的定义：代理服务器（Proxy Server）是一种位于客户端和目标服务器之间的中间服务器，用于转发客户端的请求并将服务器的响应返回给客户端。\nHTTP协议基础：HTTP（Hypertext Transfer Protocol）是用于分布式、协作式和超媒体信息系统的应用层协议，是万维网数据通信的基础。\n3. HTTP代理的工作原理请求流程：\n客户端发送 HTTP 请求到代理服务器。代理服务器接收请求并将其转发给目标服务器。目标服务器处理请求并返回响应给代理服务器。代理服务器将响应返回给客户端\n响应流程：\n与请求流程类似，代理服务器在请求和响应过程中充当中间人角色。\n数据传输和处理：\n代理服务器可以对传输的数据进行缓存、过滤和修改。\n+--------+     HTTP Request     +-----------+    HTTP Request     +-----------+| Client |---------------------&gt;| Proxy     |--------------------&gt;| Target    ||        |                      | Server    |                     | Server    |+--------+                      +-----------+                     +-----------+          &lt;---------------------                  &lt;----------------           HTTP Response                          HTTP Response\n\n4. HTTP代理的类型普通代理HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。\n➜  ~ curl -vvv http://baidu.com*   Trying 39.156.66.10:80...* Connected to baidu.com (39.156.66.10) port 80&gt; GET / HTTP/1.1&gt; Host: baidu.com&gt; User-Agent: curl/8.4.0&gt; Accept: */*\n\n➜  ~ curl -vvv -x http://127.0.0.1:8080 http://www.baidu.com*   Trying 127.0.0.1:8080...* Connected to 127.0.0.1 (127.0.0.1) port 8080&gt; GET http://www.baidu.com/ HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/8.4.0&gt; Accept: */*&gt; Proxy-Connection: Keep-Alive\n完整路径Proxy-ConnectionConnection，以及 Connection 定义的其它 Header，只是对上个节点和当前节点之间的连接进行说明，必须在报文转给下个节点之前删除，否则可能会引发后面要提到的问题。其它不能传递的 Header 还有Prxoy-Authenticate、Proxy-Connection、Transfer-Encoding 和 Upgrade。\n「close」表示操作完成后需要关闭当前连接；Connection 还允许任何字符串作为它的值，如「my-connection」，用来存放自定义的连接说明。HTTP/1.0 默认不支持持久连接，很多 HTTP/1.0 的浏览器和服务器使用「Keep-Alive」这个自定义说明来协商持久连接：浏览器在请求头里加上 Connection: Keep-Alive，服务端返回同样的内容，这个连接就会被保持供后续使用。对于 HTTP/1.1，Connection: Keep-Alive 已经失去意义了，因为 HTTP/1.1 除了显式地将 Connection 指定为 close，默认都是持久连接。\n有了上面的背景知识，我们来看问题。互联网上，存在着大量简陋并过时的代理服务器在继续工作，它们很可能无法理解 Connection——无论是请求报文还是响应报文中的 Connection。而代理服务器在遇到不认识的 Header 时，往往都会选择继续转发。大部分情况下这样做是对的，很多使用 HTTP 协议的应用软件扩展了 HTTP 头部，如果代理不传输扩展字段，这些软件将无法工作。\n如果浏览器对这样的代理发送了 Connection: Keep-Alive，那么结果会变得很复杂。这个 Header 会被不理解它的代理原封不动的转给服务端，如果服务器也不能理解就还好，能理解就彻底杯具了。服务器并不知道 Keep-Alive 是由代理错误地转发而来，它会认为代理希望建立持久连接，服务端同意之后也返回一个 Keep-Alive。同样，响应中的 Keep-Alive 也会被代理原样返给浏览器，同时代理还会傻等服务器关闭连接——实际上，服务端已经按照 Keep-Alive 指示保持了连接，即使数据回传完成，也不会关闭连接。另一方面，浏览器收到 Keep-Alive 之后，会复用之前的连接发送剩下的请求，但代理不认为这个连接上还会有其他请求，请求被忽略。这样，浏览器会一直处于挂起状态，直到连接超时。\n这个问题最根本的原因是代理服务器转发了禁止转发的 Header。但是要升级所有老旧的代理也不是件简单的事，所以浏览器厂商和代理实现者协商了一个变通的方案：首先，显式给浏览器设置代理后，浏览器会把请求头中的 Connection 替换为 Proxy-Connetion。这样，对于老旧的代理，它不认识这个 Header，会继续发给服务器，服务器也不认识，代理和服务器之间不会建立持久连接（不能正确处理 Connection 的都是 HTTP&#x2F;1.0 代理），服务器不返回 Keep-Alive，代理和浏览器之间也不会建立持久连接。而对于新代理，它可以理解 Proxy-Connetion，会用 Connection 取代无意义的 Proxy-Connection，并将其发送给服务器，以收到预期的效果。\n显然，如果浏览器并不知道连接中有老旧代理的存在，或者在老旧代理任意一侧有新代理的情况下，这种方案仍然无济于事。所以有时候服务器也会选择彻底忽略 HTTP&#x2F;1.0 的 Keep-Alive 特性：对于 HTTP&#x2F;1.0 请求，从不使用持久连接，也从不返回 Keep-Alive。\n隧道代理HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。详见 RFC 7231 - HTTP&#x2F;1.1: Semantics and Content\n\n","categories":["Network"],"tags":["http"]},{"title":"I/O 多路复用","url":"/2023/08/17/network/I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"selectselect 实现多路复用的方式是，将已连接的 socket 都放到一个文件描述符集合，然后调用 select函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 socket，然后再对其处理。\n所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。\nselect 函数原型#include &lt;sys/select.h&gt;int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout);\n\n返回值 \n若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1\n\n\n参数\nmaxfd: 待测试的描述符基数，它的值是待测试的最大描述符加 1\nreadfds：读描述符集合\nwritefds：写描述符集合\nerrorfds：异常描述符集合\ntimeout: 超时设置\n\n\n\n\n操作描述集合void FD_ZERO(fd_set *fdset);　　　　　　void FD_SET(int fd, fd_set *fdset);　　void FD_CLR(int fd, fd_set *fdset);　　　int  FD_ISSET(int fd, fd_set *fdset);\n\nFD_ZERO 清空描述符集合；\nFD_SET 向描述符集合增加 fd；\nFD_CLR 向描述符集合删除 fd；\nFD_ISSET 判断描述符集合中的 fd 是否有响应；\n\n超时设置timeval 结构体时间: \nstruct timeval &#123;  long   tv_sec; /* seconds */  long   tv_usec; /* microseconds */&#125;;\n最后一个参数,可以设置 3 种值:\n\n设置成空 (NULL)，表示如果没有 I/O 事件发生，则 select 一直等待下去\n设置一个非零的值，等待超时时间阻塞返回\ntv_sec 和 tv_usec 都设置成 0，表示不等待，检测完毕立即返回\n\n使用 🌰在使用 select 时, 两个注意点:\n\n描述符基数是当前最大描述符 +1；\n每次 select 调用完成之后，要重置待测试集合。\n\nint socket_fd = ...;fd_set ready_fds;while(true) &#123;   FD_ZERO(&amp;read_fds);   FD_SET(socket_fd, &amp;read_fds);   int rc = select(socket_fd + 1, &amp;read_fds, NULL, NULL, NULL);   if (rc == -1) &#123;       perror(&quot;select&quot;);       return 1;   &#125;    if (FD_ISSET(socket_fd, &amp;read_fds)) &#123;       ...    &#125;&#125;\n\n**select 有一个缺点，那就是所支持的文件描述符的个数是有限的。在 Linux 系统中，select 的默认最大值为 1024**。\npollpoll 可以突破 select 文件描述符的个数限制， 函数原型如下: \nint poll(struct pollfd *fds, unsigned long nfds, int timeout);\n\n返回值\n若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1\n\n\n参数\nfds: pollfd数组\nnfds: 描述 fds数组的大小\ntimeout: 超时设置, 单位 ms\n\n\n\npollfd数组pollfd 结构如下:\nstruct pollfd &#123;    int    fd;       /* file descriptor */    short  events;   /* events to look for */    short  revents;  /* events returned */&#125;;\n\nfd: 文件描述\nevents: 待检测的事件类型\nrevents:  响应的事件类型\n\nevents 类型的事件可以分为三大类。\n第一类是可读事件，有以下几种：\n#define POLLIN          0x0001          /* any readable data available */#define POLLPRI         0x0002          /* OOB/Urgent readable data */#define POLLRDNORM      0x0040          /* non-OOB/URG data available */#define POLLRDBAND      0x0080          /* OOB/Urgent readable data */\n我们一般使用 POLLIN, 系统内核通知套接字缓冲区已准备好，通过 read 函数执行读操作不会被阻塞。\n第二类是可写事件，有以下几种：\n#define POLLOUT         0x0004          /* file descriptor is writeable */#define POLLWRNORM      POLLOUT         /* no write type differentiation */#define POLLWRBAND      0x0100          /* OOB/Urgent data can be written */\n我们一般使用 POLLOUT, 系统内核通知套接字缓冲区已准备好，通过 write 函数执行写操作不会被阻塞。\n还有另一大类是错误事件，没有办法通过 poll 向系统内核递交检测请求，只能通过 returned events来加以检测:\n#define POLLERR    0x0008    /* 一些错误发送 */#define POLLHUP    0x0010    /* 描述符挂起 */#define POLLNVAL   0x0020    /* 请求的事件无效 */\n\n不想对某个 pollfd 结构进行事件检测，可以把它对应的 pollfd 结构的 fd 成员设置成一个负值。这样，poll 函数将忽略这样的 events 事件，检测完成以后，所对应的returned events的成员值也将设置为 0。\n超时设置\n&lt; 0，表示如果没有 I/O 事件发生，则 poll 一直等待下去\n&gt; 0，等待超时时间阻塞返回\n= 0，表示不等待，检测完毕立即返回\n\n使用 🌰#define INIT_SIZE 128 int main(int argc, char **argv) &#123;    int listen_fd, connected_fd;    int ready_number;    ssize_t n;    char buf[MAXLINE];    struct sockaddr_in client_addr;     listen_fd = tcp_server_listen(SERV_PORT);     // 初始化 pollfd 数组，这个数组的第一个元素是 listen_fd，其余的用来记录将要连接的 connect_fd    struct pollfd event_set[INIT_SIZE];    event_set[0].fd = listen_fd;    event_set[0].events = POLLRDNORM;     // 用 -1 表示这个数组位置还没有被占用    int i;    for (i = 1; i &lt; INIT_SIZE; i++) &#123;        event_set[i].fd = -1;    &#125;     for (;;) &#123;        if ((ready_number = poll(event_set, INIT_SIZE, -1)) &lt; 0) &#123;            error(1, errno, &quot;poll failed &quot;);        &#125;         if (event_set[0].revents &amp; POLLRDNORM) &#123;            socklen_t client_len = sizeof(client_addr);            connected_fd = accept(listen_fd, (struct sockaddr *) &amp;client_addr, &amp;client_len);             // 找到一个可以记录该连接套接字的位置            for (i = 1; i &lt; INIT_SIZE; i++) &#123;                if (event_set[i].fd &lt; 0) &#123;                    event_set[i].fd = connected_fd;                    event_set[i].events = POLLRDNORM;                    break;                &#125;            &#125;             if (i == INIT_SIZE) &#123;                error(1, errno, &quot;can not hold so many clients&quot;);            &#125;             if (--ready_number &lt;= 0)                continue;        &#125;         for (i = 1; i &lt; INIT_SIZE; i++) &#123;            int socket_fd;            if ((socket_fd = event_set[i].fd) &lt; 0)                continue;            if (event_set[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;                if ((n = read(socket_fd, buf, MAXLINE)) &gt; 0) &#123;                    if (write(socket_fd, buf, n) &lt; 0) &#123;                        error(1, errno, &quot;write error&quot;);                    &#125;                &#125; else if (n == 0 || errno == ECONNRESET) &#123;                    close(socket_fd);                    event_set[i].fd = -1;                &#125; else &#123;                    error(1, errno, &quot;read error&quot;);                &#125;                 if (--ready_number &lt;= 0)                    break;            &#125;        &#125;    &#125;&#125;\nepoll","categories":["Network"],"tags":["socket"]},{"title":"MTU与MSS的奥秘","url":"/2024/03/18/network/MTU%E4%B8%8EMSS%E7%9A%84%E5%A5%A5%E7%A7%98/","content":"最大传输单元（Maximum Transmission Unit, MTU）数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」\n\n不同的数据链路层的 MTU 是不同的。通过 netstat -i 可以查看网卡的 MTU，比如在 我的 ubuntu 机器上可以看到\n-&gt; netstat -iKernel Interface tableIface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flgens33     1500     4513      0      0 0          2872      0      0      0 BMRUlo       65536     5307      0      0 0          5307      0      0      0 LRU\n\nIP 分段网络中的木桶效应：路径 MTUTCP 最大段大小（Max Segment Size，MSS）为什么有时候抓包看到的单个数据包大于 MTUTCP 套接字选项 TCP_MAXSEG小结IP 数据包长度在超过链路的 MTU 时在发送之前需要分片，而 TCP 层为了 IP 层不用分片主动将包切割成 MSS 大小。\n","categories":["Network"],"tags":["tcp","MTU","MSS"]},{"title":"Netfilter 框架浅析","url":"/2024/07/11/network/Netfilter-%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/","content":"Netfilter，在 Linux 内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（NAT）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如 iptables 、nftables 、ebtables 和 arptables 等，来控制 Netfilter，系统管理者可以管理通过Linux操作系统的各种网络数据包。1990 年代，Netfilter 在 Linux 2.3.15 版时进入Linux内核，正式应用于 Linux 2.4 版。\n\n\n下图为网络数据包通过 Netfilter 时的工作流向图：\n\nNetlfilter 框架\nNetlfilter 有 5 个 HOOK 点：\n\nPREROUTING：数据包进入路由表之前\nINPUT：通过路由表后目的地为本机\nFORWARD：通过路由表后，目的地不为本机\nOUTPUT：由本机产生，向外发送\nPOSTROUTIONG：发送到网卡接口之前。\n\n从图中可以看到，三个方向的数据包需要经过的钩子节点不完全相同：\n\n发往本地：NF_INET_PRE_ROUTING --&gt; NF_INET_LOCAL_IN\n转发：NF_INET_PRE_ROUTING--&gt;NF_INET_FORWARD--&gt;NF_INET_POST_ROUTING\n本地发出：NF_INET_LOCAL_OUT--&gt;NF_INET_POST_ROUTING\n\nNetfilter 重要数据结构及相关函数钩子操作数据结构// file: include/linux/netfilter.hstruct nf_hook_ops &#123;\t/* User fills in from here down. */\tnf_hookfn\t\t*hook;\tstruct net_device\t*dev;\tvoid\t\t\t*priv;\tu_int8_t\t\tpf;\tunsigned int\t\thooknum;\t/* Hooks are ordered in ascending priority. */\tint\t\t\tpriority;&#125;;\n\n这个结构体中存储了自定义的钩子函数（nf_hookfn），函数优先级（priority），处理协议类型（pf），钩子函数生效的钩子节点（hooknum）等信息。\n钩子点枚举类型上面提到的网络层中 Netfilter 的几个钩子节点，在内核中是以枚举数据类型进行标记的\n// file: include/uapi/linux/netfilter.h// linux/netfilter.h 会引入uapi/linux/netfilter.henum nf_inet_hooks &#123;    NF_INET_PRE_ROUTING,    NF_INET_LOCAL_IN,    NF_INET_FORWARD,    NF_INET_LOCAL_OUT,    NF_INET_POST_ROUTING,    NF_INET_NUMHOOKS&#125;;\n\n钩子函数声明// include/linux/netfilter.hstruct nf_hook_state &#123;\tunsigned int hook;\tu_int8_t pf;\tstruct net_device *in;\tstruct net_device *out;\tstruct sock *sk;\tstruct net *net;\tint (*okfn)(struct net *, struct sock *, struct sk_buff *);&#125;;typedef unsigned int nf_hookfn(void *priv,\t\t\t       struct sk_buff *skb,\t\t\t       const struct nf_hook_state *state);\n\n注册和解注册钩子函数// file: include/linux/netfilter.h/* Function to register/unregister hook points. */int nf_register_net_hook(struct net *net, const struct nf_hook_ops *ops);void nf_unregister_net_hook(struct net *net, const struct nf_hook_ops *ops);int nf_register_net_hooks(struct net *net, const struct nf_hook_ops *reg,\t\t\t  unsigned int n);void nf_unregister_net_hooks(struct net *net, const struct nf_hook_ops *reg,\t\t\t     unsigned int n);\n\n钩子函数返回的动作// file: include/uapi/linux/netfilter.h// linux/netfilter.h 会引入uapi/linux/netfilter.h#define NF_DROP 0#define NF_ACCEPT 1#define NF_STOLEN 2#define NF_QUEUE 3#define NF_REPEAT 4#define NF_STOP 5\t/* Deprecated, for userspace nf_queue compatibility. */#define NF_MAX_VERDICT NF_STOP\n\n处理协议类型 pf// file: include/uapi/linux/netfilter.h// linux/netfilter.h 会引入uapi/linux/netfilter.henum &#123;\tNFPROTO_UNSPEC =  0,\tNFPROTO_INET   =  1,\tNFPROTO_IPV4   =  2,\tNFPROTO_ARP    =  3,\tNFPROTO_NETDEV =  5,\tNFPROTO_BRIDGE =  7,\tNFPROTO_IPV6   = 10,\tNFPROTO_DECNET = 12,\tNFPROTO_NUMPROTO,&#125;;\n\n优先级 priorities// file: include/uapi/linux/netfilter_ipv4.h// include/netfilter_ipv4.h 会引入uapi/linux/netfilter_ipv4.henum nf_ip_hook_priorities &#123;\tNF_IP_PRI_FIRST = INT_MIN,\tNF_IP_PRI_RAW_BEFORE_DEFRAG = -450,\tNF_IP_PRI_CONNTRACK_DEFRAG = -400,\tNF_IP_PRI_RAW = -300,\tNF_IP_PRI_SELINUX_FIRST = -225,\tNF_IP_PRI_CONNTRACK = -200,\tNF_IP_PRI_MANGLE = -150,\tNF_IP_PRI_NAT_DST = -100,\tNF_IP_PRI_FILTER = 0,\tNF_IP_PRI_SECURITY = 50,\tNF_IP_PRI_NAT_SRC = 100,\tNF_IP_PRI_SELINUX_LAST = 225,\tNF_IP_PRI_CONNTRACK_HELPER = 300,\tNF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,\tNF_IP_PRI_LAST = INT_MAX,&#125;;\n一个 demo#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/netfilter.h&gt;#include &lt;linux/netfilter_ipv4.h&gt;#include &lt;linux/ip.h&gt;#include &lt;linux/tcp.h&gt;#include &lt;linux/udp.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/if_ether.h&gt;#include &lt;linux/string.h&gt;MODULE_LICENSE(&quot;GPLv3&quot;);MODULE_AUTHOR(&quot;TY&quot;);MODULE_DESCRIPTION(&quot;Netfliter test&quot;);static unsigned int nf_test_in_hook(void *priv,                               struct sk_buff *skb,                               const struct nf_hook_state *state);static struct nf_hook_ops nf_test_ops[] __read_mostly = &#123;  &#123;    .hook = nf_test_in_hook,    .pf = NFPROTO_IPV4,    .hooknum = NF_INET_LOCAL_IN,    .priority = NF_IP_PRI_FIRST,  &#125;,&#125;;void hdr_dump(struct ethhdr *ehdr) &#123;    printk(&quot;[MAC_DES:%x,%x,%x,%x,%x,%x&quot;           &quot;MAC_SRC: %x,%x,%x,%x,%x,%x Prot:%x]\\n&quot;,           ehdr-&gt;h_dest[0],ehdr-&gt;h_dest[1],ehdr-&gt;h_dest[2],ehdr-&gt;h_dest[3],           ehdr-&gt;h_dest[4],ehdr-&gt;h_dest[5],ehdr-&gt;h_source[0],ehdr-&gt;h_source[1],           ehdr-&gt;h_source[2],ehdr-&gt;h_source[3],ehdr-&gt;h_source[4],           ehdr-&gt;h_source[5],ehdr-&gt;h_proto);&#125;#define NIPQUAD(addr) \\        ((unsigned char *)&amp;addr)[0], \\        ((unsigned char *)&amp;addr)[1], \\        ((unsigned char *)&amp;addr)[2], \\        ((unsigned char *)&amp;addr)[3]#define NIPQUAD_FMT &quot;%u.%u.%u.%u&quot;static unsigned int nf_test_in_hook(void *priv,                               struct sk_buff *skb,                               const struct nf_hook_state *state) &#123;  struct ethhdr *eth_header;  struct iphdr *ip_header;  eth_header = (struct ethhdr *)(skb_mac_header(skb));  ip_header = (struct iphdr *)(skb_network_header(skb));  hdr_dump(eth_header);  printk(&quot;src IP:&#x27;&quot;NIPQUAD_FMT&quot;&#x27;, dst IP:&#x27;&quot;NIPQUAD_FMT&quot;&#x27; \\n&quot;,         NIPQUAD(ip_header-&gt;saddr), NIPQUAD(ip_header-&gt;daddr));  return NF_ACCEPT;&#125;static int __init init_nf_test(void) &#123;  int ret;  ret = nf_register_hooks(nf_test_ops, ARRAY_SIZE(nf_test_ops));  if (ret &lt; 0) &#123;    printk(&quot;register nf hook fail\\n&quot;);    return ret;  &#125;  printk(KERN_NOTICE &quot;register nf test hook\\n&quot;);  return 0;&#125;static void __exit exit_nf_test(void) &#123;  nf_unregister_hooks(nf_test_ops, ARRAY_SIZE(nf_test_ops));&#125;module_init(init_nf_test);module_exit(exit_nf_test);=\nMakefileobj-m += nf_test.oall:\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean:\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n参考资料\nNetfilter Wiki\nLinux Netfilter and Traffic Control\nLinux Kernel TCP&#x2F;IP Stack|Linux网络硬核系列\n\n","categories":["Network"],"tags":["Netfilter"]},{"title":"QUIC 协议初探","url":"/2024/03/08/network/QUIC-%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/","content":"Package Type\n\nLong Header Packets\nVersion Negotiation Packet\nInitial Packet\n0-RTT Packet\nHandshake Packet\nRetry Packet\n\n\nShort Header Packets\n1-RTT Packet\n\n\n\n+=====================+=================+==================+| Packet Type         | Encryption Keys | PN Space         |+=====================+=================+==================+| Initial             | Initial secrets | Initial          |+---------------------+-----------------+------------------+| 0-RTT Protected     | 0-RTT           | Application data |+---------------------+-----------------+------------------+| Handshake           | Handshake       | Handshake        |+---------------------+-----------------+------------------+| Retry               | N/A             | N/A              |+---------------------+-----------------+------------------+| Version Negotiation | N/A             | N/A              |+---------------------+-----------------+------------------+| Short Header        | 1-RTT           | Application data |+---------------------+-----------------+------------------+\n","categories":["Network"],"tags":["QUIC"]},{"title":"译 SO_REUSEADDR 和 SO_REUSEPORT 有何不同？","url":"/2024/07/18/network/SO-REUSEADDR-%E5%92%8C-SO-REUSEPORT-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F/","content":"Socket 编程中的端口复用：SO_REUSEADDR 和 SO_REUSEPORT欢迎来到一个充满移植性挑战的世界！在深入分析这两个选项之前，我们首先需要了解 BSD 套接字实现是所有套接字实现的鼻祖。几乎所有其他系统都在某个时间点复制了 BSD 套接字实现，或至少是其接口，然后在此基础上发展演变。当然，BSD 套接字实现本身也在不断演变，因此那些更晚期复制它的系统获得了更早期系统所缺乏的功能。理解 BSD 套接字实现是理解其他所有套接字实现的关键，即使你不打算为 BSD 系统编写代码，也应该了解它。\n在深入探讨 SO_REUSEADDR 和 SO_REUSEPORT 之前，你需要了解一些基本知识。一个 TCP/UDP 连接由五个值组成的元组标识：\n&#123;&lt;协议&gt;, &lt;源地址&gt;, &lt;源端口&gt;, &lt;目标地址&gt;, &lt;目标端口&gt;&#125;\n任何唯一的这些值组合标识一个连接。因此，没有两个连接可以具有相同的五个值，否则系统将无法区分这些连接。\n套接字的基本操作\n创建套接字：使用 socket() 函数设置套接字的协议。\n绑定地址和端口：使用 bind() 函数设置源地址和端口。\n连接目标地址和端口：使用 connect() 函数设置目标地址和端口。对于 UDP，由于它是无连接协议，可以在不连接的情况下使用。然而，在某些情况下连接它是有益的。在无连接模式下，如果未显式绑定，UDP 套接字通常会在第一次发送数据时由系统自动绑定，因为未绑定的 UDP 套接字无法接收任何（回复）数据。对于未绑定的 TCP 套接字也是如此，它在连接之前会自动绑定。\n\n\n\n可以将套接字显式绑定到端口 0，这意味着任意端口。系统将从预定义的源端口范围中选择一个特定端口。同样，源地址也可以是任意地址（IPv4 中是 0.0.0.0，IPv6 中是 ::）。一个套接字可以绑定到“任意地址”，意味着它绑定到所有本地接口的所有源 IP 地址。如果套接字随后连接，系统必须选择一个特定的源 IP 地址，并用选择的源 IP 地址替换任意绑定。\n默认情况下，没有两个套接字可以绑定到相同的源地址和源端口组合。只要源端口不同，源地址实际上是无关紧要的。将 socketA 绑定到 ipA和将 socketB 绑定到 ipB总是可以的，如果 ipA != ipB 即使 portA == portB 也没有问题。例如，socketA 属于一个 FTP 服务器程序，绑定到 192.168.0.1:21，而 socketB 属于另一个 FTP 服务器程序，绑定到 10.0.0.1:21，这两个绑定都会成功。然而，如果一个套接字绑定到 0.0.0.0:21，它绑定到所有现有的本地地址，因此没有其他套接字可以绑定到端口 21，无论尝试绑定到哪个具体的 IP 地址，因为 0.0.0.0 与所有现有的本地 IP 地址冲突。\n这些基本操作在所有主要操作系统中基本相同。接下来，当涉及到地址重用时，操作系统之间的处理方式会有所不同。我们从 BSD 开始，因为它是所有套接字实现的源头。\nBSD 中的端口复用SO_REUSEADDR如果在绑定之前在套接字上启用了 SO_REUSEADDR，除非与另一个套接字完全相同的源地址和端口组合发生冲突，否则该套接字可以成功绑定。关键在于“完全相同”。SO_REUSEADDR 主要改变了在搜索冲突时如何处理通配符地址（“任意 IP 地址”）。\n没有 SO_REUSEADDR 的情况下，绑定 socketA 到 0.0.0.0:21 后，再绑定 socketB 到 192.168.0.1:21 会失败（错误 EADDRINUSE），因为 0.0.0.0 意味着“任意本地 IP 地址”，因此所有本地 IP 地址都被这个套接字视为正在使用，包括 192.168.0.1。但有了 SO_REUSEADDR，这种绑定会成功，因为 0.0.0.0 和 192.168.0.1 并不完全相同，一个是所有本地地址的通配符，另一个是非常具体的本地地址。这个行为无论 socketA 和 socketB 绑定的顺序如何，结果都是一样的：没有 SO_REUSEADDR 时会失败，有 SO_REUSEADDR 时会成功。\n以下是一个更好的概述，列出了所有可能的组合：\n\n\n\nSO_REUSEADDR\nsocketA\nsocketB\n结果\n\n\n\nON&#x2F;OFF\n192.168.0.1:21\n192.168.0.1:21\n错误 (EADDRINUSE)\n\n\nON&#x2F;OFF\n192.168.0.1:21\n10.0.0.1:21\n成功\n\n\nON&#x2F;OFF\n10.0.0.1:21\n192.168.0.1:21\n成功\n\n\nOFF\n0.0.0.0:21\n192.168.1.0:21\n错误 (EADDRINUSE)\n\n\nOFF\n192.168.1.0:21\n0.0.0.0:21\n错误 (EADDRINUSE)\n\n\nON\n0.0.0.0:21\n192.168.1.0:21\n成功\n\n\nON\n192.168.1.0:21\n0.0.0.0:21\n成功\n\n\nON&#x2F;OFF\n0.0.0.0:21\n0.0.0.0:21\n错误 (EADDRINUSE)\n\n\n上表假设 socketA 已成功绑定到给定的地址，然后创建 socketB，并设置或不设置 SO_REUSEADDR，最后绑定 socketB 到给定的地址。结果是 socketB 绑定操作的结果。如果第一列显示 ON/OFF，则 SO_REUSEADDR 的值与结果无关。\nSO_REUSEADDR 的另一个重要作用是在 TCP 协议中的应用。通常，当一个 TCP 套接字关闭时，会进行一个 3 步握手（FIN-ACK）。问题在于，最后一个 ACK 可能到达另一端，也可能没有到达。如果没有到达，另一端仍然认为套接字是打开的。为了防止重用可能仍然被远程对等方视为打开的地址和端口组合，系统在发送最后一个 ACK 后不会立即将套接字视为关闭，而是将其置于称为 TIME_WAIT 的状态。这个状态可能持续几分钟（取决于系统设置）。虽然大多数系统可以通过启用延迟并设置延迟时间为零来绕过这个状态，但这并不总是可行，并且即使系统支持这种请求，也会导致套接字通过复位（RST）关闭，这并不总是一个好主意。\n系统如何处理处于 TIME_WAIT 状态的套接字？如果未设置 SO_REUSEADDR，处于 TIME_WAIT 状态的套接字仍被视为绑定到源地址和端口，任何尝试绑定到相同地址和端口的新套接字都会失败，直到套接字真正关闭。因此，不要期望在关闭套接字后立即重新绑定源地址，大多数情况下会失败。然而，如果为尝试绑定的套接字设置了 SO_REUSEADDR，则处于 TIME_WAIT 状态的另一个套接字会被忽略，因此你的套接字可以毫无问题地绑定到相同的地址和端口。在这种情况下，即使另一个套接字具有完全相同的地址和端口也是无关紧要的。请注意，绑定一个套接字到与 TIME_WAIT 状态的套接字相同的地址和端口可能会产生意外且通常是不希望的副作用，但这些副作用在实践中相对罕见。\n还有一个关于 SO_REUSEADDR 的最后一点要注意的事情。上述所有内容都适用于绑定时具有地址重用的套接字。无需另一个已绑定或处于 TIME_WAIT 状态的套接字也设置此标志。决定绑定操作是否成功或失败的代码只会检查传入的 bind() 调用的套接字的 SO_REUSEADDR 标志，不会查看其他套接字的此标志。\nSO_REUSEPORTSO_REUSEPORT 实现了大多数人对 SO_REUSEADDR 的期望。基本上，启用该选项的套接字不仅可以在有重叠绑定的情况下绑定，还可以与已绑定的套接字共享同一个地址和端口组合。只要所有套接字都设置了 SO_REUSEPORT 标志，它们都可以绑定到相同的地址和端口。\nSO_REUSEPORT 的一个重要应用是负载平衡。多个进程或线程可以同时绑定到相同的地址和端口，系统将确保传入的连接或数据包均匀地分布在所有套接字上。对于服务器应用程序来说，这可以显著提高并发处理能力和性能。\n在 BSD 系统上，启用 SO_REUSEPORT 后，套接字绑定的行为如下：\n\n\n\nSO_REUSEPORT\nsocketA\nsocketB\n结果\n\n\n\nON\n192.168.0.1:21\n192.168.0.1:21\n成功\n\n\nON\n0.0.0.0:21\n0.0.0.0:21\n成功\n\n\nOFF\n0.0.0.0:21\n192.168.0.1:21\n成功（如上所述）\n\n\nOFF\n192.168.0.1:21\n0.0.0.0:21\n成功（如上所述）\n\n\nOFF\n0.0.0.0:21\n0.0.0.0:21\n错误 (EADDRINUSE)\n\n\nOFF\n192.168.0.1:21\n192.168.0.1:21\n错误 (EADDRINUSE)\n\n\n如上所述，SO_REUSEPORT 的行为与 SO_REUSEADDR 不同。必须为所有套接字设置此标志才能共享同一个地址和端口。这个特性在实现高性能、高并发服务器应用程序时尤为重要。\n在其他系统上的行为Linux在 Linux 系统上，SO_REUSEADDR 和 SO_REUSEPORT 的行为与 BSD 系统基本一致。然而，Linux 在一些细节上有所不同。例如，在 TCP 套接字关闭时的 TIME_WAIT 状态处理上，Linux 可能比 BSD 更灵活。此外，Linux 还支持一些额外的套接字选项和特性，如 TCP_FASTOPEN 和 TCP_DEFER_ACCEPT，这些选项可以进一步优化性能和可靠性。\nWindows在 Windows 系统上，SO_REUSEADDR 和 SO_REUSEPORT 的行为也与 BSD 和 Linux 基本一致。然而，Windows 套接字 API 在一些实现细节和错误处理上有所不同。例如，Windows 在处理地址重用和 TIME_WAIT 状态时，可能会有一些特定的行为和限制。此外，Windows 套接字 API 还支持一些特有的选项和特性，如 WSAIoctl 和 overlapped I/O，这些特性在实现高性能网络应用时非常有用。\nmacOS在 macOS 系统上，SO_REUSEADDR 和 SO_REUSEPORT 的行为基本与 BSD 系统相同。由于 macOS 基于 BSD 内核，其套接字实现与 BSD 非常相似。然而，macOS 在一些细节和特性上可能会有所不同。例如，macOS 在处理套接字关闭和资源释放时，可能会有一些特定的优化和改进。此外，macOS 还支持一些特有的套接字选项和特性，如 kqueue 和 GCD，这些特性在实现高性能、高并发网络应用时非常有用。\n结论理解和正确使用 SO_REUSEADDR 和 SO_REUSEPORT 是实现高性能网络应用的关键。虽然这些选项在不同系统上的实现可能有所不同，但它们的基本原理和应用场景是相同的。在编写跨平台的网络应用时，了解这些选项在不同系统上的行为和限制，可以帮助你更好地优化和调试你的程序。希望本文能够帮助你更好地理解和使用这些重要的套接字选项，并在实际应用中取得成功。\n参考资料\nhow-do-so-reuseaddr-and-so-reuseport-differ?\n\n","categories":["Network"],"tags":["tcp"]},{"title":"SOCKS5 代理协议详解","url":"/2025/05/07/network/SOCKS5-%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","content":"SOCKS5 代理协议详解SOCKS5 是一种网络代理协议，是 SOCKS 协议的第五个版本, 它不仅支持传统的 TCP 连接，还增加了对 UDP 和多种认证方法的支持。SOCKS5 工作在 OSI 模型的会话层，广泛用于突破网络限制、隐藏客户端真实 IP 等场景。本文深入解析其协议字段、工作模式及认证机制。\n\n\n\n协议基础\n协议版本：SOCKS5（版本号 0x05）\n\n核心功能：\n\n转发 TCP/UDP 流量\n支持 IPv4/IPv6/域名\n多种认证方式\n\n\n方法值（HEX）\n认证方法\n说明\n\n\n\n0x00\n无认证\n默认方法，无需额外步骤\n\n\n0x01\nGSSAPI\n基于 Kerberos 等安全协议\n\n\n0x02\nUsername&#x2F;Password\n用户名密码认证\n\n\n0x03-0x7F\nIANA 分配\n预留标准方法\n\n\n0x80-0xFE\n私有方法\n厂商自定义认证\n\n\n\n\n\n端口：默认 1080\n\n\n\nSOCKS5 协议工作流程SOCKS5 协议的基本工作流程可以分为以下几个步骤：\n\n客户端连接 SOCKS5 代理服务器客户端与代理服务器建立 TCP 连接。\n\n客户端进行认证（如果需要的话）客户端发送支持的认证方式，代理服务器选择合适的认证方法。\n\n客户端发起请求客户端向代理服务器发起 CONNECT、BIND 或 UDP 转发请求。\n\n代理服务器处理请求并返回响应代理服务器处理请求并返回结果。如果请求成功，数据转发开始。\n\n\n\n协议字段详解1. 认证方法协商客户端 → 代理服务器\n\n\n字段\n长度（字节）\n值（示例）\n说明\n\n\n\nVER\n1\n0x05\nSOCKS5 版本\n\n\nNMETHODS\n1\n0x02\n支持的认证方法数量\n\n\nMETHODS\n可变\n0x00, 0x02\n方法列表\n\n\n代理服务器 → 客户端\n\n\n字段\n长度（字节）\n值（示例）\n说明\n\n\n\nVER\n1\n0x05\nSOCKS5 版本\n\n\nMETHOD\n1\n0x02\n选择的认证方法\n\n\n认证流程时序(用户名&#x2F;密码认证举例)客户端               代理服务器  |--- METHOD Negotiation --&gt;|  |&lt;-- Chosen Method --------|  |--- Username/Password ---&gt;| （仅当 METHOD=0x02 时）  |&lt;-- Auth Result ----------|\n\n2. 请求&#x2F;响应格式客户端请求（以 CONNECT 为例）\n\n\n字段\n长度（字节）\n值（示例）\n说明\n\n\n\nVER\n1\n0x05\nSOCKS5 版本\n\n\nCMD\n1\n0x01\n命令（CONNECT）\n\n\nRSV\n1\n0x00\n保留字段\n\n\nATYP\n1\n0x01\n地址类型（IPv4）\n\n\nDST.ADDR\n4\n0xC0A80101\n目标地址（192.168.1.1）\n\n\nDST.PORT\n2\n0x0050\n目标端口（80）\n\n\n\n地址类型（ATYP）：\n0x01：IPv4（4 字节地址）。\n0x03：域名（1 字节长度 + 变长域名，如 0x07 &quot;example.com&quot;）。\n0x04：IPv6（16 字节地址）。\n\n\n端口字节序：\n所有端口号均为 大端字节序（如 53 → 0x0035）。\n\n\n\n代理服务器响应\n\n\n字段\n长度（字节）\n值（示例）\n说明\n\n\n\nVER\n1\n0x05\nSOCKS5 版本\n\n\nREP\n1\n0x00\n响应状态（成功）\n\n\nRSV\n1\n0x00\n保留字段\n\n\nATYP\n1\n0x01\n地址类型（IPv4）\n\n\nBND.ADDR\n4\n0x00000000\n绑定地址\n\n\nBND.PORT\n2\n0x0000\n绑定端口\n\n\n\n工作模式CONNECT 模式\n用途：客户端正向连接目标服务器（如 HTTP/HTTPS）。\n流程：\n客户端发送 CONNECT 请求。\n代理建立与目标服务器的 TCP 连接。\n代理返回响应，开始转发数据。\n\n\n\n客户端               代理服务器              目标服务器  |--- CONNECT 请求 ---&gt;|                        |  |                     |--- 连接目标服务器 ---&gt;|  |&lt;------- 响应 -------|                        |  |==================== 数据转发 ===============&gt;|\n\n\nBIND 模式\n用途：允许目标服务器反向连接客户端（如 FTP 主动模式）。\n\n流程：\n\n客户端发送 BIND 请求。\n代理监听端口并返回地址。\n客户端通知目标服务器连接代理端口。\n代理接受连接并转发数据。\n\n\n\n客户端               代理服务器              目标服务器  |--- BIND 请求 -------&gt;|                        |  |&lt;---- 监听端口 -------|                        |  |--- 通知目标服务器 --&gt;|                        |  |                     |&lt;--- 反向连接 ----------|  |&lt;---- 连接确认 -------|                        |  |==================== 数据转发 ===============&gt;|\n\n\nUDP ASSOCIATE 模式\n用途：转发 UDP 数据包（如 DNS 查询）。\n\n流程：\n\n客户端通过 TCP 协商 UDP 端口。\n客户端发送封装 UDP 数据到代理。\n代理解包并转发到目标服务器。\n\n\n\nUDP 数据包格式UDP 关联的生命周期与 TCP 控制连接绑定。若 TCP 连接断开，代理将关闭 UDP 端口。\n\n\n\n字段\n长度（字节）\n说明\n\n\n\nRSV\n2\n保留字段\n\n\nFRAG\n1\n分片编号, 0x00（不分片）\n\n\nATYP\n1\n地址类型\n\n\nDST.ADDR\n可变\n目标地址\n\n\nDST.PORT\n2\n目标端口\n\n\nDATA\n可变\nUDP 数据\n\n\n认证机制无认证\n方法值: 0x00\n流程：无需额外步骤，直接转发请求。\n\n用户名&#x2F;密码认证\n方法值: 0x02\n客户端请求：VER（0x01） | ULEN | UNAME | PLEN | PASSWD\n代理响应：VER（0x01） | STATUS（0x00=成功）\n\nGSSAPI 认证\n方法值: 0x01\n\n流程：\n\n通过令牌交换建立安全上下文。\n加密&#x2F;签名后续通信数据。\n\n\n\n应用场景\n网络穿透：绕过防火墙或 NAT 限制。\n隐私保护：隐藏客户端真实 IP。\n协议支持：代理非 HTTP 流量（如 FTP 、SMTP）。\n负载均衡：通过代理分发请求。\n\n安全注意事项\n明文风险：用户名&#x2F;密码认证需配合 TLS 加密。\n端口暴露：BIND/UDP 模式可能被滥用。\n访问控制：限制代理服务的访问权限。\n超时设置：及时关闭空闲连接。\n\n总结SOCKS5 凭借其灵活性，成为代理技术的核心协议：\n\n优势：支持多协议、认证机制、反向连接。\n局限：UDP 实现复杂，原生无加密。\n适用场景：企业内网穿透、隐私保护、混合协议代理。\n\n理解协议细节有助于优化代理实现，并规避潜在安全风险。\n参考文献\nSOCKS Protocol Version 5\nSOCKS5协议详细解析\n\n","categories":["Network"],"tags":["SOCKS5"]},{"title":"TCP Nagle算法与ACK延迟确认","url":"/2023/11/20/network/TCP-Nagle%E7%AE%97%E6%B3%95%E4%B8%8EACK%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/","content":""},{"title":"TCP-TFO快速打开","url":"/2024/03/21/network/TCP-TFO%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80/","content":"简介TCP 快速打开（TCP Fast Open，简称TFO）是对计算机网络中传输控制协议（TCP）连接的一种简化握手手续的拓展，用于提高两端点间连接的打开速度。\n它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。这个加密的 Cookie 被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个 Cookie 被重复返回。\n\n最显著的优点是可以利用握手去除一个往返 RTT\n\n开启 TFOnet.ipv4.tcp_fastopen 是 Linux 内核中的一个配置参数，它用于控制 TCP Fast Open 功能。具体地，net.ipv4.tcp_fastopen 的值可以是以下几种：\n\n0：禁用 TCP Fast Open 功能。\n1：在客户端启用 TCP Fast Open 功能。\n2：在服务器端启用 TCP Fast Open 功能。\n3：在客户端和服务器端都启用 TCP Fast Open 功能。\n\n通过设置这个参数，可以根据实际需求选择是否启用和在哪一端启用 TCP Fast Open，从而优化网络性能。\n\n\n请求 Fast Open Cookie 的过程如下：\n客户端发送一个 SYN 包，头部包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie\n服务端收取 SYN 包以后，生成一个 cookie 值（一串字符串）\n服务端发送 SYN + ACK 包，在 Options 的 Fast Open 选项中设置 cookie 的值\n客户端缓存服务端的 IP 和收到的 cookie 值\n\n第一次过后，客户端就有了缓存在本地的 cookie 值，后面的握手和数据传输过程如下：\n\n客户端发送 SYN 数据包，里面包含数据和之前缓存在本地的 Fast Open Cookie。\n服务端检验收到的 TFO Cookie 和传输的数据是否合法。\n如果合法就会返回 SYN + ACK 包进行确认并将数据包传递给应用层\n如果不合法就会丢弃数据包，走正常三次握手流程（只会确认 SYN）\n\n\n服务端程序收到数据以后可以握手完成之前发送响应数据给客户端了\n客户端发送 ACK 包，确认第二步的 SYN 包和数据（如果有的话）后面的过程就跟非 TFO 连接过程一样了\n\n我们看看 curl 如何支持 fast open, 通过 strace 抓下:\nstrace curl --tcp-fastopen http://192.168.14.168\n\n我们看下在服务器的抓包信息:\n第一次请求fast open cookie 为空\n第二次请求第一个 SYN 包被识别成了 HTTP 请求\n\n参考资料\nTCP快速打开 WIKI\n\n","categories":["Network"],"tags":["tcp","tfo"]},{"title":"TCP 协议","url":"/2023/07/25/network/TCP-%E5%8D%8F%E8%AE%AE/","content":"TCP 基本认识TCP 是 面向连接的、可靠的、基于字节流的传输层通信协议。\n 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          Source Port          |       Destination Port        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        Sequence Number                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Acknowledgment Number                      |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           Checksum            |         Urgent Pointer        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                             data                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n源端口(Source Port)源端口，16 位\n目标端口(Destination Port)目标端口，16 位\n序列号 (Sequence Number)TCP 是面向字节流的协议，通过 TCP 传输的字节流的每个字节都分配了序列号，序列号（Sequence number）指的是本报文段第一个字节的序列号。\n序列号加上报文的长度，就可以确定传输的是哪一段数据。序列号是一个 32 位的无符号整数，达到 2^32-1 后循环到 0。\n在 SYN 报文中，序列号用于交换彼此的初始序列号，在其它报文中，序列号用于保证包的顺序。\n因为网络层（IP 层）不保证包的顺序，TCP 协议利用序列号来解决网络包乱序、重复的问题，以保证数据包以正确的顺序组装传递给上层应用。\n初始序列号 （Initial Sequence Number, ISN）在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。在建立连接时，通信双方通过 SYN 报文交换彼此的 ISN\n序列号回绕确认号 (Acknowledgment Number)TCP 使用确认号（Acknowledgment number, ACK）来告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到\n头部长度 (Data Offset ):只有 4 位, 取值范围 0~15, 表示 TCP头长度为 32位(4字节)的数量。TCP 头（甚至包括选项）的长度是 32 位的整数倍。例如 DOffset的值为 0111, 则该TCP包头的长度为 7 * 4 = 28\nTCP Flags\nSYN（Synchronize）：用于发起连接数据包同步双方的初始序列号\nACK（Acknowledge）：确认数据包\nRST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理\nFIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。\nPSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来\n\n窗口大小 (Window Size)窗口大小字段是接收方用来控制发送方数据流量的机制。它表示接收方当前允许发送方发送但尚未确认的数据字节数。通过动态调整窗口大小，TCP 可以有效地进行流量控制，防止发送方数据发送过快导致接收方缓存溢出。\nTCP 协议窗口大小只有 16 位，最大窗口大小为 65535 字节(64KB), 在今天显然不够用，所以 TCP 协议引入了 TCP 窗口缩放 选项，作为窗口缩放的比例因子，比利因子的值在 0～14，其中 0 表示不缩放，最大值为  14。比例因子可以将窗口扩大到原来的 2 的 n 次方，比如窗口大小缩放前为 1050，缩放因子为 7，则真正的窗口大小为 1050 * 128 = 134400\n窗口缩放选项由于窗口大小字段只有 16 位，最大值为 65535 字节，这对于高带宽-延迟产品 (BDP) 的网络可能不够。为了解决这个问题，TCP 窗口缩放选项 (Window Scale Option) 被引入，用于扩展窗口大小的范围。\n窗口缩放选项在 TCP 连接建立时通过 SYN 包交换协商。窗口缩放因子 (Window Scale Factor) 表示允许窗口大小值左移的位数，从而有效地扩展窗口大小的范围。\n计算实际窗口大小实际的窗口大小计算如下：\n$$Actual Window Size &#x3D; Window Size \\times 2 ^{Window Scale Factor}$$\n示例（带窗口缩放）假设窗口大小字段的值是 8192（十进制），窗口缩放因子是 3：\n$Actual Window Size &#x3D; 8192 \\times 2 ^ 3 &#x3D; 8192 \\times 8 &#x3D; 65536 $ bytes\n这表示接收方可以接受最多 65536 字节的未确认数据。\n可选项 (Options)只有 (DOffset &gt; 5) 才有此数据,\n可选项的格式：\n\n一个字节的 Kind\n\nNo-Operation: 无操作。\n\n\n一个字节的 Kind, 一个字节的 option-length，和真实的 option data\n\nMSS：最大段大小选项，是 TCP 允许的从对方接收的最大报文段\nSACK：选择确认选项\nWindow Scale：窗口缩放选项\nTCP 连接状态图\n\n\n\n                             +---------+ ---------\\      active OPEN                             |  CLOSED |            \\    -----------                             +---------+&lt;---------\\   \\   create TCB                               |     ^              \\   \\  snd SYN                  passive OPEN |     |   CLOSE        \\   \\                  ------------ |     | ----------       \\   \\                   create TCB  |     | delete TCB         \\   \\                               V     |                      \\   \\                             +---------+            CLOSE    |    \\                             |  LISTEN |          ---------- |     |                             +---------+          delete TCB |     |                  rcv SYN      |     |     SEND              |     |                 -----------   |     |    -------            |     V+---------+      snd SYN,ACK  /       \\   snd SYN          +---------+|         |&lt;-----------------           ------------------&gt;|         ||   SYN   |                    rcv SYN                     |   SYN   ||   RCVD  |&lt;-----------------------------------------------|   SENT  ||         |                    snd ACK                     |         ||         |------------------           -------------------|         |+---------+   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+  |           --------------   |     |   -----------  |                  x         |     |     snd ACK  |                            V     V  |  CLOSE                   +---------+  | -------                  |  ESTAB  |  | snd FIN                  +---------+  |                   CLOSE    |     |    rcv FIN  V                  -------   |     |    -------+---------+          snd FIN  /       \\   snd ACK          +---------+|  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  || WAIT-1  |------------------                              |   WAIT  |+---------+          rcv FIN  \\                            +---------+  | rcv ACK of FIN   -------   |                            CLOSE  |  | --------------   snd ACK   |                           ------- |  V        x                   V                           snd FIN V+---------+                  +---------+                   +---------+|FINWAIT-2|                  | CLOSING |                   | LAST-ACK|+---------+                  +---------+                   +---------+  |                rcv ACK of FIN |                 rcv ACK of FIN |  |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  |  -------              x       V    ------------        x       V   \\ snd ACK                 +---------+delete TCB         +---------+    ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |                             +---------+                   +---------+\n\n如何唯一确定一个 TCP 连接?TCP 四元组可以唯一的确定一个连接，四元组包括如下：\n\n源地址\n源端口\n目的地址\n目的端口\n\nTCP 连接建立三次握手\n防止历史连接\n避免资源浪费\n同步双方初始序列号\n\n    TCP A                                                TCP B1.  CLOSED                                               LISTEN2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED\n\n重传机制TCP 针对数据包丢失的情况，会用重传机制解决。\n超时重传RTT（Round-Trip Time 往返时延）指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。\n超时重传时间是以 RTO （Retransmission Timeout）表示。\n精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。\n\n当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；\n当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n\n根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。因为网络也是时常变化的，所以 RTO 是一个动态变化的值。\n每当遇到一次超时重传的时候，都会将下一次 RTO 设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。\n快速重传当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。\nSACKSACK（Selective Acknowledgment），选择性确认。在 TCP 头部「选项」字段里加一个 SACK ，它可以将已收到的数据的信息发送给 「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以 只重传丢失的数据。\n\n在 Linux 下可以通过 net.ipv4.tcp_sack 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。\n\nD-SACKD-SACK (Duplicate SACK) ，其主要使用了 SACK 来告诉 「发送方」有哪些数据被重复接收了。\nD-SACK 有这么几个好处：\n\n可以让发送方知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了\n可以知道是不是发送方的数据包被网络延迟了\n可以知道网络中是不是把发送方的数据包给复制了\n\n\n在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。\n\n滑动窗口窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值\n发送窗口接收窗口流量控制发送方不能无脑的发数据给接收方，要考虑接收方处理能力。\n如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。\n为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**\n操作系统缓冲区和滑动窗口的关系窗口关闭如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。\n糊涂窗口综合症拥塞控制慢启动慢启动就是一点一点的提高发送数据包的数量, 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1, 发包的个数是指数性的增长\n\n慢启动门限 ssthresh （slow start threshold）状态变量，默认 65535 大小。\ncwnd &lt; ssthresh 时，使用慢启动算法。\ncwnd &gt;&#x3D; ssthresh 时，就会使用拥塞避免算法。\n\n\n\n拥塞避免每当收到一个 ACK 时，cwnd 增加 1/cwnd, 发包的个数是线性的增长\n拥塞发送当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：\n\n超时重传\n快速重传\n\n超时重传\nssthresh 设为 cwnd/2，\ncwnd 重置为 10 （是恢复为 cwnd 初始化值，Linux 默认的 cwnd 初始化值 10）\n进入慢启动接着重新开始慢启动，慢启动是会突然减少数据流的, 这种方式太激进了，反应也很强烈，会造成网络卡顿。\n\n快速重传当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。\nTCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：\n\ncwnd = cwnd/2 ，也就是设置为原来的一半\nssthresh = cwnd\n进入快速恢复算法\n\n快速恢复前面已讲进入快速恢复之前，cwnd 和 ssthresh 已被更新了：\n\ncwnd = cwnd/2 ，也就是设置为原来的一半\nssthresh = cwnd\n\n然后，进入快速恢复算法如下：\n\n拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；\n重传丢失的数据包；\n如果再收到重复的 ACK，那么 cwnd 增加 1；\n如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；\n\n参考资料\n深入理解TCP协议-从原理到实战\n图解网络\n\n","categories":["Network"],"tags":["tcp"]},{"title":"http协议","url":"/2023/07/17/network/http%E5%8D%8F%E8%AE%AE/","content":"HTTP 是什么？HTTP 是超文本传输协议，也就是 HyperText Transfer Protocol。\nURI 的完整图解  foo://example.com:8042/over/there?name=ferret#nose  \\_/   \\______________/\\_________/ \\_________/ \\__/   |           |            |            |        |scheme     authority       path        query   fragment   |   _____________________|__  / \\ /                        \\  urn:example:animal:ferret:nose\n\n消息格式start-line*( header-field CRLF )CRLF[ message-body ]\n\nstart-line\nrequest line\nmethod SP request-target SP HTTP-version CRLF\n\n\nstatus line\nHTTP-version SP status-code SP reason-phrase CRLF\n\n\n\nHeader Fields\nfield-name “:” OWS field-value OWS\n\nMessage Body在一个请求中是否会出现消息体，以消息头中是否带有 Content-Length 或者 Transfer-Encoding 头字段作为信号\nProxy 代理普通代理RFC 7230 - HTTP&#x2F;1.1: Message Syntax and Routing 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。\n隧道代理RFC 7231 - HTTP&#x2F;1.1: Semantics and Content HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。\nCONNECT server.example.com:80 HTTP/1.1\n\n\nHTTP/1.1、HTTP/2、HTTP/3 演变HTTP/1.1 的优化\n长连接\n支持管道 （pipeline）网络传输\n\n但 HTTP/1.1 还是有性能瓶颈：\n\n请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；\n发送冗长的首部。每次互相发送相同的首部造成的浪费较多；\n服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；\n没有请求优先级控制；\n请求只能从客户端开始，服务器只能被动响应。\n\nHTTP/2 的优化\n头部压缩\n二进制格式\n并发传输\n服务器主动推送资源\n\nHTTP/3 的优化HTTP/3 基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输, 有以下 3 个特点。\n\n无队头阻塞\n更快的连接建立\n连接迁移\n\n","categories":["Network"],"tags":["http"]},{"title":"libevent 使用入门","url":"/2023/08/23/network/libevent-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","content":"概述libEvent, 一个事件通知库。有以下特点：\n\n事件驱动，高性能；\n轻量级，专注于网络；\n跨平台，支持 Windows、Linux、Mac 等；\n支持多种 I/O 多路复用技术， epoll、poll、dev/poll、select 和 kqueue 等；\n支持 I/O ，定时器和信号等事件；\n\nlibevent接口分析libevent 接口大概分为以下几类: \n\n环境配置和初始化\nevent_base_new\n\n\nevutil socket 函数封装\nevutil_make_socket_nonblocking\nevutil_make_listen_socket_reuseable\nset SO_REUSEADDR on Unix and does nothing on Windows\n\n\nevutil_closesocket\n\n\n事件IO处理\nevent_new\n\n\n缓冲IO\nbufferevent\n\n\n循环(Loop)\nevent_base_dispatch\n\n\n\nLibevent APIlibevent上下文创建\nevent_base *event_base_new(void)\nevent_base *event_base_new_with_config( const struct event_config *);\n配置参数\nevent_config *event_config_new(void);\nvoid event_config_free(struct event_config * cfg);\n\n\n\n\nevent_reinit\nint event_reinit(struct event_base *base); 调用 fork 之后可以正确工作\n\n\nvoid event_base_free(struct event_base *); 释放event_base内部分配的空间及其本身对象的空间，不释放事件和socket和在回调函数中申请 的空间\nevent_config_set_flag\nevent_config_avoid_method(struct event_ config *cfg, const char *method);\nevent_config_require_features\n\nevent_base_config_flag\n\nEVENT_BASE_FLAG_NOLOCK: \n\n不要为event_base 分配锁。设置这个选项可以为event_base 节省一点用于锁定和解锁的时间，但是让在多个线程中访问event_base 成为不安全的。\n\n\nEVENT_BASE_FLAG_IGNORE_ENV\n\n选择使用的后端时，不要检测EVENT_*环境变量。使用这个标志需要三思:这会让用户更难 调试你的程序与libevent 的交互。\n\n\nEVENT_BASE_FLAG_STARTUP_IOCP\n\n仅用于Windows,启用任何必需的IOCP 分发逻辑\niocp\nevent_config_set_num_cpus_hint\nevent_config_set_flag(cfg, EVENT_BASE_ FLAG_STARTUP_IOCP)\nevthread_use_windows_threads();\n\n\n\n\nEVENT_BASE_FLAG_NO_CACHE_TIME\n\n不是在事件循环每次准备执行超时回调时检测当前时间，而是在每次超时回调后进行检 测。注意:这会消耗更多的CPU 时间。\n\n\nEVENT_BASE_FLAG_EPOLL_USE_ CHANGELIST\n\nepoll下有效，防止同一个fd多次激发事件，fd如果做复制会有bug\n\n\nEVENT_BASE_FLAG_PRECISE_TIMER\n\n默认使用系统最快的记时机制，如果系统有较慢 且更精确的则采用\n\n\n\nevent_method_feature\n\nEV_FEATURE_ET &#x3D; 0x01\n边沿触发的后端\n\n\nEV_FEATURE_O1 &#x3D; 0x02,\n要求添加、删除单个事件，或者确定哪个事件激 活的操作是O(1)复杂度的后端\n\n\nEV_FEATURE_FDS &#x3D; 0x04,\n要求支持任意文件描述符，而不仅仅是套接字的 后端\n\n\nEV_FEATURE_EARLY_CLOSE &#x3D; 0x08\n检测连接关闭事件。您可以使用它来检测连接何时关闭，而不必从连接中读取所有挂起的数据。 并非所有后端都支持EV_CLOSED。允许您使用EV_CLOSED，而不需要读取所有挂起的数据。无法在所有内核版本上\n\n\n\n事件Event处理循环(loop)缓冲 buffereventlibevent http","categories":["Network"],"tags":["libevent"]},{"title":"socket 编程","url":"/2023/07/24/network/socket-%E7%BC%96%E7%A8%8B/","content":"1. socket地址结构sockaddr_inipv4 协议的地址结构是 sockaddr_in，ipv6 的地址结构是sockaddr_in6。\n#include &lt;arpa/inet.h&gt;//#include&lt;netinet/in.h&gt;struct sockaddr_in&#123;    sa_family_t     sin_family;    in_port_t       sin_port;\t    /* Port number.  */    struct in_addr  sin_addr;\t\t/* Internet address.  */    /* Pad to size of `struct sockaddr&#x27;.  */    unsigned char sin_zero[sizeof (struct sockaddr) -            __SOCKADDR_COMMON_SIZE -            sizeof (in_port_t) -            sizeof (struct in_addr)];&#125;;\n\n\nsin_family：表示地址簇，ipv4: AF_INET, ipv6: AF_INET6，\nsin_port：16位的端口号\nsin_addr：点分十进制。\n\n通用地址结构结构体是 sockaddr，方便可以接受 ipv4/ipv6 的地址结构。之所以采用 sockaddr，而不采用 void*  是因为 BSD 设计套接字的时候大约是 1982 年，那个时候的 C 语言还没有void * 的支持。\nstruct sockaddr &#123;    sa_family_t  sa_family;    char         ss_data[14];&#125;;  \n\n将 sockaddr_in/sockaddr_in6 强制转换为 sockaddr ，通过 sockaddr 的 sa_family 来分别使用的是 ipv4/ipv6。\n网络字节序列和主机字节序列转换TCP/IP 协议规定，网络传输字节按照大端字节序列方式      \n\n大端：低地址存储在高位。\n小端：低地址存低位。\n\nsin_port 转换#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);  // host to net long(32位置)uint16_t htons(uint16_t hostshort); // host to net short(16位置)uint32_t ntohl(uint32_t netlong);   // net to host longuint16_t ntohs(uint16_t netshort);\n\nsin_addr 转换与协议无关的的转换函数，即 ipv4/ipv6都可以。\n#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst);const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\nipv4 专用的转换函数\n#include &lt;arpa/inet.h&gt;int inet_aton(const char *cp, struct in_addr *inp);char *inet_ntoa(struct in_addr in);in_addr_t inet_addr(const char *cp); // 有风险，不建议使用\n2. socket 函数socket#include &lt;sys/types.h&gt;         #include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol);\n\n返回值 \n失败时返回 -1，成功是返回一个非零整数值，表示套接字描述符，sockfd。\n\n\n参数\nfamily：\nPF_INET\nPF_INET6\nPF_LOCAL\n\n\ntype：\nSOCK_STREAM : 表示的是字节流，对应 TCP；\nSOCK_DGRAM : 表示的是数据报，对应 UDP；\nSOCK_RAW : 表示的是原始套接字。\n还可和 SOCK_NOBLOCK 和SOCK_CLOEXEC 进行组合使用。\n\n\nprotocol：\n0，原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。目前一般写成 0 即可。\n\n\n\n\n状态：  \n创建 sockfd 以后，处于 CLOSED 状态。\n\n\n\nconnect#include &lt;sys/types.h&gt;         #include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n客户端调用函数。  \n\n返回值\n成功返回 0，失败返回 -1。\n客户端调用 connect 函数，会激发TCP的三次握手过程，而且仅仅在连接成功或者失败才返回。客户端是在第二个分节返回，服务端是第三个分节返回。  \n*ETIMEOUT*：若客户端没有收到 SYN 分节响应，就会返回这个错误。\n*ECONNREFUSED*：若对客户端的 SYN 分节响应的是 RST，表示服务器主机在指定的端口上没有进程与之连接，客户端一接受到 RST 就返回 ECONNREFUSED 错误。\n不可达错误。\n\n\n参数\nsockfd：是socket函数返回值。\nsockaddr：是套接字的地址结构，sockaddr_int/sockaddr_in6 强制转换而来。\naddrlen：传入的地址结构大小。\n\n\n状态：  connect 会使得当前套接字从 closed 状态转移到 SYN_SENT 状态，如成功再转移到ESTABLISHED 状态，若失败则该套接字不可用，必须关闭。\n\nbind#include &lt;sys/types.h&gt;         #include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n服务器端调用函数。\n\n参数\naddr\n可以使用通配地址 对于 IPv4 的地址来说，使用 INADDR_ANY 来完成通配地址的设置；对于 IPv6 的地址来说，使用 IN6ADDR_ANY 来完成通配地址的设置\n0, 系统随机分配\n\n\nport\n绑定端口，一般选择大于 1024 的端口。\n0, 系统随机分配\n\n\n\n\n\nstruct sockaddr_in name;name.sin_addr.s_addr = htonl (INADDR_ANY); /* IPV4 通配地址 */\nlisten#include &lt;sys/types.h&gt;         #include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);\nlisten 函数由服务器端调用。\n初始化创建的套接字，可以认为是一个”主动”套接字，其目的是之后主动发起请求（通过调用 connect 函数）。通过 listen 函数，可以将原来的”主动”套接字转换为”被动”套接字，告诉操作系统内核：”我这个套接字是用来等待用户请求的。”, 操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。\n\n返回值 \n\n失败时返回 -1，成功返回 0。\n\n\n参数\n\nsockfd\n初始化套接字\n\n\nbacklog\n内核为相应套接字排队的最大连接个数，这个参数的大小决定了可以接收的并发数目。\n\n内核为每个监听套接字维护两个队列：  (1) 半连接队列（ SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；  (2) 全连接队列（ Accept 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态； \n  在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。在 Linux 内核 2.2 之后，SYN 队列由 /proc/sys/net/ipv4/tcp_max_syn_backlog指定； backlog 变成 Accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 backlog 是 accept 队列。但是上限值是内核参数 somaxconn 的大小，也就说 ** Accept 队列长度 &#x3D; min(backlog, somaxconn)**。\n\n\n\n\n\n状态转移\n\n当来自客户的 SYN 分节到达时，TCP 在未连接队列创建一个新项，然后响应以三次握手的第二个分节，这一项一直保留在未完成连接队列中，直到三次握手的第三个分节到达或者超时。如果到达，该项就从未完成连接队列中移到已完成连接队列的队尾。当调用 accept 时，已完成连接队列的队首将作为 accept 的返回值，如果已完成连接队列是空，那么调用 accept 函数的进程会进入睡眠状态。\n\n\n\naccept#include &lt;sys/types.h&gt;          /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n调用 accept 时，已完成连接队列的队首将作为 accept 的返回值，如果已完成连接队列是空，那么调用进程进入睡眠状态。成功返回客户端的已连接套接字connfd，失败返回 -1。\naccpet 函数返回时，表示已连接套接字 connfd 和服务器端的监听套接字 listenfd 完成了三次握手。\n\nEMFILE  如果函数accept返回EMFILE，即文件描述符过多，怎么处理？\n\n先实现准备一个空闲的文件描述符 */dev/null*。遇到这种情况，先关闭这个空闲的文件描述符，就可以获得一个文件描述名额，然后再accept就可以拿到这个连接的socket文件描述符，随后立即close，就优雅的断开了与客户端的连接，最后重新打开空闲文件，以备这种情况再次出现。\n\n\n\nclose#include &lt;unistd.h&gt;int close(int fd);\n\n这个函数表示的把该套接字标记为已关闭，然后立即返回到调用进程，该套接字描述符不能再被调用进程使用。  \n\n注意事项\n由于描述符是引用计数，close 只是减少该引用计数，只有当该引用计数为 0 时才会引用终止序列。\ntcp会先将已经排队等待发送到对端的任何数据发送过去，然后再发送终止序列FIN。因此，调用 close 不是立即发送终止序列。\n\n\n\nshutdown#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how);\n\nshutdown 解决的是 close 的两个限制：\n\nclose 把描述符计数减一，仅仅在计数变为 0 时才关闭套接字。shutdown 可以不管描述符计数就激发 TCP 的正常连接终止序列。\n\nclose 终止读和写两个方向的数据传递，shutdown 是半关闭，可以只是关闭一个方向数据流。\n\n参数\n\nhow:\nSHUT_RD：关闭读\nSHUT_WR：关闭写\nSHUT_RDWR：关闭读写\n\n\n\n\n\n","categories":["Network"],"tags":["socket","tcp"]},{"title":"tcpdump 抓包","url":"/2023/07/19/network/tcpdump-%E6%8A%93%E5%8C%85/","content":"tcpdump 命令行抓包工具。\ntcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ]        [ -c count ] [ --count ] [ -C file_size ]        [ -E spi@ipaddr algo:secret,...  ]        [ -F file ] [ -G rotate_seconds ] [ -i interface ]        [ --immediate-mode ] [ -j tstamp_type ] [ -k (metadata_arg) ]        [ -m module ]        [ -M secret ] [ --number ] [ --print ]        [ -Q packet-metadata-filter ] [ -Q in|out|inout ]        [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]        [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]        [ -z postrotate-command ] [ -Z user ]        [ --time-stamp-precision=tstamp_precision ]        [ --micro ] [ --nano ]        [ expression ]\n需要 root 权限运行:\n&gt; sudo tcpdump -i anytcpdump: data link type LINUX_SLL2tcpdump: verbose output suppressed, use -v[v]... for full protocol decodelistening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes15:01:28.921972 ens33 Out IP ept.55660 &gt; 123.208.120.34.bc.googleusercontent.com.https: Flags [P.], seq 1706429942:1706429981, ack 1072465052, win 63000, length 3915:01:28.922423 ens33 In  IP 123.208.120.34.bc.googleusercontent.com.https &gt; ept.55660: Flags [.], ack 39, win 64240, length 015:01:28.971505 lo    In  IP localhost.33425 &gt; localhost.domain: 48367+ [1au] PTR? 123.208.120.34.in-addr.arpa. (56)15:01:28.971785 ens33 Out IP ept.50072 &gt; _gateway.domain: 32506+ PTR? 123.208.120.34.in-addr.arpa. (45)15:01:28.977216 ens33 In  IP _gateway.domain &gt; ept.50072: 32506 1/0/0 PTR 123.208.120.34.bc.googleusercontent.com. (98)15:01:28.977492 lo    In  IP localhost.domain &gt; localhost.33425: 48367 1/0/1 PTR 123.208.120.34.bc.googleusercontent.com. (109)15:01:28.977796 lo    In  IP localhost.45140 &gt; localhost.domain: 38317+ [1au] PTR? 168.14.168.192.in-addr.arpa. (56)15:01:28.978066 ens33 Out IP ept.50288 &gt; _gateway.domain: 21988+ PTR? 168.14.168.192.in-addr.arpa. (45)\n\n-i 表示指定哪一个网卡，any 表示任意。有哪些网卡可以用 ifconfig 来查看，在我的虚拟机上，ifconfig 输出结果如下\n-&gt; ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.14.168  netmask 255.255.255.0  broadcast 192.168.14.255        inet6 fe80::a421:b6c8:4404:333d  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:cc:cd:fb  txqueuelen 1000  (Ethernet)        RX packets 4548  bytes 5135525 (5.1 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2897  bytes 1689085 (1.6 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 5307  bytes 391240 (391.2 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 5307  bytes 391240 (391.2 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n如果只想查看 ens33 网卡经过的数据包，就可以使用 tcpdump -i ens33来指定。\n\n\n过滤主机：host 选项sudo tcpdump -i any host 10.211.55.2\n\n过滤源地址、目标地址：src、dstsudo tcpdump -i any src 10.211.55.10\n过滤端口：port 选项sudo tcpdump -i any port 80\n\n过滤指定端口范围内的流量抓取 21 到 23 区间所有端口的流量\ntcpdump portrange 21-23\n\n禁用主机与端口解析：-n 与 -nn 选项过滤协议用 ASCII 格式查看包体内容：-A 选项与 -A 对应的还有一个 -X 命令，用来同时用 HEX 和 ASCII 显示报文内容。\n限制包大小：-s 选项当包体很大，可以用 -s 选项截取部分报文内容，一般都跟 -A 一起使用。查看每个包体前 500 字节可以用下面的命令\nsudo tcpdump -i any -nn port 80 -A -s 500\n\n如果想显示包体所有内容，可以加上 -s 0\n只抓取 5 个报文： -c 选项使用 -c number 命令可以抓取 number 个报文后退出。在网络包交互非常频繁的服务器上抓包比较有用，可能运维人员只想抓取 1000 个包来分析一些网络问题，就比较有用了。\nsudo tcpdump -i any -nn port 80  -c 5\n数据报文输出到文件：-w 选项-w 选项用来把数据报文输出到文件，比如下面的命令就是把所有 80 端口的数据输出到文件\nsudo tcpdump -i any port 80 -w test.pcap\n生成的 pcap 文件就可以用 wireshark 打开进行更详细的分析了\n也可以加上 -U 强制立即写到本地磁盘，性能稍差\n显示绝对的序号：-S 选项默认情况下，tcpdump 显示的是从 0 开始的相对序号。如果想查看真正的绝对序号，可以用 -S 选项。\n没有 -S 时的输出，seq 和 ACK 都是从 0 开始\n高级技巧tcpdump 真正强大的是可以用布尔运算符and（或&amp;&amp;）、or（或||）、not（或!）来组合出任意复杂的过滤器\n抓取 ip 为 10.211.55.10 到端口 3306 的数据包\nsudo tcpdump -i any host 10.211.55.10 and dst port 3306\n\n抓取源 ip 为 10.211.55.10，目标端口除了 22 以外所有的流量\nsudo tcpdump -i any src 10.211.55.10 and not dst port 22\n复杂的分组如果要抓取：来源 ip 为 10.211.55.10 且目标端口为 3306 或 6379 的包，按照前面的描述，我们会写出下面的语句\nsudo tcpdump -i any src 10.211.55.10 and (dst port 3306 or 6379)\n如果运行一下，就会发现执行报错了，因为包含了特殊字符 ()，解决的办法是用单引号把复杂的组合条件包起来。\nsudo tcpdump -i any &#x27;src 10.211.55.10 and (dst port 3306 or 6379)&#x27;\n\n如果想显示所有的 RST 包，要如何来写 tcpdump 的语句呢？先来说答案\ntcpdump &#x27;tcp[13] &amp; 4 != 0&#x27;\n\n要弄懂这个语句，必须要清楚 TCP 首部中 offset 为 13 的字节的第 3 比特位就是 RST\ntcp[13] 表示 tcp 头部中偏移量为 13 字节, !=0 表示当前 bit 置 1，即存在此标记位，跟 4 做与运算是因为 RST 在 TCP 的标记位的位置在第 3 位(00000100)\n如果想过滤 SYN + ACK 包，那就是 SYN 和 ACK 包同时置位（00010010），写成 tcpdump 语句就是\ntcpdump &#x27;tcp[13] &amp; 18 != 0&#x27;\n参考资料深入理解TCP协议-从原理到实战\n","categories":["Network"],"tags":["tools","network"]},{"title":"如何正确使用TCP","url":"/2023/07/24/network/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8TCP/","content":"SO_REUSEADDR\nTCP 服务器能够在杀掉或崩溃后快速重启\n也适用 fork-per-connection 服务器模型。\n\nint optval = 1;setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));\n忽略 SIGPIPE程序向对方已经关闭的管道，写数据，会收到 SIGPIPE 信号。write 系统调用返回 -1收到 errono EPIPE。 SIGPIPE 信号默认行为终止进程。我们应该忽略 SIGPIPE 信号。\nif (signal(SIGPIPE, SIG_IGN) == SIG_ERR) &#123;    return 1;&#125;\n\n\nTCP_NODELAYNagle 算法避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个 TCP 连接而言，只允许一个未被 ACK的包存在于网络。\nNagle 算法规则:\n\n如果包长度达到 MSS，则允许发送\n如果包含 FIN，则允许发送\n如果设置了 TCP_NODELAY，则允许发送\n未设置 TCP_CORK 选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送\n上述条件都未满足，但发生了超时（一般为200ms），则立即发送。\n\n通过设置 TCP_NODELAY 禁用 nagle 算法。\nint flag = 1;setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (char*)&amp;flag, sizeof(int));\n\n正确关闭 TCP 连接如果协议栈接受缓存区中有数据，程序还没有读，直接调用 close 函数，TCP 协议栈会发送 RST 包，强行断开连接，如果协议栈发送缓存区还有有数据，则对方没能收到，造成数据丢失。 对于无格式的协议正确的做法是：\n发送方: send() + shutdown(WR) + read()-&gt;0 + close()接收方: read()-&gt;0 + 没有数据发送 + close()\n\n如果遇到恶意或者是有 bug 的 client，一直不 close，发送方一直阻塞在 read , 建议加一个超时机制退出程序，这是为了程序安全 security，不是为了数据安全 safety 完整性 Integrity。\n依赖 shutdown write 会发送 FIN，end of file，更好的办法是设计协议，把数据长度包含进来，接收方可以主动判断数据是否收全。\nSocket 选项之 SO_LINGER","categories":["Network"],"tags":["tcp"]},{"title":"深入了解FTP协议：原理、命令与数据连接","url":"/2025/05/07/network/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3FTP%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5/","content":"深入了解FTP协议：原理、命令与数据连接什么是FTP协议？FTP（File Transfer Protocol） 是最常用的网络文件传输协议之一，允许计算机之间通过网络传输文件。它是一个基于客户端-服务器模型的协议，通过 TCP 连接进行通信，通常运行在端口 21。FTP主要支持两种模式：主动模式和被动模式。\n在本文中，我们将深入探讨 FTP 协议的工作原理、常用命令、数据连接的处理方式以及两种模式的区别。\n\n\n\n1. FTP协议基本工作原理FTP 协议的工作基于两条连接：\n\n控制连接：用于发送命令和接收响应，通常使用 TCP 端口 21。\n数据连接：用于传输实际的文件数据，连接可以使用不同的端口，具体取决于客户端和服务器的设置。\n\n控制连接控制连接是客户端与服务器之间的长期连接，用于发送和接收命令、状态消息以及FTP协议的控制信息（如认证、文件操作等）。它通常由 FTP 客户端和服务器使用端口 21 建立。\n数据连接数据连接用于传输实际的文件数据或目录列表。在 FTP 协议中，数据连接的建立方式取决于使用的模式：主动模式和被动模式。\n\n2. FTP协议常用命令FTP 协议通过一系列标准化的命令来与服务器进行通信，以下是一些常用的命令：\n2.1 身份验证命令\nUSER &lt;用户名&gt;\n\n发送用户名给 FTP 服务器，开始身份验证过程。\n示例：USER anonymous\\r\\n\n\n\nPASS &lt;密码&gt;\n\n发送密码给 FTP 服务器，完成用户身份验证。\n示例：PASS guest\\r\\n\n\n\nACCT &lt;账户&gt;\n\n在某些 FTP 服务器上，需要提供账户名。通常不常用。\n示例：ACCT guest\\r\\n\n\n\nQUIT\n\n结束 FTP 会话，关闭控制连接。\n示例：QUIT\\r\\n\n\n\n\n2.2 文件操作命令\nSTOR &lt;文件路径&gt;\n\n将文件从客户端上传到服务器。\n示例：STOR myfile.txt\\r\\n\n\n\nRETR &lt;文件路径&gt;\n\n从服务器下载文件到客户端。\n示例：RETR myfile.txt\\r\\n\n\n\nDELE &lt;文件路径&gt;\n\n删除服务器上的文件。\n示例：DELE myfile.txt\\r\\n\n\n\nRNFR &lt;旧文件路径&gt;\n\n指定要重命名的文件。\n示例：RNFR oldfile.txt\\r\\n\n\n\nRNTO &lt;新文件路径&gt;\n\n指定文件的新名称（用于重命名操作）。\n示例：RNTO newfile.txt\\r\\n\n\n\nAPPE &lt;文件路径&gt;\n\n将数据追加到服务器上的文件末尾，而不是覆盖文件。\n示例：APPE myfile.txt\\r\\n\n\n\n\n2.3 目录操作命令\nPWD\n\n显示当前工作目录的路径。\n示例：PWD\\r\\n\n\n\nCWD &lt;目录路径&gt;\n\n改变服务器上的当前工作目录。\n示例：CWD /home/user\\r\\n\n\n\nLIST [&lt;路径&gt;]\n\n列出目录内容。如果提供路径参数，则列出指定路径的内容。\n示例：LIST\\r\\nLIST /home/user\\r\\n\n\n\nNLST [&lt;路径&gt;]\n\n列出目录中的文件名，通常以简单的文件名格式返回（比LIST返回的更简洁）。\n示例：NLST\\r\\nNLST /home/user\\r\\n\n\n\nMKD &lt;目录路径&gt;\n\n在服务器上创建一个新目录。\n示例：MKD newdir\\r\\n\n\n\nRMD &lt;目录路径&gt;\n\n删除服务器上的空目录。\n示例：RMD olddir\\r\\n\n\n\n\n2.4 传输模式和文件类型命令\nTYPE &lt;类型&gt;\n\n指定文件传输类型（如 ASCII 或二进制）。\n常用值：\nA：ASCII模式（文本文件传输）。\nI：二进制模式（图片、压缩文件等传输）。\n\n\n示例：TYPE I\\r\\nTYPE A\\r\\n\n\n\nMODE &lt;模式&gt;\n\n设置传输模式。S为流模式，B为块模式，C为压缩模式。\n示例：MODE S\\r\\n\n\n\nSTRU &lt;结构&gt;\n\n指定文件传输的结构。通常使用的值是：\nF：文件结构。\nR：记录结构。\nP：页面结构。\n\n\n示例：STRU F\\r\\n\n\n\n\n2.5 连接控制命令\nPORT &lt;IP1&gt;,&lt;IP2&gt;,&lt;IP3&gt;,&lt;IP4&gt;,&lt;P1&gt;,&lt;P2&gt;\n\n指定客户端的 IP 地址和端口，用于主动模式下的数据连接。\n示例：PORT 192,168,1,100,12,34\\r\\n\n\n\nPASV\n\n请求服务器进入被动模式，并返回服务器监听的端口和 IP 地址。\n示例：PASV\\r\\n\n\n\nREIN\n\n重新初始化连接，终止当前会话。\n示例：REIN\\r\\n\n\n\n\n2.6 其他控制命令\nSYST\n\n请求服务器返回其操作系统的类型。\n示例：SYST\\r\\n\n\n\nSTAT [&lt;路径&gt;]\n\n请求服务器返回当前状态信息。\n示例：STAT\\r\\nSTAT /home/user\\r\\n\n\n\nHELP [&lt;命令&gt;]\n\n获取命令的帮助信息。如果没有指定命令，则返回所有支持的命令列表。\n示例：HELP\\r\\nHELP STOR\\r\\n\n\n\nNOOP\n\n发送空命令，用于保持连接活跃，服务器通常会回应 200。\n示例：NOOP\\r\\n\n\n\n\n\n3. 主动模式与被动模式FTP 协议有两种模式来建立数据连接：主动模式（Active Mode）和被动模式（Passive Mode）。这两种模式主要的区别在于谁发起数据连接。\n3.1 主动模式（Active Mode）在主动模式下，客户端向服务器发送 PORT 命令，指定客户端的 IP 地址和端口号，服务器通过该端口与客户端建立数据连接。具体过程如下：\n\n客户端向服务器发送 PORT 命令，提供客户端的 IP 地址和端口号。\n服务器收到命令后，使用指定的 IP 和端口与客户端建立数据连接。\n客户端开始发送或接收数据。\n\n端口计算：P = P1 * 256 + P2，例如 PORT 192,168,1,100,12,34 表示客户端IP为 192.168.1.100，端口为 12*256 + 34 = 3146。\n3.2 被动模式（Passive Mode）在被动模式下，客户端向服务器发送PASV命令，请求服务器提供一个可供数据连接的端口。服务器响应并提供自己的IP 地址和端口，客户端通过这个端口与服务器建立数据连接。具体过程如下：\n\n客户端向服务器发送PASV命令。\n服务器返回一个响应，包含服务器的IP地址和端口号。\n客户端通过返回的 IP 地址和端口与服务器建立数据连接。\n\n端口计算：P = P1 * 256 + P2，例如 PASV 返回 227 Entering Passive Mode (192,168,1,100,12,34)，表示服务器IP为 192.168.1.100，端口为 12*256 + 34 = 3146。\n\n4. 总结FTP 协议是一种功能强大的文件传输协议，支持多种命令和文件操作方式。无论是主动模式还是被动模式，数据连接的计算方法和控制连接的管理都是成功传输文件的关键。了解 FTP 协议的常用命令、模式以及如何计算端口和IP，对于开发和调试 FTP 客户端和服务器都有着重要的作用。\n\n参考文献\nRFC 959 - File Transfer Protocol (FTP)\nFTP协议详细解析\n\n","categories":["Network"],"tags":["FTP"]},{"title":"深入理解TUN与TAP：虚拟网络设备的原理与应用","url":"/2025/05/09/network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TUN%E4%B8%8ETAP%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","content":"在构建虚拟网络或实现VPN时，TUN和TAP是两个常被提及的虚拟网络设备。它们看似相似，却在网络协议栈的不同层级发挥作用。本文将深入解析它们的工作原理、应用场景及配置方法。\n\n\n\n1. 什么是TUN和TAP？TUN（Network TUNnel）\n层级：工作于网络层（OSI第三层）\n数据单元：处理IP数据包\n特性：模拟点对点设备，无 MAC 地址\n典型用途：VPN（如OpenVPN）、IP隧道\n\nTAP（Network TAP）\n层级：工作于数据链路层（OSI第二层）\n数据单元：处理以太网帧\n特性：模拟以太网接口，拥有 MAC 地址\n典型用途：虚拟机网络（如QEMU/KVM）、二层 VPN\n\n\n2. 核心区别对比\n\n\n特性\nTUN\nTAP\n\n\n\n工作层级\n第三层（IP层）\n第二层（数据链路层）\n\n\n处理内容\n仅IP数据包（如 TCP/UDP）\n完整以太网帧（含 MAC地址、ARP 等）\n\n\n设备类型\n点对点设备（如tun0）\n以太网设备（如tap0）\n\n\n广播支持\n不支持\n支持（可处理 ARP、DHCP 广播）\n\n\n典型场景\nVPN 隧道、路由控制\n虚拟机网卡、网桥、二层网络嗅探\n\n\n\n3. 工作流程解析TUN设备的工作流程\n发送数据应用程序生成 IP 包 → 内核路由到 TUN 设备 → 用户程序从 TUN 读取 → 加密后通过物理网卡发送\n接收数据物理网卡接收加密数据 → 用户程序解密 → 写回 TUN 设备 → 内核处理 IP 包\n\nTAP设备的工作流程\n发送数据虚拟机生成以太网帧 → 内核转发到 TAP 设备 → 用户程序读取帧 → 通过物理网卡发送\n接收数据物理网卡接收帧 → 用户程序写回 TAP 设备 → 内核视为本地流量 → 传递给虚拟机\n\n\n4. 实际应用场景TUN的典型应用\nVPN隧道搭建OpenVPN 默认使用 TUN 模式，将用户流量封装为 IP 包，通过 SSL/TLS 加密传输。\n跨网络路由控制自定义路由规则，实现流量分流（如国内直连&#x2F;境外走代理）。\n网络诊断工具抓取特定 IP 流量进行分析，无需处理底层以太网帧。\n\nTAP的典型应用\n虚拟机网络连接QEMU/KVM 通过TAP设备将虚拟机接入宿主机网桥，实现 NAT 或桥接模式。\n二层VPN（L2TP）构建虚拟局域网，使远程设备像处于同一物理网络。\n网络协议开发测试 ARP、STP 等二层协议，或实现自定义以太网帧转发逻辑。\n\n\n5. Linux下的配置示例创建TUN设备# 创建TUN设备并配置IPsudo ip tuntap add mode tun dev tun0sudo ip addr add 10.8.0.1/24 dev tun0sudo ip link set tun0 up# 验证ip addr show tun0\n创建TAP设备# 创建TAP设备并加入网桥sudo ip tuntap add mode tap dev tap0sudo ip link set tap0 master br0sudo ip link set tap0 up# 验证brctl show br0\n\n6. 实战：用socat测试TUN设备通信实验目标通过socat工具在两个终端之间通过TUN设备发送ICMP（ping）数据包。\n步骤1：创建并配置TUN设备# 终端A：创建tun0sudo ip tuntap add mode tun dev tun0sudo ip addr add 10.8.0.1/24 dev tun0sudo ip link set tun0 up# 终端B：创建tun1sudo ip tuntap add mode tun dev tun1sudo ip addr add 10.8.0.2/24 dev tun1sudo ip link set tun1 up\n步骤2：使用socat建立隧道# 终端A：将tun0的数据转发到UDP端口5000sudo socat TUN:10.8.0.1/24,tun-name=tun0,iff-up UDP4:192.168.1.100:5000# 终端B：将tun1的数据转发到UDP端口5000sudo socat TUN:10.8.0.2/24,tun-name=tun1,iff-up UDP4:192.168.1.200:5000\n步骤3：测试通信# 终端A ping终端Bping 10.8.0.2# 终端B抓包验证sudo tcpdump -i tun1 icmp\n实验原理\nsocat将TUN设备与UDP套接字绑定，实现IP包的双向转发\n内核将ping请求路由到tun0\nsocat读取tun0的IP包，通过UDP发送到对端\n对端socat将UDP数据写回tun1，完成通信闭环\n\n7. 编程交互示例#include &lt;fcntl.h&gt;#include &lt;linux/if_tun.h&gt;// 创建TUN/TAP设备int tun_alloc(char *dev, int flags) &#123;    struct ifreq ifr;    int fd = open(&quot;/dev/net/tun&quot;, O_RDWR);    memset(&amp;ifr, 0, sizeof(ifr));    ifr.ifr_flags = flags;  // IFF_TUN或IFF_TAP    strncpy(ifr.ifr_name, dev, IFNAMSIZ);    ioctl(fd, TUNSETIFF, &amp;ifr);    return fd;&#125;// 使用示例：创建TAP设备int fd = tun_alloc(&quot;tap0&quot;, IFF_TAP | IFF_NO_PI);\n\n8. 如何选择TUN&#x2F;TAP？\n选择TUN当：\n  ✅ 仅需处理IP流量\n  ✅ 避免二层协议开销（如ARP广播）\n  ✅ 构建VPN或IP隧道\n\n选择TAP当：\n  ✅ 需要MAC地址和以太网功能\n  ✅ 连接虚拟机或容器网络\n  ✅ 处理非IP协议（如IPX）\n\n\n9. 注意事项\n权限问题：操作 /dev/net/tun 需 root 权限或 CAP_NET_ADMIN 能力\n性能优化：使用零拷贝技术（如sendfile）提升吞吐量\n安全风险：暴露 TAP 设备可能让攻击者接入二层网络\n\n","categories":["网络虚拟化"],"tags":["TUN","TAP","VPN","虚拟机"]},{"title":"网络工具 telnet、 nc、 netstat、ss","url":"/2024/03/20/network/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%20telnet%E3%80%81-nc%E3%80%81-netstat/","content":"telnet检查端口是否打开telnet [domainname or ip] [port]telnet 220.181.57.216 80\n\nnetcat当服务器nc -l [port]nc -l 9090\n连接服务器nc [host or ip] [port]nc 10.211.55.5 9090\n\n查看远程端口是否打开nc -zv [host or ip] [port]\n\n其中 -z 参数表示不发送任何数据包，tcp 三次握手完后自动退出进程。有了 -v 参数则会输出更多详细信息（verbose）\nnetstatnetstat 用来显示套接字的状态。\n列出所有套接字netstat -a\n\n-a 命令可以输出所有的套接字，包括监听的和未监听的套接字。 示例输出：\n\n➜  ~ netstat -aActive Internet connections (including servers)Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)tcp4       0      0  yanghao.51628          43.134.115.68.https    ESTABLISHEDtcp4       0      0  localhost.hydap        localhost.51627        ESTABLISHEDtcp4       0      0  localhost.51627        localhost.hydap        ESTABLISHEDtcp4       0      0  localhost.ddi-tcp-2    localhost.51626        ESTABLISHEDtcp4       0      0  localhost.51626        localhost.ddi-tcp-2    ESTABLISHED\n\n只列出 TCP 连接netstat -at\n\n只列出 UDP 连接netstat -au\n只列出处于监听状态的连接netstat -l\n\n-l 选项用来指定处于 LISTEN 状态的连接\n\n禁用端口 和 IP 映射netstat -ltn\n\n常用端口都被映射为了名字，比如 22 端口输出显示为 ssh，8080 端口被映射为 webcache。大部分情况下，我们并不想 netstat 帮我们做这样的事情，可以加上 -n 禁用\n\n显示进程netstat -ltnp\n\n-p 命令可以显示连接归属的进程信息，在查看端口被哪个进程占用时非常有用.\n\n显示所有的网卡信息netstat -i\n\nss","categories":["Network"],"tags":["tools","network"]},{"title":"Qt 之 焦点处理","url":"/2023/02/15/qt/Qt-%E4%B9%8B-%E7%84%A6%E7%82%B9%E5%A4%84%E7%90%86/","content":"焦点事件当焦点从一个 widget 移动到另一个 widget 时，会触发 QFocusEvent 事件，这个事件会被发送给原焦点窗口和当前焦点窗口，原焦点窗口执行 focusOutEvent() ，新焦点窗口执行 focusInEvent()。 相关函数如下：\nvoid focusInEvent(QFocusEvent *event) override;void focusOutEvent(QFocusEvent *event) override;\n焦点策略只有可获取焦点的窗口，才有机会成为焦点窗口。比如QWidget 默认策略是 Qt::NoFocus 所以 QWidget 默认不获取焦点。Qt提供了如下接口：\nvoid QWidget::setFocusPolicy(Qt::FocusPolicy policy);\n\nenum Qt::FocusPolicy\n\n\nConstant\nValue\nDescription\n\n\n\nQt::TabFocus\n0x1\nthe widget accepts focus by tabbing.\n\n\nQt::ClickFocus\n0x2\nthe widget accepts focus by clicking.\n\n\nQt::StrongFocus\nTabFocus &#124; ClickFocus &#124; 0x8\nthe widget accepts focus by both tabbing and clicking. On macOS this will also be indicate that the widget accepts tab focus when in ‘Text&#x2F;List focus mode’.\n\n\nQt::WheelFocus\nStrongFocus &#124; 0x4\nlike Qt::StrongFocus plus the widget accepts focus by using the mouse wheel.\n\n\nQt::NoFocus\n0\nthe widget does not accept focus.\n\n\n焦点原因Qt::FocusReason\n\n\nConstant\nValue\nDescription\n\n\n\nQt::MouseFocusReason\n0\nA mouse action occurred.\n\n\nQt::TabFocusReason\n1\nThe Tab key was pressed.\n\n\nQt::BacktabFocusReason\n2\nA Backtab occurred. The input for this may include the Shift or Control keys; e.g. Shift+Tab.\n\n\nQt::ActiveWindowFocusReason\n3\nThe window system made this window either active or inactive.\n\n\nQt::PopupFocusReason\n4\nThe application opened&#x2F;closed a pop-up that grabbed&#x2F;released the keyboard focus.\n\n\nQt::ShortcutFocusReason\n5\nThe user typed a label’s buddy shortcut\n\n\nQt::MenuBarFocusReason\n6\nThe menu bar took focus.\n\n\nQt::OtherFocusReason\n7\nAnother reason, usually application-specific.\n\n\n焦点信号QApplication 的信号。\nvoid focusChanged(QWidget *old, QWidget *now);\n焦点次序相关接口如下： \n// 返回此部件焦点链中的下一个部件QWidget* QWidget::nextInFocusChain() const; // 返回此部件焦点链中的前一个部件QWidget* QWidget::previousInFocusChain() const;// 将焦点顺序中的部件 second 放置在部件 first 之后static void setTabOrder(QWidget *, QWidget *);\n\n通过按 Tab 或者 Shift+Tab，可以实现焦点在各个窗口之间循环移动。\n\n点击 Tab 键，焦点向后查找，直至找到第一个 FocusPolicy 大于等于 TabFocus 的窗口，并设置该窗口为焦点窗口;\n\n点击 Shift+Tab ，焦点向前查找，直至找到第一个 FocusPolicy  大于等于 TabFocus 的窗口，并设置该窗口为焦点窗口;\n\n\n默认情况下, 先加入的 QWidget 焦点顺序越靠前。可以通过 setTabOrder 调整顺序.\n比如，若默认的焦点链顺序为 a-b-c-d ，则：\nsetTabOrder(d,c); //改变后焦点链的顺序为 a-b-d-csetTabOrder(b,a); //改变后焦点链的顺序为 b-a-d-c\n\n焦点切换相关接口如下： \n// 等同于focusNextPrevChild(true)bool QWidget::focusNextChild();// 等同于focusNextPrevChild(false)bool QWidget::focusPreviousChild();// next==true：设置焦点链中下个`FocusPolicy`为`TabFocus`的窗口为焦点窗口// next==false：设置焦点链中前一个`FocusPolicy`为`TabFocus`的窗口为焦点窗口bool QWidget::focusNextPrevChild(bool next);// 设置当前窗口为焦点窗口void QWidget::setFocus(Qt::FocusReason reason);// 取消焦点窗口void QWidget::clearFocus();\n\n焦点代理代为接收焦点事件。比如，Widget A 是 Widget B 的焦点代理，则当 B 获得焦点时，实际获得并处理焦点的是 A。相关接口如下： \n//返回该窗口的焦点代理QWidget* QWidget::focusProxy() const; //设置该窗口的焦点代理为wvoid QWidget::setFocusProxy(QWidget* w);","categories":["Qt"],"tags":["焦点","Qt"]},{"title":"Application-Layer Protocol Negotiation","url":"/2023/12/11/network/TLS/ALPN/","content":"IntroductionALPN(Application-Layer Protocol Negotiation)应用层协议协商, 当单个服务器端口号（例如端口 443）上支持多个应用程序协议时，客户端和服务器需要协商用于每个连接的应用程序协议。希望在不增加客户端和服务器之间的网络往返次数的情况下完成此协商，因为每次往返都会降低最终用户的体验。\nALPN 作为 TSL的扩展，客户端会将支持的应用程序协议列表作为 TLS ClientHello 消息的一部分发送给服务器，服务器选择一个协议，并将所选协议作为 TLS ServerHello 消息的一部分发送给客户端。因此，可以在 TLS 握手中完成应用协议协商，而无需添加网络往返，并且允许服务器根据需要，将不同的证书与每个应用协议相关联。\n\n通过 OpenSSL 命令行工具，快速查看 HTTP/2 服务是否支持 ALPN 扩展：\nopenssl s_client -alpn h2 -servername ipinfo.io -connect ipinfo.io:443 &lt; /dev/null | grep ALPN \n\n提示 unknown option -alpn:  OpenSSL 版本太低, OpenSSL 1.0.2 才开始支持 ALPN 需要升级高版本\n结果包含 ALPN protocol: h2，说明服务端支持 ALPN\n结果包含 No ALPN negotiated，说明服务端不支持 ALPN\n\nApplication-Layer Protocol NegotiationThe Application-Layer Protocol Negotiation Extension定义新的扩展类型（application_layer_protocol_negotiation（16），并且可以由客户端包括在其 ClientHello 消息中。\nenum &#123;    application_layer_protocol_negotiation(16), (65535)&#125; ExtensionType;\n\n（application_layer_protocol_negotiation（16）扩展的 extension_data 字段应包含ProtocolNameList 值。\nopaque ProtocolName&lt;1..2^8-1&gt;;struct &#123;    ProtocolName protocol_name_list&lt;2..2^16-1&gt;&#125; ProtocolNameList;\n\nProtocolNameList 按优先级从高到低包含客户端发布的协议列表。 协议是由 IANA 注册的不透明非空字节串命名的。不能包含空字符串，并且不能截断字节字符串。\n接收到包含 application_layer_protocol_negotiation 扩展名的 ClientHello 的服务器可以向客户端返回合适的协议选择作为响应。服务器将忽略它无法识别的任何协议名称。一个新的 ServerHello 扩展类型(application_layer_protocol_negotiation(16)) 可以在 ServerHello 消息扩展中返回给客户端。(application_layer_protocol_negotiation(16)) 扩展名的 extension_data 字段的结构与上述针对客户端 extension_data 的描述相同，只是 ProtocolNameList 必须包含一个 ProtocolName。\nClient                                              ServerClientHello                     --------&gt;       ServerHello  (ALPN extension &amp;                               (ALPN extension &amp;   list of protocols)                              selected protocol)                                                Certificate*                                                ServerKeyExchange*                                                CertificateRequest*                                &lt;--------       ServerHelloDoneCertificate*ClientKeyExchangeCertificateVerify*[ChangeCipherSpec]Finished                        --------&gt;                                                [ChangeCipherSpec]                                &lt;--------       FinishedApplication Data                &lt;-------&gt;       Application Data\n\nProtocol Selection期望服务器将具有优先级支持的协议列表，并且仅在客户端支持的情况下才选择协议。在这种情况下，服务器应该选择它所支持的，并且也是由客户端发布的最优先的协议。如果服务器不支持客户端传过来的协议，则服务器应以 &quot;no_application_protocol&quot; alert 错误回应。\nenum &#123;    no_application_protocol(120),    (255)&#125; AlertDescription;\n\nWireshark 抓包在 TLS1.3 中:\n\nClientHello消息:\n\nServerHello消息:\n\n\n参考资料\nApplication-Layer Protocol Negotiation Extension\n\n","tags":["SSL/TLS"]},{"title":"TLS 1.2 与 TLS 1.3 握手流程深度解析：安全与性能的演进","url":"/2025/04/08/network/TLS/TLS-1-2-and-TLS-1-3-Handshake/","content":"TLS 1.2 与 TLS 1.3 握手流程深度解析：安全与性能的演进引言TLS（传输层安全协议）是互联网加密通信的基石。从 TLS 1.2 到 TLS 1.3，协议在安全性和性能上实现了质的飞跃。本文将深入对比两者的握手流程，解析其设计差异，并探讨为何 TLS 1.3 成为现代网络通信的首选。\n\n\nTLS 1.2 握手流程（传统 2-RTT 模型）1. ClientHello\n客户端发送支持的协议版本（如 TLS 1.2）\n随机数（ClientRandom）\n密码套件列表（如 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256）\n其他扩展：SNI（服务器名称指示）等。\n\n2. ServerHello\n服务器选择协议版本\n随机数（ServerRandom）：32 字节的随机值。\n选定的密码套件\n\n3. Certificate\n服务器发送证书链，用于身份验证。\n\n4. ServerKeyExchange\n传递临时密钥参数（如 ECDHE 公钥）。（仅限非 RSA 密钥交换）\n\n5. ServerHelloDone\n表示服务器消息结束。\n\n6. ClientKeyExchange\n客户端生成预主密钥（Pre-Master Secret），用服务器公钥加密后发送。（若使用 RSA 密钥交换）\n\n7. ChangeCipherSpec（客户端）\n通知服务器后续消息将加密。\n\n8. Finished（客户端）\n发送加密的 HMAC 验证握手完整性。\n\n9. ChangeCipherSpec（服务器）\n服务器切换至加密模式。\n\n10. Finished（服务器）\n服务器发送加密的 HMAC 验证。\n\n总耗时：至少 2 次往返（2-RTT）。\n\nTLS 1.3 握手流程（1-RTT）1. ClientHello\n客户端发起握手，发送以下内容：\n\n协议版本：声明支持 TLS 1.3。\n随机数（ClientRandom）：32 字节的随机值。\n密码套件列表：支持的加密算法组合（如 TLS_AES_128_GCM_SHA256）。\n密钥共享扩展（key_share）：包含客户端生成的临时公钥（如 ECDHE 的椭圆曲线公钥）。\n其他扩展：如支持的签名算法、SNI（服务器名称指示）等。\n\n\n密钥生成：\n\n此时尚未生成密钥，消息以明文发送。\n\n\n加密数据：\n\n无加密，但包含后续密钥交换所需参数。\n\n\n\n2. ServerHello\n服务器响应，内容包括：\n\n协议版本：确认使用 TLS 1.3。\n随机数（ServerRandom）：32 字节的随机值。\n选定的密码套件：从客户端列表中选择的套件（如 TLS_AES_128_GCM_SHA256）。\n密钥共享扩展（key_share）：服务器的临时公钥（如 ECDHE 的椭圆曲线公钥）。\n\n\n密钥生成：\n\n客户端和服务器通过 ECDHE（或其他密钥交换算法）计算共享密钥：\n共享密钥（Shared Secret） &#x3D; ECDH(client_priv, server_pub) = ECDH(server_priv, client_pub)。\n结合 Client Random 和 Server Random，通过 HKDF 生成：\n预主密钥（Pre-Master Secret） → 主密钥（Master Secret）。\n主密钥再派生出 握手流量密钥（Handshake Traffic Keys）。\n\n\n\n\n\n\n加密数据：\n\n无加密，ServerHello 仍为明文。\n\n\n\n3. 服务器端后续消息（同一轮次发送）服务器发送以下消息，合并为单个 TLS 记录：\n\nEncryptedExtensions：可选扩展（如 ALPN 应用层协议协商, SNI 确认等）。\nCertificate：服务器证书链，用于身份验证。\nCertificateVerify：用服务器私钥对握手消息签名，证明拥有证书。\nFinished：加密的验证数据（HMAC），确保握手完整性。\n\n4. 客户端验证与响应客户端：\n\n验证服务器证书的有效性。\n检查证书颁发机构\\有效期、域名匹配\n递归验证证书链至可信根CA（浏览器&#x2F;OS内置）\n检查吊销状态（OCSP或CRL）\n\n\n检查 CertificateVerify 签名是否正确。\n发送 Finished 消息：加密的 HMAC，供服务器验证握手完整性。\n\n总耗时：1 次往返（1-RTT）。\n\n0-RTT 快速握手（提前发送数据）前提：客户端与服务器已通过前一次握手生成预共享密钥（PSK）。\n流程\n\nClientHello：包含 pre_shared_key 扩展（PSK 标识）和 early_data 扩展。\nServerHello：服务器接受 PSK，返回 pre_shared_key 确认。\n客户端立即发送 0-RTT 应用数据：使用 PSK 加密，无需等待握手完成。\n后续步骤与完整握手相同（服务器发送 Finished，客户端响应）。\n\n注意：0-RTT 数据可能受重放攻击，需确保应用层操作是幂等的（如 GET 请求）。\n\n关键差异对比\n\n\n特性\nTLS 1.2\nTLS 1.3\n\n\n\n握手耗时\n2-RTT\n1-RTT（或 0-RTT）\n\n\n密钥交换算法\n支持 RSA（非前向安全）\n仅 ECDHE&#x2F;DHE（强制前向安全）\n\n\n握手消息合并\n多步骤（如 ServerKeyExchange）\n合并至 ServerHello 后\n\n\n0-RTT 支持\n不支持\n支持（基于 PSK）\n\n\n不安全算法\n允许 SHA-1、RC4 等\n完全移除\n\n\n会话恢复机制\nSession ID 或 Session Ticket\n优先使用 PSK 和 Session Ticket\n\n\n\nTLS 1.3 的核心改进1. 前向安全（Forward Secrecy）\n强制使用临时密钥（Ephemeral Key），即使长期私钥泄露，历史会话也无法解密。\n\n2. 0-RTT 快速握手\n基于预共享密钥（PSK），客户端首次请求即可携带加密数据（如 HTTP GET）。\n注意：0-RTT 数据需防重放攻击，仅限幂等操作。\n\n3. 算法精简\n移除 RSA 密钥传输、DES、RC4、SHA-1 等弱算法，默认使用 AEAD 加密（如 AES-GCM）。\n\n4. 握手消息加密\n除 ClientHello/ServerHello 外，其余消息（如证书）均加密传输，增强隐私性。\n\nTLS 1.2 与 TLS 1.3 握手流程图TLS 1.2 流程图（简化）sequenceDiagram    Client-&gt;&gt;Server: ClientHello    Server-&gt;&gt;Client: ServerHello + Certificate + ServerKeyExchange + ServerHelloDone    Client-&gt;&gt;Server: ClientKeyExchange + ChangeCipherSpec + Finished    Server-&gt;&gt;Client: ChangeCipherSpec + Finished\n\nTLS 1.3 流程图（1-RTT）sequenceDiagram    Client-&gt;&gt;Server: ClientHello (key_share)    Server-&gt;&gt;Client: ServerHello (key_share) + EncryptedExtensions + Certificate + CertificateVerify + Finished    Client-&gt;&gt;Server: Finished\n\n\n性能与安全对比\n\n\n场景\nTLS 1.2\nTLS 1.3\n\n\n\n首次连接延迟\n高（2-RTT）\n低（1-RTT）\n\n\n重连延迟（会话恢复）\n中（1-RTT）\n极低（0-RTT）\n\n\n抗量子计算攻击\n弱\n更强（支持 X25519 等算法）\n\n\n隐私保护\n部分握手消息明文传输\n握手消息全加密\n\n\n\n表格说明\n首次连接延迟：\n\nTLS 1.3 通过合并握手步骤减少往返次数，显著降低延迟。\nTLS 1.2 需多次交互协商密钥，耗时更长。\n\n\n重连延迟：\n\nTLS 1.3 支持 0-RTT 快速恢复，客户端可立即发送加密数据。\nTLS 1.2 需重新协商密钥，仍需 1-RTT。\n\n\n抗量子计算攻击：\n\nTLS 1.3 默认使用 X25519 等强临时密钥算法，安全性更高。\nTLS 1.2 依赖传统算法（如 RSA），易受量子计算威胁。\n\n\n隐私保护：\n\nTLS 1.3 加密所有握手消息（除 ClientHello/ServerHello），防止中间人窃听敏感信息（如证书）。\nTLS 1.2 的证书、ServerKeyExchange 等消息明文传输。\n\n\n\n\n\n注：TLS 1.3 的 0-RTT 模式需注意重放攻击风险，建议仅用于幂等操作（如 HTTP GET）。\n\n\n何时选择 TLS 1.3？\n推荐场景：\n\n高延迟网络（如移动端）。\n需要前向安全的敏感数据传输。\n高频短连接（如 API 请求）。\n\n\n注意事项：\n\n部分旧设备可能不支持 TLS 1.3。\n0-RTT 需应用层防御重放攻击。\n\n\n\n\n总结TLS 1.3 通过精简握手流程、强制前向安全和算法升级，显著提升了安全性与性能。尽管 TLS 1.2仍在某些旧系统中使用，但 TLS 1.3 已成为现代 Web 服务、移动应用和 IoT 通信的首选协议。升级至 TLS 1.3 不仅是技术趋势，更是安全实践的必然要求。\n参考内容\nThe Transport Layer Security (TLS) Protocol Version 1.2\nThe Transport Layer Security (TLS) Protocol Version 1.3\ntls13_key_schedule\n\n","tags":["SSL/TLS"]},{"title":"TLS False Start","url":"/2023/12/11/network/TLS/TLS-False-Start/","content":"什么是TLS False Start？在 TLS 协商第二阶段，浏览器发送 ChangeCipherSpec 和 Finished 后，立即发送加密的应用层数据，而无需等待服务器端的确认。\n如何启用TLS False Start？\n需要支持 NPN/ALPN\n服务器端配置支持前向安全(Forward Secrecy)\n\n","tags":["SSL/TLS"]},{"title":"Qt QML 核心概念基础","url":"/2024/02/26/qt/Qt-QML-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/","content":"Qt QML 简介QML 是什么？\nQML 是声明式编程语言\nQML 模块 类型库\n内置了 javascript 运行时环境, 提供逻辑处理： 界面逻辑，业务逻辑\n\nQt Quick 是什么？Qt Quick 是类型库，提供了可视化 UI 组件，软件开发框架，用于构建用户界面\n\nQML 应用程序使用 qmlscene 运行 QML 程序C++ 应用程序使用 QML使用 QML Engine只使用了 Qt Quick 框架，没有使用Qt Widgets\n#include &lt;QQmlApplicationEngine&gt;QQmlApplicationEngine engine;engine.load(QUrl(QStringLiteral(&quot;qrc:/main.qml&quot;)));if (engine.rootObjects().isEmpty())    return -1;\n使用 QML View只使用了 Qt Quick 框架，没有使用 QWidget, QQuickView 不支持 window 作为根节点\n#include &lt;QQuickView&gt;const QUrl url(QStringLiteral(&quot;qrc:/main.qml&quot;));QQuickView* view = new QQuickView;view-&gt;setSource(url);view-&gt;show();\n使用 QML Widget支持混合使用Qt Quick 框架和 Qt Widgets 框架, 不支持 window 作为根节点\n#include &lt;QApplication&gt;#include &lt;QQuickWidget&gt;QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);QApplication app(argc, argv);const QUrl url(QStringLiteral(&quot;qrc:/main.qml&quot;));QQuickWidget *view = new QQuickWidget;view-&gt;setSource(url);view-&gt;show();\n\nQt QML 语法基础QML 术语表\n\n\n术语\n含义\n\n\n\nQML\n1. QML 是一种应用编程语言 2. QML模块实现了QML语言的架构和引擎\n\n\nQt Quick\n1 基于QML实现的类型和功能的标准库 2. Qt Quick 模块实现了这些类型和功能\n\n\nType\n1. QML 基础类型 2. QML对象类型\n\n\nBasic Type\nQML 内置类型。 int、bool、string等\n\n\nObject Type\nQML代码定义的对象类型 c++代码定义的对象类型\n\n\nObject\n对象由QML引擎创建，1. 在对象定义时实例化 2.延迟实例化\n\n\nComponent\n组件是用于创建QML对象或者对象树的模板 1. QML文档加载时由QML引擎创建 2. 在QML 文档内部内联定义创建\n\n\nDocument\nQML 文档包含了一些QML源代码，文档名以大写字母开头 1. 可以位于 QML 源代码文件 2. 可以位于一个文本字符串中\n\n\nProperty\n一个对象可以有一个或多个属性 1. 属性名称 2.属性的值\n\n\nBinding\n属性绑定到一个javascript 表达式，任何时候属性的值由整个 javascript表达式估值决定\n\n\nSignal\n对象可以发射一个信号  其他对象可以接受并通过信号处理器处理这个信号\n\n\nSignal Handler\n信号处理\n\n\nLazy Instance\n对象可以延迟初始化，已避免不必要的工作\n\n\nQML 导入语句\nimport 模块标识 主版本.次版本 as 模块名称\nimport “目录路径” as 模块名称\nimport “javascript文件名称” as 模块名称\n\nQML 对象定义语句对象类型 &#123;    属性： 属性值    信号    信号处理器    函数&#125;\nQML 注释跟 C++ 一样，单行和多行\nQML 调试日志console.log(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);console.debug(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);console.info(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);console.warn(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);console.error(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);\n断言断言失败不影响之后的代码运行\nconsole.assert(width &gt; 600, &quot;assert failed&quot;)\n计时器console.time(&quot;ty&quot;);...console.timeEnd(&quot;ty&quot;);\n跟踪console.trace();\n计数统计函数执行了多少次\nconsole.count();\n","categories":["Qt"],"tags":["Qt","QML"]}]