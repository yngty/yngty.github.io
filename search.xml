<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 中 malloc 和 new 的区别</title>
    <url>/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">new</th>
<th align="center">malloc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">关键字</td>
<td align="center">标准库函数</td>
</tr>
<tr>
<td align="center">支持语言</td>
<td align="center"><code>C/C++</code></td>
<td align="center">只在 <code>C++</code></td>
</tr>
<tr>
<td align="center">申请内存的位置</td>
<td align="center">自由存储区 <code>free store</code></td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">分配内存的大小</td>
<td align="center">编译器根据类型信息自行计算</td>
<td align="center">显示指定字节数</td>
</tr>
<tr>
<td align="center">内存分配失败</td>
<td align="center">抛出 <code>bac_alloc</code> 异常, 不会返回 <code>NULL</code></td>
<td align="center">返回 <code>NULL</code></td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">返回对象类型的指针</td>
<td align="center">返回<code>void</code> 指针，需要转换</td>
</tr>
<tr>
<td align="center">是否调用构造函数&#x2F;析构函数</td>
<td align="center">调用</td>
<td align="center">不调用</td>
</tr>
<tr>
<td align="center">处理数组</td>
<td align="center"><code>new[]</code></td>
<td align="center">手动指定数组的大小</td>
</tr>
<tr>
<td align="center">是否支持重载</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">是否支持内存扩充</td>
<td align="center">不支持</td>
<td align="center"><code>realloc</code></td>
</tr>
<tr>
<td align="center">内存释放方式</td>
<td align="center"><code>new/delete</code>, <code>new[]/delete[]</code></td>
<td align="center"><code>malloc/free</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>std::make_shared vs. new</title>
    <url>/2023/02/07/c++/std-make-shared-vs-new/</url>
    <content><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p><code>std::make_shared</code> 执行<strong>一次</strong>堆分配，而调用<code>std::shared_ptr</code> 构造函数执行<strong>两次</strong>。</p>
<p>在一个典型的实现中 <code>std::shared_ptr</code> 管理两个实体：</p>
<ul>
<li>控制块（存储元数据，如引用计数、类型擦除删除器等）</li>
<li>被管理的对象</li>
</ul>
<p>控制块是一个动态分配的对象，它包含：</p>
<ul>
<li>指向托管对象的指针或托管对象本身；</li>
<li>删除器 (类型擦除)</li>
<li>分配器 (类型擦除)</li>
<li>拥有被管理对象的 <code>shared_ptr</code>的数量</li>
<li>引用托管对象的 <code>weak_ptr</code> 的数量</li>
</ul>
<p><code>std::make_shared</code>执行一次堆分配，计算控制块和数据所需的总空间。在另一种情况 <code>std::shared_ptr&lt;Obj&gt;(new Obj(&quot;foo&quot;))</code>下执行两次, <code>new Obj(&quot;foo&quot;)</code>为托管数据调用堆分配，<code>std::shared_ptr</code>构造函数为控制块执行另一个堆分配。</p>
<span id="more"></span>

<h1 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h1><p><strong>自 <code>C++17</code> 以来，这不是问题，因为函数参数的评估顺序发生了变化。具体来说，函数的每个参数都需要在评估其他参数之前完全执行</strong>。</p>
<p>考虑这个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(std::shared_ptr&lt;int&gt;(new int(42)), g())</span><br></pre></td></tr></table></figure>
<p>因为 C++ 允许对子表达式进行任意顺序的计算，所以一种可能的顺序是：</p>
<ol>
<li><code>new int(42)</code></li>
<li><code>g()</code></li>
<li><code>std::shared_ptr&lt;int&gt;</code></li>
</ol>
<p>现在，假设我们在第 <code>2</code> 步抛出一个异常。然后我们丢失了在步骤 <code>1</code> 分配的内存，因为没有将原始指针传给 <code>std::shared_ptr</code>, 后面没有任何东西有机会清理它。</p>
<p>解决这个问题的一种方法是在不同的行上执行它们，这样就不会发生这种任意排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto ptr = std::shared_ptr&lt;int&gt;(new int(42));</span><br><span class="line">f(ptr, g());</span><br></pre></td></tr></table></figure>

<p>更方便的的是采用 <code>std::make_shared</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(std::make_shared&lt;int&gt;(42), g())</span><br></pre></td></tr></table></figure>

<h1 id="std-make-shared-的一些缺点"><a href="#std-make-shared-的一些缺点" class="headerlink" title="std::make_shared 的一些缺点"></a><code>std::make_shared</code> 的一些缺点</h1><h2 id="weak-ptr内存保活"><a href="#weak-ptr内存保活" class="headerlink" title="weak_ptr内存保活"></a><code>weak_ptr</code>内存保活</h2><ul>
<li>通过 <code>std::make_shared</code> 构造的智能指针, 当没有 <code>shared_ptr</code> 引用计数为 <code>0</code> 时只调用析构函数，<code>weak_ptr</code>引用计数为 <code>0</code> 时才释放内存块。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> logging = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (logging) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Allocated: &quot;</span> &lt;&lt; (<span class="type">uintptr_t</span>)ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> <span class="keyword">noexcept</span>  </span>&#123;</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (logging) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deallocated: &quot;</span> &lt;&lt; (<span class="type">uintptr_t</span>)ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget::~Widget()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span> </span>&#123;</span><br><span class="line">    logging = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="literal">true</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated: 105553162522944 //分配一次</span><br><span class="line">Widget::~Widget() // 没有 shared_ptr 指针，只调用析构函数</span><br><span class="line">No std::shared_ptr&#x27;s anymore.</span><br><span class="line">Deallocated: 105553162522944 //没有 `weak_ptr` 释放整个内存块</span><br><span class="line">No std::weak_ptr&#x27;s anymore.</span><br><span class="line">---------------------</span><br><span class="line">Allocated: 105553164599312</span><br><span class="line">Allocated: 105553162522944 //分配两次</span><br><span class="line">Widget::~Widget()</span><br><span class="line">Deallocated: 105553164599312 //立即释放</span><br><span class="line">No std::shared_ptr&#x27;s anymore.</span><br><span class="line">Deallocated: 105553162522944</span><br><span class="line">No std::weak_ptr&#x27;s anymore.</span><br></pre></td></tr></table></figure>

<h2 id="无法访问公共构造函数"><a href="#无法访问公共构造函数" class="headerlink" title="无法访问公共构造函数"></a>无法访问公共构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">val</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make_shared 无法调用 A(int) </span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;A&gt; createNext()&#123; </span></span><br><span class="line">    <span class="comment">//     return std::make_shared&lt;A&gt;(val+1); </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以调用 A(int) </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">createNext</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(val+<span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v): <span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">Difference in make_shared and normal shared_ptr in C++</a></li>
<li><a href="https://www.gamedev.net/forums/topic/695796-stdmake_shared-vs-new/">std::make_shared 与 new</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr/make_shared#Notes">make_shared#Notes</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 1：将C++视作一系列的语言</title>
    <url>/2020/12/07/effecitve-cpp/effective-cpp-1/</url>
    <content><![CDATA[<blockquote>
<p>Item 1: View C++ as a federation of languages</p>
</blockquote>
<p>一开始，<code>Ｃ++</code> 只是 <code>Ｃ</code> 加上一些面向对象特性，<code>Ｃ++</code> 最初的名称 <code>Ｃ with Classes</code> 也反映了这个血缘关系。现在这个语言逐渐成熟，已经是一个<strong>多重泛型编程语言</strong>(<code>multiparadigm programming language</code>)。同时支持过程形式(<code>procedural</code>)、面向对象形式(<code>object-oriented</code>)、函数形式(<code>functional</code>)、泛型形式(<code>generic</code>)、元编程形式(<code>metaprogramming</code>)</p>
<p>将 <code>C++</code> 视为一个由相关语言组成的联邦而非单一的语言。</p>
<p><code>C++</code> 主要４个子语言：</p>
<ul>
<li><code>C</code>。说到底Ｃ++仍是以Ｃ为基础。许多时候Ｃ++对问题的解法其实不过就是较高级的Ｃ的解法如<code>item2</code>、<code>item13</code>。当只使用<code>C++</code>中<code>C</code>的那部分语法，　会发现<code>C</code>语言的缺陷：没有模板、没有异常、没有重载。</li>
<li><code>Object-Oriented</code>。面向对象程序设计也是<code>C++</code>的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。</li>
<li><code>Template C++</code>。这是C++的泛型编程部分，大多数程序员经验最少的部分。<strong>TMP模板元编程</strong>（<code>template metaprogramming</code>）也是一个新兴的程序设计范式。</li>
<li><code>STL</code>。<code>STL</code>是一个特殊的模板库，它将容器、迭代器和算法优雅地结合在一起。</li>
</ul>
<p><code>C++</code> 程序设计的惯例并非一成不变，而是取决于你使用 <code>C++</code> 语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触 <code>Object-Oriented C++</code> 时会发现，传常量指针是更好的选择。运用<code>Template C++</code>时尤其如此，因为彼时你甚至不知道所处理的对象的类型。 但是你如果又碰到了<code>STL</code>，其中的迭代器和函数对象都是基于<code>C</code>语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 10：赋值运算符要返回自己的引用</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-10/</url>
    <content><![CDATA[<blockquote>
<p>Item 10：Have assignment operators return a reference to *this.</p>
</blockquote>
<p>赋值运算符要返回自己的引用只是个协议，并无强制性。这份协议被所有内置类型和标准程序库提供的类型如<code>string</code>, <code>vector</code>, <code>complex</code> <code>std::shared_ptr</code>等共同遵守。可以用来支持链式的赋值语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>; <span class="comment">//赋值连锁形式</span></span><br></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = ( y = ( z = <span class="number">15</span> ) );</span><br></pre></td></tr></table></figure>

<p>我们自定义的对象最好也能支持链式的赋值，这需要重载&#x3D;运算符时返回当前对象的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;   </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算 +=, -=, *=, etc.</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;  </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 11：赋值运算符需要考虑自我赋值问题</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-11/</url>
    <content><![CDATA[<blockquote>
<p>Item 11: Handle assignment to self in operator&#x3D;</p>
</blockquote>
<p>我们在重载一个类的赋值运算符时要考虑自我赋值的问题。有了指针和引用自我赋值不总是第一时间能够识别出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line">*px = *py;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">const</span> Base&amp; rb, Derived* pd)</span></span>;<span class="comment">// rb和女pd 有可能其实是同一对象</span></span><br><span class="line">rb = pd;</span><br></pre></td></tr></table></figure>

<p>自我赋值主要考虑到 <strong>自我赋值安全性</strong> 和 <strong>异常安全性</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">//指针，指向一个从heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既不自我赋值安全性也不异常安全性, 当 rhs &#x3D;&#x3D; *this时，delete pb使得rhs.pb成为空值，接下来 new 的数据便是空的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断两个地址是否相同，如果是自我赋值，就不做任何事。但开始就delete pb， 但 new 出现异常， pb就会置空出现风险。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 证同测试</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中<strong>仔细地排列语句顺序</strong>通常可以达到异常安全， 比如我们可以先申请空间，最后再delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap *pOrig = pb;  </span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更加通用的技术便是复制和交换（copy and swap）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this rhs 的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs); <span class="comment">//rhs 数据制作一份复件(副本)</span></span><br><span class="line">    <span class="built_in">swap</span> (temp); <span class="comment">//*this 数据和上述复件的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 12：复制对象时勿忘其每一个成分</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-12/</url>
    <content><![CDATA[<blockquote>
<p>Item 12: Copy all parts of an object</p>
</blockquote>
<p>正确拷贝函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="情形一：-新添加了一个数据成员，忘记了更新拷贝函数"><a href="#情形一：-新添加了一个数据成员，忘记了更新拷贝函数" class="headerlink" title="情形一： 新添加了一个数据成员，忘记了更新拷贝函数"></a>情形一： 新添加了一个数据成员，忘记了更新拷贝函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line">  Date lastTransaction;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时 <code>lastTransaction</code> 便被你忽略了，编译器也不会给出任何警告（即使在最高警告级别）</p>
<h3 id="情形二：-继承父类忘记了拷贝父类的部分"><a href="#情形二：-继承父类忘记了拷贝父类的部分" class="headerlink" title="情形二： 继承父类忘记了拷贝父类的部分"></a>情形二： 继承父类忘记了拷贝父类的部分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : <span class="built_in">priority</span>(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确写法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : <span class="built_in">Customer</span>(rhs), <span class="built_in">priority</span>(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 13：以对象管理资源</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-13/</url>
    <content><![CDATA[<blockquote>
<p>Item 13: Use objects to manage resources.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 14：在资源管理类中小心 copying 行为</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-14/</url>
    <content><![CDATA[<blockquote>
<p>Item 14: Think carefully about copying behavior in resource-managing classes.</p>
</blockquote>
<p>设计一个 <strong><code>RAII</code></strong> 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>:mutexPtr(pm)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>()&#123; <span class="built_in">unlock</span>(mutexPtr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户对<code>Lock</code>的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <strong><code>RAII</code></strong> 对象被复制，会发生什么事？ 不确定？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(&amp;ml1)</span></span></span><br></pre></td></tr></table></figure>

<p>记住<strong>资源管理对象的拷贝行为取决于资源本身的拷贝行为，同时资源管理对象也可以根据业务需要来决定自己的拷贝行为</strong>。一般有如下四种方式：</p>
<ul>
<li><p><strong>禁止复制</strong>。参考<a href="/2021/10/25/effecitve-cpp/effective-cpp-6/" title="Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝">若不想使用编译器自动生成的函数，就该明确拒绝</a>。对Lock而言看起来是这样：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>引用计数</strong>，采用 <code>shared_ptr</code> 的逻辑。<code>shared_ptr</code> 构造函数提供了第二个参数 <code>deleter</code>，当引用计数到 <code>0</code> 时被调用。 所以 <code>Lock</code> 可以通过聚合一个 <code>shared_ptr</code> 成员来实现引用计数：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm, unlock)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutexPtr; <span class="comment">//shared_ptr替换 raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>   <code>Lock</code> 的析构会引起 <code>mutexPtr</code> 的析构，而 <code>mutexPtr</code> 计数到0时<code>unlock(mutexPtr.get())</code> 会被调用。</p>
</li>
<li><p><strong>拷贝底部资源</strong>。复制资源管理对象时，进行的是<strong>深拷贝</strong>。比如 <code>string</code> 的行为：内存存有指向对空间的指针，当它被复制时会复制那片空间。</p>
</li>
<li><p><strong>转移底部资源的拥有权</strong>。<code>auto_ptr</code> 就是这样做的，把资源移交给另一个资源管理对象，自己的资源置空。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 15：在资源管理类中提供对原始资源的访问</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-15/</url>
    <content><![CDATA[<blockquote>
<p>Item 15: Provide access to raw resources in resource-managing classes.</p>
</blockquote>
<p><code>APIs</code> 往往要求访问原始资源(<code>raw resources</code>)，所以每一个RAII class 应该<strong>提供提供对原始资源访问的方法。获取资源的方式有两类：隐式地获取和显式地获取。</strong> 显式的资源获取会更安全，它最小化了无意中进行类型转换的机会。</p>
<ul>
<li><strong>显示获取</strong></li>
</ul>
<p><code>shared_ptr</code> 提供了 <code>get</code> 方法来得到资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Investment&gt; pInv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daysHeld</span><span class="params">(Investment *pi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<p>为了让 <code>pInv</code> 表现地更像一个指针，<code>shared_ptr</code>还重载了解引用运算符（<code>dereferencing operator</code>） <code>operator-&gt;</code>和 <code>operator*</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>());</span><br><span class="line"><span class="type">bool</span> texable2 = !((*pi1).<span class="built_in">isTaxFree</span>());</span><br></pre></td></tr></table></figure>

<p>我们封装了Font来管理资源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line">FontHandle f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span>: f(fh)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Font</span>()&#123; <span class="built_in">releaseFont</span>(f); &#125;;</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过get方法来访问FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>隐式地获取</strong></li>
</ul>
<p>可以隐式类型转换运算符将 <code>Font</code> 转换为 <code>FontHandle</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> f;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize);</span><br></pre></td></tr></table></figure>

<p>然而问题也随之出现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FontHandle h2 = f1;</span><br></pre></td></tr></table></figure>
<p>无意间 <code>h2</code> 并没有被资源管理起来，这将会引发意外的资源泄漏。所以隐式转换在提供便利的同时， 也引起了资源泄漏的风险。 </p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 16：使用同样的形式来new和delete</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-16/</url>
    <content><![CDATA[<blockquote>
<p>Item 16: Use the same form in corresponding uses of new and delete.</p>
</blockquote>
<p><strong>如果你用 <code>new</code> 申请了动态内存，请用 <code>delete</code> 来销毁；如果你用 <code>new xx[]</code> 申请了动态内存，请用 <code>delete[]</code> 来销毁</strong>: </p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string* stringPtrl = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* stringPtr2 = <span class="keyword">new</span> std::string[lOO];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringptrl;      <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;  <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure>

<p>上面很容易理解但需要注意<code>typedef</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];    <span class="comment">//每个人的地址有四行，</span></span><br><span class="line">                                        <span class="comment">//每行是一个string</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>AddressLines</code> 是个数组，如果这样使用 <code>new</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string *pal = <span class="keyword">new</span> AddressLines;     <span class="comment">//注意. &quot;new AddressLines&quot; 返回</span></span><br><span class="line">                                         <span class="comment">//一个 string*，就像 &quot;new string[4]&quot; 一样</span></span><br></pre></td></tr></table></figure>
<p>那就必须匹配 “<strong>数组形式</strong>“的 <code>delete</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pal;         <span class="comment">//行为未有定义!</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;     <span class="comment">//很好。</span></span><br></pre></td></tr></table></figure>

<p>为避免诸如此类的错误，最好尽量不要对数组形式做 <code>typedefs</code> 动作。可以使用更加面向对象的<code>vector</code>、<code>string</code>等对象。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 17：在单独的语句中将 new 的对象放入智能指针</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-17/</url>
    <content><![CDATA[<blockquote>
<p>Item 17: Store newed objects in smart pointers in standalone statements.</p>
</blockquote>
<p><strong>以单独的语句将 <code>new</code> 的对象放入智能指针内。这是为了防止由于其他表达式抛出异常而导致的资源泄漏</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>上述代码中，在 <code>processWidget</code> 函数被调用之前参数会首先得到计算。可以认为包括三部分的过程：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
<li>调用 <code>priority()</code></li>
</ol>
<p><strong>因为C++不同于其他语言，函数参数的计算顺序很大程度上决定于编译器</strong>，编译器认为顺序应当是1, 3, 2，即：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>调用 <code>priority()</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
</ol>
<p>那么如果 <code>priority</code>抛出了异常，新的 <code>Widget</code> 便永远地找不回来了。虽然我们使用了智能指针，但资源还是泄漏了！</p>
<p>于是更加健壮的实现中，应当将创建资源和初始化智能指针的语句独立出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Widget&gt; pw = <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget);</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 18：让接口容易被正确使用，不易被误用</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-18/</url>
    <content><![CDATA[<blockquote>
<p>Item 18: Make interfaces easy to use correctly and hard to use incorrectly.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 19：设计 class 犹如设计 type</title>
    <url>/2021/11/11/effecitve-cpp/effective-cpp-19/</url>
    <content><![CDATA[<blockquote>
<p>Item 19: Teat class design as type design.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 2：尽量以const, enum, inline 替换 &amp;#35;define</title>
    <url>/2020/12/14/effecitve-cpp/effective-cpp-2/</url>
    <content><![CDATA[<blockquote>
<p>Item 2: Prefer consts, enums, and inlines to #defines</p>
</blockquote>
<p>我们先看看<code>#deifne</code> 有哪些的问题:</p>
<h1 id="不利于调试"><a href="#不利于调试" class="headerlink" title="不利于调试"></a>不利于调试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ASPECT_RATION 1.653</span><br></pre></td></tr></table></figure>
<p>在预处理时候 <code>ASPECT_RATION</code> 可能就被移走了,<code>ASPECT_RATION</code> 没有进入 符号表, 运行此常量获得编译错误信息时, 可能会疑惑。因为这个错误信息总是提到 <code>1.653</code>，而不是<code>ASPECT_RATION</code> ， 如果 <code>ASPECT_RATION</code> 定义不是自己写的头文件中，可能对 <code>1.653</code> 的来源毫无概念，将因追踪它浪费时间，解决之道是以一个常量替换上述宏 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏</span></span><br><span class="line">                                 <span class="comment">//因此这里改变名称写法</span></span><br></pre></td></tr></table></figure>
<p>作为一个语言常量，<code>ASPECT_RATION</code> 肯定会被编译器看到，当然会进入记号表内。此外对于浮点常量(<code>floating point constant</code>)而言，使用常量可能比使用<code>#define</code> 导致较少量的码。</p>
<h1 id="不重视scope"><a href="#不重视scope" class="headerlink" title="不重视scope"></a>不重视scope</h1><p>无法利用 <code>#define</code> 创建<code>class</code>专属常量。一旦宏定义，它就在其后的编译过程中有效（除非在某处 <code>#undef</code> ）。而 <code>const</code> 可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns; <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];      <span class="comment">//使用该常量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum-比-const-更好用"><a href="#enum-比-const-更好用" class="headerlink" title="enum 比 const 更好用"></a>enum 比 const 更好用</h2><p>旧式编译器也许不支持上述语法，　它们不允许static在声明式上获得初值，此外所谓的“<code>in-classs　初值设定</code>”也只运行对<strong>整数常量</strong>进行，　如果编译器不支持上述语法，可以将初值放在定义式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CostEstimate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> FudgeFactor;  <span class="comment">//staitc class　常量声明位于头文件内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>; <span class="comment">//staitc class　常量定义位于实现文件内</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>emnu</code>就很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];　<span class="comment">//the enum hack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　</p>
<h1 id="不易理解"><a href="#不易理解" class="headerlink" title="不易理解"></a>不易理解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b)  f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);     　<span class="comment">//ａ被累加二次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b + <span class="number">10</span>);　<span class="comment">//ａ被累加一次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须记住为宏的所有实参加上小括号</li>
<li>在这里调用ｆ之前，ａ的递增次取决与“它被拿来与谁比较”</li>
</ul>
<p>更好的做法是使用　<code>template inline</code>　函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 20：传常量引用比传值更好</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-20/</url>
    <content><![CDATA[<blockquote>
<p>Item 20: Prefer pass-by-reference-to-const to pass-by-value.</p>
</blockquote>
<p>缺省情况下<code>C++</code> 用传值得方式(一个继承自<code>C</code>的方式)传递对象至(或来自)函数。除非你另外指定，否则函数参数都是以实际实参的复件(副本)为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件(副本)系由对象的<code>copy</code>构造函数产出。</p>
<p><strong>尽量以传常量引用替换传值前者通常比较高效，并可避免切割问题 (<code>slicing problem</code>)，但是内置类型和 <code>STL</code> 迭代器，还是传值更加合适。</strong>。</p>
<span id="more"></span>

<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题:"></a>性能问题:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> ();</span><br><span class="line">    <span class="keyword">virtual</span> -<span class="built_in">Person</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    -<span class="built_in">Student</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑以下代码，其中调用函数 <code>validateStudent</code> ，后者需要一个 <code>Student</code><br>(<code>by value</code>) 并返回它是否有效:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;           <span class="comment">// function taking a Student by value</span></span><br><span class="line"></span><br><span class="line">Student plato;                             <span class="comment">// Plato studied under Socrates</span></span><br><span class="line"><span class="type">bool</span> platoIsOK = <span class="built_in">validateStudent</span>(plato);   <span class="comment">// call the functio</span></span><br></pre></td></tr></table></figure>

<p>在调用 <code>validateStudent(</code>) 时进行了 <strong>6</strong> 个函数调用：</p>
<ol>
<li><code>Person</code> 的拷贝构造函数，为什么 <code>Student</code> 的拷贝构造一定要调用 <code>Person</code> 的拷贝构造请参见：<a href="/2021/11/02/effecitve-cpp/effective-cpp-12/" title="Effective C++ 12：复制对象时勿忘其每一个成分">Item:12 复制对象时勿忘其每一个成分</a></li>
<li><code>Student</code> 的拷贝构造函数</li>
<li><code>name</code>, <code>address</code>, <code>schoolName</code>, <code>schoolAddress</code> 的拷贝构造函数</li>
</ol>
<p>解决办法便是传递常量引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先以引用的方式传递，不会构造新的对象，避免了上述例子中 <strong>6</strong> 个构造函数的调用。 同时 const 也是必须的：传值的方式保证了该函数调用不会改变原来的 <code>Student</code>， 而传递引用后为了达到同样的效果，需要使用 <code>const</code> 声明来声明这一点，让编译器去进行检查!</p>
<h2 id="截断问题"><a href="#截断问题" class="headerlink" title="截断问题"></a>截断问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// return name of window</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// draw window and contents</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在假设你希望写个函数打印窗口名称，然后显示该窗口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; w.<span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    w.<span class="built_in">display</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br></pre></td></tr></table></figure>

<p>当调用 <code>printNameAndDisplay</code> 时参数类型从 <code>WindowWithScrollBars</code> 被隐式转换为 <code>Window</code>。 该转换过程通过调用 <code>Window</code> 的拷贝构造函数来进行。 导致的结果便是函数中的 <code>w</code> 事实上是一个 <code>Window</code> 对象， 并不会调用多态子类 <code>WindowWithScrollBars</code> 的 <code>display()</code>。</p>
<p>正确做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fine, parameter won&#x27;t be sliced</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>一般情况下相比于传递值，传递常量引用是更好的选择。但也有例外情况，比如 <strong>内置类型</strong> 和 <strong>STL 迭代器</strong>和<strong>函数对象</strong>。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 21：需要返回对象时，不要返回引用</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-21/</url>
    <content><![CDATA[<blockquote>
<p>Item 21: Don’t to return a reference when you must return an object.</p>
</blockquote>
<p>Item 20 中提到，多数情况下传引用比传值更好。但不要无脑追求这一点，一定不要返回空引用或指针。</p>
<span id="more"></span>

<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line">  <span class="type">int</span> n, d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Raitonal</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为什么是const请参考Item 3</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a, b;</span><br><span class="line">Rational c = a*b;</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>operator*</code> 返回的是一个实例，<code>a*b</code>时便会调用<code>operator*()</code>， 返回值被拷贝后用来初始化<code>c</code>。</p>
<p>不考虑编译器优化和 <code>C11</code> 的 <code>move</code> ,这个过程涉及到多个构造和析构过程：</p>
<ol>
<li><code>operator*</code>调用结束前，返回值被拷贝，调用拷贝构造函数</li>
<li><code>operator*</code>调用结束后，返回值被析构</li>
<li><code>c</code> 被初始化，调用拷贝构造函数</li>
</ol>
<p>我们能否通过传递引用的方式来避免这些函数调用？这要求在函数中创建那个要被返回给调用者的对象，而函数只有两种办法来创建对象：在栈空间中创建、或者在堆中创建。</p>
<p>在栈空间中创建显然是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n*rhs.n, lhs.d*rhs.d)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目标是要避免调用构造函数，而 <code>result</code> 却必须像任何对象一样地由构造函数构造起, 而且得到的 <code>result</code> 永远是空。因为 <code>result</code> 是一个 <code>local</code> 对象，当函数调用结束后 <code>result</code>即被销毁。</p>
<p>在堆中创建也会问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  Rational *result  = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n*rhs.n, lhs.d*rhs.d);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是得必须付出一个”构造函数调用”代价， 并且谁去 <code>delete</code>?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x*y*z;</span><br></pre></td></tr></table></figure>

<p>上面这样合理的代码都会导致内存泄露。</p>
<p>使用静态变量的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="type">static</span> Rational result; <span class="comment">// static 对象，此函数将返回</span></span><br><span class="line">    result = ... ; <span class="comment">// lhs 乘以 rhs. 并将结果置于 result 内。</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量首先便面临着线程安全问题，除此之外当我们需要不止一个的返回值同时存在时也会产生问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a*b) == (c*d))&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果operator*的返回值是静态变量，那么上述条件判断恒成立，因为等号两边是同一个对象。所以我们还是老老实实返回对象实例就好，并且考虑到编译器优化和<code>move</code>语意，拷贝构造返回值带来的代价没那么高。</p>
<p><strong>永远不要返回局部对象的引用或指针或堆空间的指针，如果需要多个返回对象时也不能是局部静态对象的指针或引用</strong>。<a href="/2021/01/13/effecitve-cpp/effective-cpp-4/" title="Effective C++ 4：确定对象被使用前已先被初始化">Item:4 确定对象被使用前已先被初始化</a>， 对于单例模式，返回局部静态对象的引用也是合理的。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 22：将成员变量声明为private</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-22/</url>
    <content><![CDATA[<blockquote>
<p>Item 22: Declare data members private.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 23：用非成员函数、非友元函数替换成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-23/</url>
    <content><![CDATA[<blockquote>
<p>Item 23: Prefer non-member non-friend functions to member functions</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 24：若所有参数皆需类型转换，请采用非成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-24/</url>
    <content><![CDATA[<blockquote>
<p>Item 24: Declare non-member functions when type conversions should apply all parameters.</p>
</blockquote>
<p>令 <code>classes</code> 支持隐式转换通常是糟糕的设计，但也有例外，最常见的是在建立数值类型时。 比如设计一个有理数 <code>class</code> 允许整数隐式转换。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>); <span class="comment">//构造函数刻意不使用 explicit; 允许 int-to-Rational 隐式转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时我们想设计一个乘法，该使用 <code>member</code> 函数，还是 <code>non-member</code> 函数， 还是 <code>non-member-friend</code> 函数？</p>
<p>我们先采用 <code>member</code> 函数看有什么问题？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用如下没有什么问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational result = oneEighth * oneHalf; <span class="comment">//ok</span></span><br><span class="line">result = result * oneEighth;  <span class="comment">// ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但当我们想支持混合运算，那 <code>Rational</code> 和 <code>ints</code> 相乘, 就只有一半行的通。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">//ok  隐式转换</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">// no</span></span><br></pre></td></tr></table></figure>

<p>当我们设计成 <code>non-member</code> 函数就都支持：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>(), rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;  <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth;  <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>

<p><strong>如果需要为某个函数的所有参数进行类型转换，那这个函数必须是 <code>non-member</code></strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 25：设计一个不抛异常的 swap 函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-25/</url>
    <content><![CDATA[<blockquote>
<p>Item 25: Consider support for a non-throwing swap.</p>
</blockquote>
<p><code>swap</code> 函数能置换两对象值，功能很重要!</p>
<ul>
<li>异常安全性编程</li>
<li>处理自我赋值可能性：<a href="/2021/11/01/effecitve-cpp/effective-cpp-11/" title="Effective C++ 11：赋值运算符需要考虑自我赋值问题">赋值运算符需要考虑自我赋值问题</a></li>
</ul>
<p><code>std</code> 的缺省基本实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="类的-swap"><a href="#类的-swap" class="headerlink" title="类的 swap"></a>类的 swap</h2><p>只要类型 <code>T</code> 支持 <code>copying</code>运算(拷贝构造和拷贝赋值运算)就能使用。 但缺省实现会有多次拷贝，在某些情况下不是性能最好的实现。比如针对 <code>pimpl</code> 手法实现的 <code>class</code>, 不仅要复制三次 <code>Widget</code> 还需要复制三次 <code>WdigetImpl</code>, 非常缺乏效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;);</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实我们发现这种情况只需要将 <code>pImpl</code> 指针交换就好， 我们可以将 <code>std::swap</code> 对 <code>Widget</code> 的特化来实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上述代码不能通过编译， 因为 <code>pImpl</code> 是私有变量， 所以，<code>Widget</code> 应当提供一个 <code>swap</code> 成员函数或友元函数。 惯例上会提供一个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap; <span class="comment">// 为何要这样？请看下文</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;</span><br><span class="line">      a.<span class="built_in">swap</span>(b);              <span class="comment">// 调用成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现与 STL 容器是一致的：<strong>提供公有 <code>swap</code> 成员函数， 并特化 <code>std::swap</code> 来调用那个成员函数</strong>。</p>
<h2 id="类模板的-swap"><a href="#类模板的-swap" class="headerlink" title="类模板的 swap"></a>类模板的 swap</h2><p>如果 <code>Widget</code> 和 <code>WidgetImpl</code> 是 <code>class templates</code> 而非 <code>classes</code>, 按照上面的 <code>swap</code> 实现方式，你可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;  ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但上述代码不能通过编译， <code>c++</code> 允许偏特化类模版，却不允许偏特化函数模版(虽然有的编译器中可以编译)。那我们继续尝试重载 <code>std::swap</code>  函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重载了 <code>std::swap</code>，相当于在 <code>std</code> 命名空间添加了一个函数模板。但这在 <code>C++</code> 标准中是不允许的！ <code>C++</code> 标准中，客户只能特化 <code>std</code> 中的模板，但不允许在 <code>std</code> 命名空间中添加任何新的模板。 上述代码虽然在有些编译器中可以编译，但会引发未定义的行为，所以不要这么做。所以我们最终可以把 <code>swap</code> 定义在 <code>Widget</code> 所在的命名空间中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何地方在两个 <code>Widget</code> 上调用 <code>swap</code> 时，<code>C++</code> 根据其 <code>argument-dependent lookup</code>（又称 <code>Koenig lookup</code>） 会找到 <code>WidgetStuff</code> 命名空间下的具有 <code>Widget</code> 参数的 <code>swap</code>。</p>
<p>其实类的 <code>swap</code> 也可以在同一命名空间下定义 <code>swap</code> 函数，而不必特化 <code>std::swap</code>。 但有人可能直接写 <code>std::swap(w1, w2)</code>，特化 <code>std::swap</code> 可以让你的类更加健壮。</p>
<p><strong>在成员函数中不要直接调用 <code>swap(pImpl, other.pImpl);</code> 因为指定了调用 <code>std::swap</code>，<code>argument-dependent lookup</code> 便失效了，<code>WidgetStuff::swap</code> 不会得到调用</strong>。</p>
<p>如果希望优先调用 <code>WidgetStuff::swap</code>，如果未定义则取调用 <code>std::swap</code>，那么应该如何写呢？ 看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;           <span class="comment">// 使得 std::swap 在该作用域内可见</span></span><br><span class="line">  <span class="built_in">swap</span>(obj1, obj2);          <span class="comment">// 现在，编译器会帮你选最好的 swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>C++</code> 编译器还是会优先调用指定了 <code>T</code> 的 <code>std::swap</code>，其次是 <code>obj1</code> 的类型 <code>T</code> 所在命名空间下的对应 <code>swap</code> 函数， 最后才会匹配 <code>std::swap</code> 的默认实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何实现 <code>swap</code> 呢？</p>
<ul>
<li>提供一个更加高效的，不抛异常的公有成员函数（比如 <code>Widget::swap</code>）。</li>
<li>在你类（或类模板）的同一命名空间下提供非成员函数 <code>swap</code>，调用你的成员函数。</li>
<li>如果你写的是类而不是类模板，也可以特化 <code>std::swap</code>，同样地在里面调用你的成员函数。</li>
<li>调用时，请首先用 <code>using</code> 使 <code>std::swap</code> 可见，然后直接调用 <code>swap</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 26：尽可能推迟变量的定义</title>
    <url>/2022/04/15/effecitve-cpp/effective-cpp-26/</url>
    <content><![CDATA[<blockquote>
<p>Item 26:Postpone variable definitions as long as possible.</p>
</blockquote>
<p>推迟变量的定义有两个好处：</p>
<ul>
<li>改善程序效率，减少无用的构造和析构。</li>
<li>增加程序流程清晰度。</li>
</ul>
<p>这条规则看似简单，但存在流程控制语句的时候容易疏忽。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted = password;</span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="推迟到需要构造时执行"><a href="#推迟到需要构造时执行" class="headerlink" title="推迟到需要构造时执行"></a>推迟到需要构造时执行</h2><p>当 <code>encryptPassword</code> 抛出异常时，<code>encrypted</code> 是无用的, 根本不需要构造它。所以更好的写法是推迟 <code>encrypted</code> 的构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;       <span class="comment">// 默认构造函数</span></span><br><span class="line">    encrypted = password;   <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推迟到有构造参数时"><a href="#推迟到有构造参数时" class="headerlink" title="推迟到有构造参数时"></a>推迟到有构造参数时</h2><p> <strong>“尽可能延后”</strong> 的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至<strong>应该尝试延后这份定义直到能够给它初值实参为止</strong>。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的 <code>default</code> 构造行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">encrypted</span><span class="params">(password)</span></span>;     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环中的变量"><a href="#循环中的变量" class="headerlink" title="循环中的变量"></a>循环中的变量</h2><p>循环中的变量定义也是一个常见的争论点。常有两种写法：</p>
<p>写法 <code>A</code>，在循环外定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; </span><br><span class="line">  w = some value dependent on i;</span><br><span class="line">  ...                           </span><br><span class="line">&#125;                  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写法 <code>B</code> ，在循环内定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>A</code>：<code>1</code> 个构造函数，<code>1</code> 个析构函数，<code>n</code> 个赋值运算符</li>
<li><code>B</code>：<code>n</code> 个构造函数，<code>n</code> 个析构函数</li>
</ul>
<p>但 <code>A</code> 使得循环内才使用的变量进入外部的作用域，不利于程序的理解和维护。软件工程中倾向于认为人的效率比机器的效率更加难得， 所以推荐采用 <code>B</code> 来实现。除非：</p>
<ul>
<li>这段代码是性能的关键.</li>
<li>赋值比一对构造&#x2F;析构更加廉价。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 28：避免返回 handles 指向对象内部成分</title>
    <url>/2022/04/16/effecitve-cpp/effective-cpp-28/</url>
    <content><![CDATA[<blockquote>
<p>Item28: Avoid returning “handles” to object internals.</p>
</blockquote>
<p>避免返回 <code>handles</code> (包括 <code>references</code> 、指针、迭代器)指向对象内部。</p>
<span id="more"></span>

<h2 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h2><p><code>const</code> 函数不再是 <code>const</code>, 修改了私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;</span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这样的设计可通过编译，但却是错误的。<code>upperLeft</code> 和 <code>lowerRight</code> 被声明为 <code>const</code> 成员函数，但是可以更改内部数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>; <span class="comment">// rec是个const矩形, 从 (0 ，0) 到 (100 ， 100)</span></span><br><span class="line"></span><br><span class="line">rec.<span class="built_in">upperLeft</span>( ) .<span class="built_in">setX</span>(<span class="number">50</span>);  <span class="comment">// 现在rec却变成从 (50 ， 0) 到 (100 ， 100)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>成员变量的封装性最多只等于”返回其 <code>reference</code>“ 的函数的访问级别。</li>
<li>如果 <code>const</code> 成员函数传出一个 <code>reference</code>，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。(<code>bitwise constness</code>原因)</li>
</ul>
<h2 id="悬空问题"><a href="#悬空问题" class="headerlink" title="悬空问题"></a>悬空问题</h2><p>虽然我们可以修改函数，达到不能修改私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br></pre></td></tr></table></figure>
<p>但也不能解决悬空问题。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">boundingBox</span><span class="params">(<span class="type">const</span> GUIObject&amp; obj)</span></span>; <span class="comment">//以 by value 方式返回一个矩形</span></span><br></pre></td></tr></table></figure>

<p>现在，客户有可能这么使用这个函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIObject* pgo; <span class="comment">// 让pgo指向某个GUIObject</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Point* pUpperLeft = &amp;(<span class="built_in">boundingBox</span>(*pgo) .<span class="built_in">upperLeft</span>()); <span class="comment">// 取得一个指针指向外框左上点</span></span><br></pre></td></tr></table></figure>

<p><code>pUpperLeft</code> 被悬空了，<code>boundingBox(*pgo)</code> 返回的是一个临时变量，在语句执行结束后就会销毁，导致 <code>pUpperLeft</code> 指针失效。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 3：尽可能使用 const</title>
    <url>/2021/01/05/effecitve-cpp/effective-cpp-3/</url>
    <content><![CDATA[<blockquote>
<p>Item3: Use const whenever possible.</p>
</blockquote>
<h1 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h1><p>指针的常量声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting;                 <span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;           <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;           <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;     <span class="comment">//const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>const</code> 出现在<code>*</code>左边，表示被指物为常量;　如果出现在<code>*</code>右边，表示指针自身为常量；如果出现在<code>*</code>两边，表示被指物和指针两者都是常量。</p>
<p>如果被指物是常量，<code>const</code> 放在类型之前和放在类型之后<code>*</code>之前表示的意义一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget* p)</span></span>;　<span class="comment">//f1　获得一个指针，指向一个常量Ｗidget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(widget <span class="type">const</span> *p)</span></span>;　<span class="comment">//f2 也是</span></span><br></pre></td></tr></table></figure>


<p>STL的<code>iterator</code> 系以指针塑模出来，所以<code>iterator</code>的作用像个<code>T*</code>指针。如果希望指针是常量，可以声明为 <code>const iterator</code>，如果希望被指物为常量，需使用 <code>const_iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">//iter的作用像个Ｔ* const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                             <span class="comment">//没问题，改变iter所指物  </span></span><br><span class="line">++iter;　　　　　　　　　　　　　　　　　　　　　　 　　　　     <span class="comment">//错误，iter是const</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();   <span class="comment">//cIter的作用像个const Ｔ*</span></span><br><span class="line">*cIter = <span class="number">10</span>;                                            <span class="comment">//错误，*cIter是const</span></span><br><span class="line">++cIter;                                                <span class="comment">//没问题，　改变cIter</span></span><br></pre></td></tr></table></figure>
<p>返回值声明为常量，可以降低代码被错误使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>　&#123;...&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*&#123;<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们本来想做个比较，错误地输入<code>=</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) ...</span><br></pre></td></tr></table></figure>
<p>编译器就会报错误：不可给常量赋值。</p>
<h1 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h1><p>声明const 成员函数，是为了确认该成员函数可以作用与const对象，也使class接口比较容易理解，可以得知哪些函数可以改动对象内容，哪些不可以。</p>
<p>成员函数只是常量性不同是可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>   <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// const objects</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)               <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// non-const objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;             <span class="comment">// fine — writing a non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;            <span class="comment">// error! — writing a const TextBlock</span></span><br></pre></td></tr></table></figure>

<h1 id="bitsise-constness-和-logical-constness"><a href="#bitsise-constness-和-logical-constness" class="headerlink" title="bitsise constness 和　logical constness"></a>bitsise constness 和　logical constness</h1><p><code>bitsise constness</code>: 成员函数只有在不改变对象的任何非静态成员变量时才可以被称为常量函数。也是C++对常量性的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pText[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TextBlock tb;</span><br><span class="line"><span class="type">char</span> *p = &amp;tb[<span class="number">1</span>];</span><br><span class="line">*p = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>函数调用<code>const</code>函数可以避免代码重复。不可以反着来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position]</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">            [position]</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>*this</code> 的类型是 <code>TextBlock</code>，先把它强制隐式转换为 <code>const TextBlock</code>，这样我们才能调用那个常量方法。</li>
<li>调用 <code>operator[](std::size_t) const</code>，得到的返回值类型为 <code>const char&amp;</code>。</li>
<li>把返回值去掉 <code>const</code> 属性，得到类型为 <code>char&amp;</code> 的返回值。</li>
</ol>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 4：确定对象被使用前已先被初始化</title>
    <url>/2021/01/13/effecitve-cpp/effective-cpp-4/</url>
    <content><![CDATA[<blockquote>
<p>Item 4: Make sure that objects are initialized before they’re used.</p>
</blockquote>
<h1 id="手工初始化内置对象"><a href="#手工初始化内置对象" class="headerlink" title="手工初始化内置对象"></a>手工初始化内置对象</h1><p>为内置对象进行手工初始化，因为<code>C++</code>不保证初始化他们。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;                                  <span class="comment">//对 int 进行手工初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;A C-style string&quot;</span>;      <span class="comment">//对指针进行手工初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">std::cin &gt;&gt; d;                              <span class="comment">//以读取 input stream 的方式完成初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="构造函数最好使用成员初值列"><a href="#构造函数最好使用成员初值列" class="headerlink" title="构造函数最好使用成员初值列"></a>构造函数最好使用成员初值列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones) &#123;</span><br><span class="line">    theName = name;             <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address;       <span class="comment">//而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在<code>class</code>中的声明次序相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones) : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address), <span class="built_in">thePhones</span>(phones), <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="local-static-对象替换-non-local-static-对象。"><a href="#local-static-对象替换-non-local-static-对象。" class="headerlink" title="local static 对象替换 non-local static 对象。"></a><code>local static</code> 对象替换 <code>non-local static</code> 对象。</h1><p>为免除”跨单元之初始化次序“问题，请以 <code>local static</code> 对象替换 <code>non-local static</code> 对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;     </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户使用使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params )</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在初始化次序的重要性体现出来了，除非 <code>tfs</code> 在 <code>tempDir</code> 之前先被初始化，否则<code>tempDir</code>的构造函数会用到尚未初始化的<code>tfs</code>。但<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源文件建立起来的，它们是定义于不同编译单元内的 <code>non-local static</code> 对象。它们初始化相对次序并无明确定义。但我们可以将 <code>local static</code> 对象替换<code>non-local static</code> 对象来解决。这也是<strong>Singleton</strong>模式的常见实现手法。</p>
<p>这个手法的基础在于：C++保证，函数内的 <code>local static</code> 对象会在调用该函数时首次遇上该对象的定义式时被初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 5：了解c++默默编写并调用哪些函数</title>
    <url>/2021/10/24/effecitve-cpp/effective-cpp-5/</url>
    <content><![CDATA[<blockquote>
<p>Item 5: Know what functions C++ silently writes and calls</p>
</blockquote>
<h1 id="默认函数"><a href="#默认函数" class="headerlink" title="默认函数"></a>默认函数</h1><p>在 <code>C++</code> 中，一个类有八个默认函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="built_in">Empty</span> () &#123;&#125; <span class="comment">//默认构造函数    </span></span><br><span class="line">    <span class="built_in">Empty</span> (<span class="type">const</span> Empty &amp;) &#123;&#125; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span> (<span class="type">const</span> Empty &amp;&amp;) &#123;&#125; <span class="comment">// 默认移动构造函数(`C++11`)</span></span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123;&#125; <span class="comment">// 默认析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;) &#123;&#125; <span class="comment">// 默认重载赋值运算符函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;&amp;)&#123;&#125; <span class="comment">// 默认重载移动赋值操作符函数函数</span></span><br><span class="line">    Empty* <span class="keyword">operator</span> &amp;() &#123;&#125; <span class="comment">// 默认重载取址运算符函数</span></span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="type">const</span> &#123;&#125; <span class="comment">// 默认重载取址运算符 `const` 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h1><p>只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。</p>
<h1 id="引用成员"><a href="#引用成员" class="headerlink" title="引用成员"></a>引用成员</h1><p>如果你打算在一个“内含引用成员”或者“内含<code>const</code>成员”的类内支持赋值操作，就必须定义自己的默认拷贝赋值操作符。因为 <code>C++</code> 本身不允许引用改指不同的对象，也不允许更改 <code>const</code> 成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string &amp; name;</span><br><span class="line">    <span class="built_in">Person</span>(string &amp;str):<span class="built_in">name</span>(str) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(s1)</span>, <span class="title">p2</span><span class="params">(s2)</span></span>;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: object of type &#x27;Person&#x27; cannot be assigned because its copy assignment operator is implicitly deleted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-6/</url>
    <content><![CDATA[<blockquote>
<p>Item 6: Explicitly disallow the use of compiler-generated functions you do not want.</p>
</blockquote>
<p>在C++中，编译器会自动生成一些你没有显式定义的函数。可以参考:<a href="/2021/10/24/effecitve-cpp/effective-cpp-5/" title="Effective C++ 5：了解c++默默编写并调用哪些函数">了解c++默默编写并调用哪些函数</a><br>然而有时候我们希望禁用掉这些函数，可以通过把自动生成的函数设为 <code>private</code> 来禁用它或者在 <code>c++11</code> 中使用 <code>delete</code> 关键字。</p>
<p>比如我们禁用拷贝的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale &amp;);  <span class="comment">// 只有声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;) = <span class="keyword">delete</span>； <span class="comment">// c++11</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以专门设计一个阻止<code>copying</code> 的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> noncopyable_ &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">noncopyable</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>() &#123;&#125;</span><br><span class="line">            ~<span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable() = default;</span></span><br><span class="line"><span class="comment">            ~noncopyable() = default;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">            noncopyable&amp; <span class="keyword">operator</span>=( <span class="type">const</span> noncopyable&amp; );</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            noncopyable&amp; operator=( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> noncopyable_::noncopyable</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HomeForSale p1, p2;</span><br><span class="line">p1 = p2;</span><br><span class="line"></span><br><span class="line">error: object of type <span class="string">&#x27;HomeForSale&#x27;</span> cannot be assigned because its copy assignment <span class="keyword">operator</span> is implicitly deleted</span><br><span class="line">    p1 = p2;</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 7：为多态基类声明 virtual 析构函数</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-7/</url>
    <content><![CDATA[<blockquote>
<p>Item 7: Declare destructors virtual in polymorphic base classes.</p>
</blockquote>
<p>析构函数声明为虚函数目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。 否则子类部分的内存将会泄漏，正确的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper *ptk = <span class="built_in">getTimeKeeper</span>():  <span class="comment">// 可能返回任何一种子类</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>

<ul>
<li>polymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果<br>class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。</li>
<li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性<br>(polymorphically) ，就不该声明 virtual 析构函数。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 8：析构函数不要抛出异常</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-8/</url>
    <content><![CDATA[<blockquote>
<p>Item 8: Prevent exceptions from leaving destructors.</p>
</blockquote>
<p><code>C++</code> 本身不阻止在析构函数抛出异常，但在析构函数中抛出的异常往往会难以捕获，引发程序非正常退出或未定义行为。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123; ... &#125; <span class="comment">//假设这里可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::vector&lt;Widget&gt; v;  <span class="comment">// v 这里被自动析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。</p>
<p>不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在 <code>C++</code> 中，不要让析构函数抛出异常！</p>
<p>但是如果析构函数所使用的代码可能无法避免抛出异常呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span>&#123;                   <span class="comment">//某用来建立数据库连接的类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;     <span class="comment">//建立一个连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;                     <span class="comment">//关闭一个连接，假设可以抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;                         <span class="comment">//创建一个资源管理类来提供更好的用户接口</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    ~DBConn&#123; db.<span class="built_in">close</span>(); &#125;            <span class="comment">//终止时自动调用关闭连接的方法</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...&#123;                                 </span><br><span class="line">  <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>; <span class="comment">//创建一个DBConn类的对象</span></span><br><span class="line">  ...                                 <span class="comment">//使用这个对象</span></span><br><span class="line">&#125;                                     <span class="comment">//对象dbc被释放资源</span></span><br><span class="line">          </span><br></pre></td></tr></table></figure>

<p>析构函数所调用的 <code>close()</code> 方法可能会抛出异常，那么有什么方法来解决呢？</p>
<p><strong>吞掉异常</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>主动关闭程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">    std::<span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把可能抛出异常的代码移出析构函数</strong></p>
<p>客户在需要关闭的时候主动调用 <code>close()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;        <span class="comment">//当要关闭连接时，手动调用此函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    closed = <span class="literal">false</span>;      <span class="comment">//显示连接是否被手动关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBConn::close</span><span class="params">()</span></span>&#123;    <span class="comment">//当需要关闭连接，手动调用此函数</span></span><br><span class="line">  db.<span class="built_in">close</span>();</span><br><span class="line">  closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DBConn::~<span class="built_in">DBcon</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!closed)            <span class="comment">//析构函数还是要留有备用，但不用每次都承担风险了</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">      <span class="comment">//记录访问历史</span></span><br><span class="line">      <span class="comment">//消化异常或者主动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析<br>构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 <code>class</code> 应该提<br>供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 9：绝不在构造和析构过程中调用 virtual 函数</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-9/</url>
    <content><![CDATA[<blockquote>
<p>Item 9: Never call virtual functions during construction or destruction.</p>
</blockquote>
<p>在构造和析构期间不要调用 <code>virtual</code> 函数，因为这类调用不会下降至 <code>derived class</code><br>(比起当前执行构造函数和析构函数的那层)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;                               <span class="comment">// base class for all</span></span><br><span class="line"><span class="keyword">public</span>:                                           <span class="comment">// transactions</span></span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;                                <span class="comment">// base class ctor           </span></span><br><span class="line">        <span class="built_in">logTransaction</span>();                         <span class="comment">// as final action, log this               </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;      <span class="comment">// make type-dependent</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;        <span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// how to log trans-</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p><code>b</code> 在构造时，调用到父类Transaction的构造函数，其中对 <code>logTransaction</code> 的调用会被解析到 <code>Transaction</code> 类。 那是一个纯虚函数，因此程序会非正常退出。</p>
<p>在<code>derived class</code> 对象的 <code>base class</code> 构造期间，对象的类型是 <code>base class</code> 而不是 <code>derived classo</code> 不只 <code>virtual</code> 函数会被编译器解析至(resolve to) <code>base class</code> ，若使用运行期类型信息 <code>RTTI</code>(runtime type information, 例如 <code>dynamic_cast</code>  <code>typeid</code>) ，也会把对象视为 <code>base class</code> 类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P11Transaction</span><br><span class="line">P14BuyTransaction</span><br></pre></td></tr></table></figure>

<p><strong>相同道理也适用于析构函数.</strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-STL 21：总是让比较函数在等值情况下返回 false</title>
    <url>/2023/03/10/effective-stl/effective-stl-21/</url>
    <content><![CDATA[<blockquote>
<p>Item 21: Always have comparison functions return false for equal values.</p>
</blockquote>
<h1 id="严格弱序-strict-weak-ordering"><a href="#严格弱序-strict-weak-ordering" class="headerlink" title="严格弱序( strict weak ordering )"></a>严格弱序( <code>strict weak ordering</code> )</h1><p>先补充下严格弱序的概念: 对两个变量 <code>x</code> 和 <code>y</code>：</p>
<ul>
<li><code>x &gt; y</code> 等同于 <code>y &lt; x</code></li>
<li><code>x == y</code> 等同于 <code>!(x &lt; y) &amp;&amp; !(x &gt; y)</code></li>
</ul>
<p>要想严格弱序，就需要遵循如下规则：</p>
<ul>
<li>每个变量值必须等于其本身（<code>irreflexivity</code>）：<code>x &lt; x</code> 永远不能为 <code>true</code></li>
<li>不对称性（<code>asymmetry</code>）：如果 <code>x &lt; y</code>，那么 <code>y &lt; x</code> 就不能为 <code>true</code></li>
<li>有序性必须可传递性：如果 <code>x &lt; y</code> 并且 <code>y &lt; z</code>，那么 <code>x &lt; z</code></li>
<li>值相同必须具有可传递性：如果 <code>x == y</code> 并且 <code>y == z</code>，那么 <code>x == z</code></li>
</ul>
<span id="more"></span>

<h1 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h1><h2 id="1-关联容器中的比较算法"><a href="#1-关联容器中的比较算法" class="headerlink" title="1. 关联容器中的比较算法"></a>1. 关联容器中的比较算法</h2><p>比如我们创建一个 <code>set</code> ， 用 <code>less_euqal</code> 作为比较类型，然后插入两个 <code>10</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>我们将第一个 <code>10</code> 记为 <code>10A</code>, 第二个 <code>10</code> 记为 <code>10B</code>, 我们在插入 <code>10B</code> 的时候会检查是否与 <code>10A</code> 相同, 我们用的是 <code>less_equal</code>，下面的表达式会为假，就会重复插入，显然不合理。:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!(10A &lt;= 10B) &amp;&amp; !(10B &lt;= 10A) //  !(true) &amp;&amp; !(true)</span><br></pre></td></tr></table></figure>

<p>另外在 <code>multiset</code> 中也不行: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>, less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入10A</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入10B</span></span><br></pre></td></tr></table></figure>

<p>当我们想要一个 <code>equal_range</code>, <code>10A</code> 和 <code>10B</code> 同样认为是不等，永远不会在同一个区间。</p>
<h2 id="2-sort-算法"><a href="#2-sort-算法" class="headerlink" title="2. sort 算法"></a>2. <code>sort</code> 算法</h2><p>对于 <code>std::sort</code>，当容器里面元素个数大于 <code>_S_threshold</code> 的值时（<code>16</code>），就会使用快速排序，会将所有的元素与中间值比较是无边界保护的，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">     _RandomAccessIterator</span><br><span class="line">     __unguarded_partition(_RandomAccessIterator __first,</span><br><span class="line">               _RandomAccessIterator __last,</span><br><span class="line">               _Tp __pivot, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span> (__comp(*__first, __pivot)) <span class="comment">// &lt;-------------------</span></span><br><span class="line">         ++__first;</span><br><span class="line">       --__last;</span><br><span class="line">       <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">         --__last;</span><br><span class="line">       <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">         <span class="keyword">return</span> __first;</span><br><span class="line">       std::<span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">       ++__first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入的 <code>vector</code> 中，后面的元素完全相等， <code>__comp()</code>函数一直返回 <code>true</code> ，在进行快速排序的时候，<code>++first</code> 就可能越界失效，导致 <code>coredump</code>。</p>
]]></content>
      <categories>
        <category>Effective-STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-STL</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-STL 9：慎重选择删除元素的方法</title>
    <url>/2023/02/16/effective-stl/effective-stl-9/</url>
    <content><![CDATA[<blockquote>
<p>Item9. Choose carefully among easing options.</p>
</blockquote>
<h1 id="一、删除特定值"><a href="#一、删除特定值" class="headerlink" title="一、删除特定值"></a>一、删除特定值</h1><ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code></p>
<p> 最好使用 <code>erase-remove</code>习惯用法: </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1963</span>, c.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器</p>
<p> 直接使用 <code>remove</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove</span>(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>对于标准关联容器</p>
<p> 直接使用 <code>erase</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="number">1963</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>
<h1 id="二、删除满足特定判定条件的值"><a href="#二、删除满足特定判定条件的值" class="headerlink" title="二、删除满足特定判定条件的值"></a>二、删除满足特定判定条件的值</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">badValue</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// 返回x是否为&quot;坏值&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code><br> 使用 <code>erase-remove-if</code>方法: </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), badValue, c.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器<br> 直接使用 <code>remove_if</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove_if</span>(badValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于标准关联容器</p>
<p> <strong>把当前的i传给erase，i后缀递增</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c3.<span class="built_in">erase</span>(i++); </span><br><span class="line">    <span class="keyword">else</span> ++i;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="三、循环内部删除对象之外还要做某些事"><a href="#三、循环内部删除对象之外还要做某些事" class="headerlink" title="三、循环内部删除对象之外还要做某些事"></a>三、循环内部删除对象之外还要做某些事</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code></p>
<p> <strong>接收 <code>erase</code>返回的迭代器值。</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">badValue</span>(*i)) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(*i);</span><br><span class="line">        i = c.<span class="built_in">rease</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器</p>
<p> 虽然也可以采用标准关联容器方法，但建议采用跟 <code>vector</code>、 <code>string</code> 或 <code>deque</code> 一致。</p>
</li>
<li><p>对于标准关联容器</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">badValue</span>(*i)) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(*i);</span><br><span class="line">        c.<span class="built_in">rease</span>(i++);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Effective-STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-STL</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之tr</title>
    <url>/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/</url>
    <content><![CDATA[<p><code>Linux</code> 中 <code>tr</code> 命令用于转换或删除文件中的字符。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> [OPTION] SET1 [SET2]</span></span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c, --complerment：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换;</span><br><span class="line">-d, --delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s, --squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t, --truncate-set1：先删除第一字符集较第二字符集多出的字符;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>字符集1(<code>SET1</code>)：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数 “字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</li>
<li>字符集2(<code>SET2</code>)：指定要转换成的目标字符集。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol>
<li><p>小写字母转换为大写字母:</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;HELLO WORLD&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -d &#x27;0-9&#x27;</span><br><span class="line">hello  world</span><br><span class="line"></span><br><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -cd &#x27;0-9&#x27;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></li>
<li><p>压缩字符</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello          world&quot; | tr -s &#x27;[:space:]&#x27;</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">➜  share echo &quot;hellooooo worldddddddddddd&quot; | tr -s &#x27;od&#x27; </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="常用的字符类"><a href="#常用的字符类" class="headerlink" title="常用的字符类"></a>常用的字符类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:print:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY</title>
    <url>/2022/04/19/linux/NO_PUBKEY/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt update </span><br><span class="line">命中:1 https://pro-driver-packages.uniontech.com eagle InRelease</span><br><span class="line">获取:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease [269 kB]                                 </span><br><span class="line">命中:3 http://packages.microsoft.com/repos/code stable InRelease                                             </span><br><span class="line">命中:4 https://home-packages.chinauos.com/home plum InRelease                                                </span><br><span class="line">命中:5 https://home-packages.chinauos.com/home plum/beta InRelease   </span><br><span class="line">命中:6 https://home-packages.chinauos.com/printer eagle InRelease</span><br><span class="line">错误:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease</span><br><span class="line">  由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">命中:7 https://home-store-img.uniontech.com/appstore eagle InRelease</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">W: GPG 错误：http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">E: 仓库 “http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease” 没有数字签名。</span><br><span class="line">N: 无法安全地用该源进行更新，所以默认禁用该源。</span><br><span class="line">N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 871920D1991BC93C</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>文件MIME类型</title>
    <url>/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="什么是-MIME-类型？"><a href="#什么是-MIME-类型？" class="headerlink" title="什么是 MIME 类型？"></a>什么是 MIME 类型？</h1><p><code>MIME</code>（多用途 <code>Internet</code> 邮件扩展）的类型来识别文件格式。 <code>MIME</code> 类型构成了 <code>Internet</code> 上对文件类型进行分类的标准方法。</p>
<ul>
<li><code>MIME Type</code>是用于描述文件的类型的一种表述方法，其将文件划分为多种类型，方便对其进行统一的管理。</li>
<li><code>MIME Type</code>指定了文件的类型名称、描述、图标信息，同时通过与.desktop应用程序描述文件整合，指定了文件的打开方式。</li>
</ul>
<span id="more"></span>
<p><code>MIME</code> 类型名字遵循指定的格式：</p>
<p>类型和子类型， 在 MIME 类型中，类型和子类型不区分大小写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-type/subtype-identifier</span><br></pre></td></tr></table></figure>

<p>目前，有十种注册类型：<code>application</code>，<code>audio</code>，<code>example</code>，<code>font</code>，<code>image</code>，<code>message</code>，<code>model</code>，<code>multipart</code>，<code>text</code>和<code>video</code>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multipart/form-data</span><br><span class="line">text/xml</span><br><span class="line">text/csv</span><br><span class="line">text/plain</span><br><span class="line">application/xml</span><br><span class="line">application/zip</span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<p>完整MIME 类型示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application/vnd.api+json</span><br></pre></td></tr></table></figure>

<p><code>application</code>作为类型，<code>api</code>作为子类型，<code>vnd</code>是厂商前缀，<code>+json</code>是后缀，表示可以解析为<code>JSON</code>。</p>
<h1 id="获取文件的-MIME-类型"><a href="#获取文件的-MIME-类型" class="headerlink" title="获取文件的 MIME 类型"></a>获取文件的 MIME 类型</h1><h2 id="xdg-mime命令"><a href="#xdg-mime命令" class="headerlink" title="xdg-mime命令"></a>xdg-mime命令</h2><ul>
<li><p>显示文件的<code>MIME</code>类型：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query filetype &#123;file&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query filetype one.jpg </span><br><span class="line">image/jpeg</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示<code>MIME</code> 类型的默认应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &#123;mimetype&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query default image/jpeg</span><br><span class="line">/usr/share/applications/deepin-image-viewer.desktop</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>显示文件默认应用程序的语法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &quot;$(xdg-mime query filetype &#123;file&#125;)&quot;</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default \</span><br><span class="line">    `xdg-mime query filetype &quot;$(find ~ / -iname &#x27;*.png&#x27; -print -quit)&quot;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>MIME</code> 类型的默认打开应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dekstop filetype</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dde-file-manager.desktop inode/directtory</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a>file 命令</h2><ul>
<li><p>查询文件类型：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file --mime-type INPUT_FILE</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ file --mime-type one.jpg </span><br><span class="line">one.jpg: inode/symlink</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="自定义的-MIME-类型"><a href="#自定义的-MIME-类型" class="headerlink" title="自定义的 MIME 类型"></a>自定义的 MIME 类型</h1><p>如需为系统上的所有用户添加一个自定义的 <code>MIME</code> 类型，并为该 <code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>/usr/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，在 <code>/usr/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<p>比如我们创建一个<code>application/x-newtype</code>类型：</p>
<ol>
<li><p>创建 &#x2F;usr&#x2F;share&#x2F;mime&#x2F;packages&#x2F;application-x-newtype.xml 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;mime-info xmlns=&quot;http://www.freedesktop.org/standards/shared-mime-info&quot;&gt;</span><br><span class="line">&lt;mime-type type=&quot;application/x-newtype&quot;&gt;</span><br><span class="line">    &lt;comment&gt;new mime type&lt;/comment&gt;</span><br><span class="line">    &lt;glob pattern=&quot;*.xyz&quot;/&gt;</span><br><span class="line">&lt;/mime-type&gt;</span><br><span class="line">&lt;/mime-info&gt;</span><br></pre></td></tr></table></figure>
<p> 上述 <code>application-x-newtype.xml</code> 文件定义了一种新的 <code>MIME</code> 类型<code>application/x-newtype</code>，并指定拓展名是 <code>.xyz</code> 的文件为该 <code>MIME</code> 类型。</p>
</li>
<li><p>创建一个名为例如 <code>myapplication1.desktop</code> 的新的 <code>.desktop</code> 文件，并将它放置在 <code>/usr/share/applications/</code> 目录下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=application/x-newtype</span><br><span class="line">Name=My Application 1</span><br><span class="line">Exec=myapplication1</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新 <code>MIME</code> 数据库以使您的更改生效：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-mime-database /usr/share/mime</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新应用程序数据库：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-desktop-database /usr/share/applications</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如需为个别用户添加自定义的 <code>MIME</code> 类型，并为该<code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>~/.local/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，并在 <code>~/.local/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/desktop_migration_and_administration_guide/file_formats">配置文件关联</a></p>
</li>
<li><p><a href="https://www.baeldung.com/linux/file-mime-types">file-mime-types</a></p>
</li>
<li><p><a href="https://specifications.freedesktop.org/mime-apps-spec/mime-apps-spec-latest.html">mime-apps-spec</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mime</tag>
      </tags>
  </entry>
  <entry>
    <title>Disk Arbitration</title>
    <url>/2023/02/16/macos/Disk-Arbitration/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>Disk Arbitration framework</code> 是一个基于 <code>Core Foundation</code> 的低级框架。会在磁盘出现和消失时通知您的应用程序，并让您的应用程序影响该过程。借助 <code>Disk Arbitration</code>，我们可以：</p>
<ul>
<li>检测何时出现新磁盘</li>
<li>阻止挂载</li>
<li>使用不同的标志或在不同的安装点上安装卷</li>
<li>卸载卷</li>
<li>观察卷的变化</li>
</ul>
<span id="more"></span>

<h1 id="使用磁盘仲裁通知和批准回调"><a href="#使用磁盘仲裁通知和批准回调" class="headerlink" title="使用磁盘仲裁通知和批准回调"></a>使用磁盘仲裁通知和批准回调</h1><ol>
<li>通过调用创建会话对象 <code>DASessionCreate</code>。</li>
<li>如果您想知道磁盘相关事件何时发生，请注册通知回调；如果您想积极参与仲裁过程，请注册批准回调。</li>
<li>在运行循环或调度队列上安排会话对象（并在必要时启动运行循环或调度队列）。</li>
<li>处理您的应用收到的任何回调。</li>
<li>当应用程序不再需要接收回调时，取消调度会话对象并释放它。</li>
</ol>
<h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p>编写磁盘仲裁通知客户端时必须做的第一件事是创建一个会话 (<code>DASessionRef</code>)。要创建磁盘仲裁会话，请调用<code>DASessionCreate</code>，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DASessionRef session;</span><br><span class="line">session = DASessionCreate(kCFAllocatorDefault);</span><br></pre></td></tr></table></figure>

<h2 id="注册通知和批准"><a href="#注册通知和批准" class="headerlink" title="注册通知和批准"></a>注册通知和批准</h2><p>磁盘仲裁支持两种类型的回调。通知回调告诉您发生了某些事情。批准回调允许您阻止挂载、卸载或弹出操作发生。</p>
<h3 id="通知回调"><a href="#通知回调" class="headerlink" title="通知回调"></a>通知回调</h3><ul>
<li><code>DADiskAppearedCallback</code>—出现磁盘或出现分区时调用</li>
<li><code>DADiskDescriptionChangedCallback</code>—当磁盘的描述发生变化时调用（在 <code>OS X v10.7</code> 及更高版本中，当首次安装卷时）</li>
<li><code>DADiskDisappearedCallback</code>—弹出可移动磁盘时调用</li>
<li><code>DADiskPeekCallback</code>—在首次探测磁盘时、自动挂载开始之前以及发送任何其他通知之前调用</li>
</ul>
<h3 id="注册函数"><a href="#注册函数" class="headerlink" title="注册函数"></a>注册函数</h3><ul>
<li><code>DARegisterDiskAppearedCallback</code></li>
<li><code>DARegisterDiskDescriptionChangedCallback</code></li>
<li><code>DARegisterDiskDisappearedCallback</code></li>
<li><code>DARegisterDiskPeekCallback</code></li>
</ul>
<p>这些注册函数中的大多数都采用匹配字典。您通常应该传递 <code>NULL``（以匹配所有磁盘）或传递标准匹配字典，例如kDADiskDescriptionMatchMediaUnformatted</code>. 这些匹配字典的详细匹配行为如下所示:</p>
<table>
<thead>
<tr>
<th align="left">标准字典</th>
<th align="left">内容</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">kDADiskDescriptionMatchMediaUnformatted</td>
<td align="left">kDADiskDescriptionMediaSizeKey价值为0</td>
<td align="left">匹配未格式化的媒体（如空白 DVD）。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchMediaWhole</td>
<td align="left">kDADiskDescriptionMediaWholeKey有价值true</td>
<td align="left">仅匹配整盘媒体（&#x2F;dev&#x2F;disk0例如 ）。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchVolumeMountable</td>
<td align="left">kDADiskDescriptionVolumeMountableKey有价值true</td>
<td align="left">匹配可安装的卷。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchVolumeUnrecognized</td>
<td align="left">kDADiskDescriptionVolumeMountableKey有价值false</td>
<td align="left">匹配不可挂载的磁盘。</td>
</tr>
</tbody></table>
<p>例如，要限制与 USB 连接媒体的匹配，您可以创建一个匹配字典，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFMutableDictionaryRef matchingDict =</span><br><span class="line">    CFDictionaryCreateMutable(</span><br><span class="line">        kCFAllocatorDefault,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">        &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"> </span><br><span class="line">CFDictionaryAddValue(matchingDict,</span><br><span class="line">    kDADiskDescriptionDeviceProtocolKey,</span><br><span class="line">    CFSTR(kIOPropertyPhysicalInterconnectTypeUSB));</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/kernel/kiopropertyphysicalinterconnecttypeusb">IOStorageProtocolCharacteristics.h User-Space Reference</a>中描述了其他互连类型和其他相关常量。最后，只要磁盘事件与指定的匹配字典（或多个字典）和使用上下文指针的事件类型匹配，您就可以将任意数据传递给回调。通过传递不同的上下文指针，您可以使用不同的匹配字典多次注册相同的回调，并向回调提供指示哪个注册匹配的信息。如果您不需要提供此类上下文信息，只需传递NULL此参数即可。</p>
<p>每个回调的详细信息在以下部分中有更详细的描述。</p>
<h3 id="注销通回调"><a href="#注销通回调" class="headerlink" title="注销通回调"></a>注销通回调</h3><p>当您不再需要通知回调时，通过调用取消注册 <code>DAUnregisterCallback</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DAUnregisterCallback(session, mycallbackfuntion, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>请务必传入注册函数时使用的原始上下文指针值</strong>。</p>
<h3 id="批准回调"><a href="#批准回调" class="headerlink" title="批准回调"></a>批准回调</h3><p>通过三种方式在磁盘仲裁中注册批准回调，具体取决于您希望何时收到通知。</p>
<ul>
<li>如果您希望在弹出磁盘之前获得许可，请调用 <code>DARegisterDiskEjectApprovalCallback</code>.</li>
<li>如果您希望在安装卷之前获得许可，请调用 <code>DARegisterDiskMountApprovalCallback</code>.</li>
<li>如果您希望在卸载卷之前获得许可，请调用 <code>DARegisterDiskUnmountApprovalCallback</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DADissenterRef <span class="title function_">allow_mount</span><span class="params">(DADiskRef disk, <span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">session = DASessionCreate(kCFAllocatorDefault);</span><br><span class="line"> </span><br><span class="line">DARegisterDiskMountApprovalCallback(session,</span><br><span class="line">                <span class="literal">NULL</span>, <span class="comment">/* Match all disks */</span></span><br><span class="line">                allow_mount,</span><br><span class="line">                <span class="literal">NULL</span>); <span class="comment">/* No context */</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">DADissenterRef <span class="title function_">allow_mount</span><span class="params">(</span></span><br><span class="line"><span class="params">        DADiskRef disk,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> allow = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (allow) &#123;</span><br><span class="line">                <span class="comment">/* Return NULL to allow */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;allow_mount: allowing mount.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Return a dissenter to deny */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;allow_mount: refusing mount.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> DADissenterCreate(</span><br><span class="line">                        kCFAllocatorDefault, kDAReturnExclusiveAccess,</span><br><span class="line">                        CFSTR(<span class="string">&quot;It&#x27;s mine!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注销批准回调"><a href="#注销批准回调" class="headerlink" title="注销批准回调"></a>注销批准回调</h3><p>当您不再需要批准回调时，您应该通过调用取消注册 <code>DAUnregisterApprovalCallback</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DAUnregisterApprovalCallback(session, mycallbackfuntion, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>请务必传入注册函数时使用的原始上下文指针值</strong>。</p>
<h2 id="使用调度队列"><a href="#使用调度队列" class="headerlink" title="使用调度队列"></a>使用调度队列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Schedule the session on a dispatch queue. */</span></span><br><span class="line">DASessionSetDispatchQueue(session, <span class="built_in">queue</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Unschedule the session on a dispatch queue. */</span></span><br><span class="line">DASessionSetDispatchQueue(session, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Clean up the session resources. */</span></span><br><span class="line">CFRelease(session);</span><br></pre></td></tr></table></figure>
<h2 id="使用运行循环"><a href="#使用运行循环" class="headerlink" title="使用运行循环"></a>使用运行循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Schedule a disk arbitration session. */</span></span><br><span class="line">DASessionScheduleWithRunLoop(session, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Start the run loop.  (Don&#x27;t do this if you already have</span></span><br><span class="line"><span class="comment">   a running Core Foundation or Cocoa run loop.) */</span></span><br><span class="line">CFRunLoopRun();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Clean up a session. */</span></span><br><span class="line">DASessionUnscheduleFromRunLoop(session,</span><br><span class="line">    CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</span><br><span class="line">CFRelease(session);</span><br></pre></td></tr></table></figure>

<h1 id="操作磁盘和卷"><a href="#操作磁盘和卷" class="headerlink" title="操作磁盘和卷"></a>操作磁盘和卷</h1><h2 id="获取磁盘对象"><a href="#获取磁盘对象" class="headerlink" title="获取磁盘对象"></a>获取磁盘对象</h2><p>在您可以操作磁盘或卷之前，您必须<code>DADiskRef</code>为该磁盘或卷获取一个对象。通过四种方式获取对象：</p>
<ul>
<li>作为传递给事件回调的参数（在使用磁盘仲裁通知和批准回调中描述）</li>
<li>通过调用从 <code>io_service_t</code>用户空间引用到有效设备切片的对象 <code>IOMediaDADiskCreateFromIOMedia</code></li>
<li>您可以通过调用或io_service_t来获取对象的用户空间引用。</li>
<li>从 <code>BSD</code> 设备名称（disk1s1例如）使用 <code>DADiskCreateFromBSDName</code></li>
<li>从挂载点调用 <code>DADiskCreateFromVolumePath</code></li>
</ul>
<p>如果您有一个<code>io_service_t</code>对象或一个 <code>BSD</code> 设备名称，您的应用程序可以创建一个<code>DADiskRef</code>对象，如下所示：</p>
<p><code>DASessionRef</code>按照创建会话中的描述创建一个对象。</p>
<ul>
<li>按照<code>Scheduling the Session with the Run Loop or Dispatch Queue</code>中的描述安排它。确保您的调度队列或运行循环正在运行。</li>
<li>创建磁盘对象。</li>
<li>根据需要操纵它们。</li>
</ul>
<h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><p>盘仲裁提供三个函数来获取有关磁盘和分区的附加信息：<code>DADiskCopyDescription</code> 、<code>DADiskGetBSDName</code> 和<code>DADiskCopyIOMedia</code>。通常，您可以通过调用 获得关于特定磁盘的几乎所有信息 <code>DADiskCopyDescription</code>。然而，对于一些相当深奥的信息，您可能必须<code>IOMedia</code>为磁盘获取一个对象并查询该对象。</p>
<p>如果您需要磁盘或分区的 <code>BSD</code> 设备名称（<code>disk1s1</code>例如）作为 <code>C</code> 字符串（通常在使用 <code>POSIX</code> 级 <code>API</code> 时使用），请调用 <code>DADiskGetBSDName</code>.<br>对于大多数其他信息，请调用<code>DADiskCopyDescription</code>，如获取描述字典中所述。<br>如果无法通过 获得您需要的信息 <code>DADiskCopyDescription</code>，请调用DADiskCopyIOMedia。</p>
<h3 id="获取描述字典"><a href="#获取描述字典" class="headerlink" title="获取描述字典"></a>获取描述字典</h3><p><code>DADiskCopyDescription</code>方法返回一个 <code>CFDictionaryRef</code> 对象，其中包含有关磁盘或分区的几十条信息。一些常用的数据包括：</p>
<ul>
<li>挂载点和卷名</li>
<li><code>BSD</code> 设备节点名称和主要和次要编号</li>
<li>有关硬件的信息（<code>设备 ID</code> 、<code>供应商 ID</code> 、<code>GUID</code> 等）</li>
<li>连接信息（总线名称和路径</li>
</ul>
<p>您可以在磁盘仲裁框架的标头中找到完整的属性列表 <a href="https://developer.apple.com/documentation/diskarbitration/dadisk_h?language=objc">DADisk.h Reference.</a>，以及每个键值的预期数据类型的描述。</p>
<h3 id="从-I-O-Kit-获取附加信息"><a href="#从-I-O-Kit-获取附加信息" class="headerlink" title="从 I/O Kit 获取附加信息"></a>从 <code>I/O Kit</code> 获取附加信息</h3><p>在极少数情况下，您可能需要获取有关磁盘的其他信息，而不是磁盘仲裁提供的信息。如果这样做，您可以调用<code>DADiskCopyIOMedia</code>以获取一个 <code>io_service_t</code>对象，该对象是对象的用户空间表示 <code>IOMedia</code>。您可以像操作任何 <code>I/O Registry</code> 对象一样操作此对象。</p>
<p>例如，您可以通过调用 <code>IORegistryEntryCreateCFProperties</code>结果对象来获取具有媒体 <code>I/O</code> 注册表属性的 <code>Core Foundation</code> 字典。</p>
<p><code>I/O Registry</code> 字典中的属性在 <code>I/O Kit Framework</code> 中定义。有关详细信息，请参阅<a href="https://developer.apple.com/documentation/iokit">I&#x2F;O Kit Framework Reference</a>。</p>
<h2 id="安装和卸载卷"><a href="#安装和卸载卷" class="headerlink" title="安装和卸载卷"></a>安装和卸载卷</h2><ul>
<li><p><code>DADiskMount</code></p>
</li>
<li><p><code>DADiskMountWithArguments</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *mppath = <span class="string">&quot;/mnt/mydisk&quot;</span>;</span><br><span class="line"></span><br><span class="line">path = CFURLCreateFromFileSystemRepresentation(</span><br><span class="line">    kCFAllocatorDefault,</span><br><span class="line">    mppath,</span><br><span class="line">    <span class="built_in">strlen</span>(mppath),</span><br><span class="line">    <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">DADiskMountWithArguments(disk, path, kDADiskMountOptionDefault,</span><br><span class="line">    mount_complete_callback, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>DADiskUnmount</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">DADissenterRef dissenter,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">DADiskUnmount(disk, kDADiskUnmountOptionDefault,</span><br><span class="line">    unmount_done, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        <span class="comment">/* Unmount failed. */</span></span><br><span class="line">        <span class="type">char</span> buf[MAXPATHLEN];</span><br><span class="line">        <span class="keyword">if</span> (CFURLGetFileSystemRepresentation(fspath, <span class="literal">false</span>, (UInt8 *)buf, <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unmount failed (Error: 0x%x Reason: %s).  Retrying.\n&quot;</span>,</span><br><span class="line">                DADissenterGetStatus(dissenter),</span><br><span class="line">                buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Something is *really* wrong. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Do something. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="弹出磁盘"><a href="#弹出磁盘" class="headerlink" title="弹出磁盘"></a>弹出磁盘</h2><p>在弹出磁盘之前，您必须卸载磁盘上的所有卷。首先调用 <code>DADiskUnmount</code>，将整个磁盘分区作为磁盘参数传递，并<code>kDADiskUnmountOptionWhole</code> 在卸载选项中设置标志。然后调用 <code>DADiskEject</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eject_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Unmount all volumes */</span></span><br><span class="line">DADiskRef wholedisk = DADiskCopyWholeDisk(partition);</span><br><span class="line">DADiskUnmount(wholedisk, kDADiskUnmountOptionWhole,</span><br><span class="line">    unmount_done, <span class="literal">NULL</span>);</span><br><span class="line">CFRelease(wholedisk);</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* In the unmount callback, eject the volume. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DADiskEject(disk, kDADiskEjectOptionDefault,</span><br><span class="line">            eject_done, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Eject callback. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eject_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/DriversKernelHardware/Conceptual/DiskArbitrationProgGuide/">Disk Arbitration Programming Guide</a></li>
</ul>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Disk</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS平台上符号化崩溃报告</title>
    <url>/2022/07/26/macos/%E5%9C%A8MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="dSYM"><a href="#dSYM" class="headerlink" title=".dSYM"></a><code>.dSYM</code></h1><p><code>.dSYM</code> (<code>debugging SYMbols</code>) 又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的 <code>DWARF</code>（<code>Debugging With Attributed Record Formats</code>），其在.xcarchive目录中的层次结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.xcarchive</span><br><span class="line">--dSYMs</span><br><span class="line">  |--Your.app.dSYM</span><br><span class="line">    |--Contents</span><br><span class="line">      |--Resources</span><br><span class="line">        |--DWARF</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果在XCode中设置了带有 <code>dSYM</code> 文件的 <code>DWARF</code> 选项，则编译器会生成 <code>dSYM</code> 文件，并将其存储在您的构建中。<br><img src="/images/dsym.png"></p>
<h1 id="确定符号表和崩溃日志的一致性"><a href="#确定符号表和崩溃日志的一致性" class="headerlink" title="确定符号表和崩溃日志的一致性"></a>确定符号表和崩溃日志的一致性</h1><h2 id="崩溃日志中获取UUID"><a href="#崩溃日志中获取UUID" class="headerlink" title="崩溃日志中获取UUID"></a>崩溃日志中获取UUID</h2><p>崩溃日志比较靠下的位置有个 <code>Binary Images</code> 模块，其第一行内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x109724000 - 0x109cf7fff Your &lt;19a667b1-8910-3890-a0b0-03befee8876e&gt; /Library/Application Support/YourApp/*/YourApp.app/Contents/MacOS/YourApp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>代码段的起终地址: <code>0x109724000 - 0x109cf7fff</code></li>
<li>应用的UUID：<code>19a667b1-8910-3890-a0b0-03befee8876e</code>（不区分大小写）</li>
</ul>
<h2 id="从符号表中获取UUID"><a href="#从符号表中获取UUID" class="headerlink" title="从符号表中获取UUID"></a>从符号表中获取UUID</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --uuid Your.app.dSYM</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --uuid Your.app.dSYM/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure>

<p><strong>崩溃日志中和符号表中的UUID一致，才能正确解析</strong></p>
<h1 id="计算崩溃符号表地址"><a href="#计算崩溃符号表地址" class="headerlink" title="计算崩溃符号表地址"></a>计算崩溃符号表地址</h1><h2 id="符号表堆栈地址计算方式"><a href="#符号表堆栈地址计算方式" class="headerlink" title="符号表堆栈地址计算方式"></a>符号表堆栈地址计算方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 0::  Dispatch queue: com.apple.main-thread</span><br><span class="line">0   libsystem_kernel.dylib        	    0x7ff8159e775e write + 10</span><br><span class="line">1   libapr-1.0.dylib              	    0x10a6c1cee apr_file_write + 286</span><br><span class="line">2   liblog4cxx.10.0.0.dylib       	    0x10a369531 log4cxx::helpers::FileOutputStream::write(log4cxx::helpers::ByteBuffer&amp;, log4cxx::helpers::Pool&amp;) + 81</span><br><span class="line">3   Your      	                        0x10a3ae877❶  0x10a340000❷ + 452727❸</span><br></pre></td></tr></table></figure>

<ul>
<li>❶ 运行时堆栈地址 </li>
<li>❷ 运行时起始地址</li>
<li>❸ 偏移量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时堆栈地址 = 运行时起始地址 + 偏移量</span><br></pre></td></tr></table></figure>

<p>崩溃堆栈中的起始地址和崩溃地址均为运行时地址，根据虚拟内存偏移量不变原理，只要提供了符号表TEXT段的起始地址，再加上偏移量就能得到符号表中的堆栈地址，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">符号表堆栈地址 = 符号表起始地址 + 偏移量</span><br></pre></td></tr></table></figure>

<h2 id="符号表中TEXT段的起始地址可以通过以下命令获得："><a href="#符号表中TEXT段的起始地址可以通过以下命令获得：" class="headerlink" title="符号表中TEXT段的起始地址可以通过以下命令获得："></a>符号表中TEXT段的起始地址可以通过以下命令获得：</h2><p>使用 <code>otool</code> 查找 <code>LC_SEGMENT_64</code> 段和 <code>vmaddr</code> 条目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ otool -l Your.app.dSYM/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load command 4</span><br><span class="line">      cmd LC_SEGMENT_64</span><br><span class="line">  cmdsize 232</span><br><span class="line">  segname __TEXT</span><br><span class="line">   vmaddr 0x0000000100000000·</span><br><span class="line">   vmsize 0x0000000000004000</span><br><span class="line">  fileoff 0</span><br><span class="line"> filesize 0</span><br><span class="line">  maxprot 0x00000005</span><br><span class="line"> initprot 0x00000005</span><br><span class="line">   nsects 2</span><br><span class="line">    flags 0x0</span><br></pre></td></tr></table></figure>
<p>其中的<code>vmaddr 0x0000000100000000</code>字段即为TEXT段的起始地址。</p>
<h1 id="使用-LLDB-进行符号化"><a href="#使用-LLDB-进行符号化" class="headerlink" title="使用 LLDB 进行符号化"></a>使用 <code>LLDB</code> 进行符号化</h1><h2 id="crashlog"><a href="#crashlog" class="headerlink" title="crashlog"></a>crashlog</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xcrun lldb</span><br><span class="line"></span><br><span class="line">(lldb) command script import lldb.macosx.crashlog</span><br><span class="line"></span><br><span class="line">(lldb) crashlog &lt;path/to/crashlog.crash&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(lldb) target create --no-dependents --arch &lt;architecture&gt; &lt;path/to/dSYMs/App.app.dSYM/Contents/Resources/DWARF/App&gt;</span><br><span class="line"></span><br><span class="line">(lldb) image lookup --address &lt;symboladdress&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-ATOS-符号化"><a href="#使用-ATOS-符号化" class="headerlink" title="使用 ATOS 符号化"></a>使用 <code>ATOS</code> 符号化</h1><h2 id="符号表崩溃地址的解析方式"><a href="#符号表崩溃地址的解析方式" class="headerlink" title="符号表崩溃地址的解析方式"></a>符号表崩溃地址的解析方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; -l &lt;load address&gt; &lt;stack address 1&gt; &lt;stack address 2&gt; ...</span><br></pre></td></tr></table></figure>

<h2 id="无需符号表崩溃地址的解析方式"><a href="#无需符号表崩溃地址的解析方式" class="headerlink" title="无需符号表崩溃地址的解析方式"></a>无需符号表崩溃地址的解析方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; &lt;symboladdress&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-Dwarfdump-符号化"><a href="#使用-Dwarfdump-符号化" class="headerlink" title="使用 Dwarfdump 符号化"></a>使用 <code>Dwarfdump</code> 符号化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --arch x86_64 Your.app.dSYM --lookup symboladdress</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 之 焦点处理</title>
    <url>/2023/02/15/qt/Qt-%E4%B9%8B-%E7%84%A6%E7%82%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h1><p>当焦点从一个 <code>widget</code> 移动到另一个 <code>widget</code> 时，会触发 <code>QFocusEvent</code> 事件，这个事件会被发送给原焦点窗口和当前焦点窗口，原焦点窗口执行 <code>focusOutEvent()</code> ，新焦点窗口执行 <code>focusInEvent()</code>。 相关函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusInEvent</span><span class="params">(QFocusEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusOutEvent</span><span class="params">(QFocusEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="焦点策略"><a href="#焦点策略" class="headerlink" title="焦点策略"></a>焦点策略</h1><p>只有<strong>可获取焦点</strong>的窗口，才有机会成为焦点窗口。比如<code>QWidget</code> 默认策略是 <code>Qt::NoFocus</code> 所以 QWidget 默认不获取焦点。Qt提供了如下接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocusPolicy</span><span class="params">(Qt::FocusPolicy policy)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="enum-Qt-FocusPolicy"><a href="#enum-Qt-FocusPolicy" class="headerlink" title="enum Qt::FocusPolicy"></a>enum Qt::FocusPolicy</h2><table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt::TabFocus</td>
<td align="left">0x1</td>
<td align="left">the widget accepts focus by tabbing.</td>
</tr>
<tr>
<td align="left">Qt::ClickFocus</td>
<td align="left">0x2</td>
<td align="left">the widget accepts focus by clicking.</td>
</tr>
<tr>
<td align="left">Qt::StrongFocus</td>
<td align="left">TabFocus &amp;#124; ClickFocus &amp;#124; 0x8</td>
<td align="left">the widget accepts focus by both tabbing and clicking. On macOS this will also be indicate that the widget accepts tab focus when in ‘Text&#x2F;List focus mode’.</td>
</tr>
<tr>
<td align="left">Qt::WheelFocus</td>
<td align="left">StrongFocus &amp;#124; 0x4</td>
<td align="left">like Qt::StrongFocus plus the widget accepts focus by using the mouse wheel.</td>
</tr>
<tr>
<td align="left">Qt::NoFocus</td>
<td align="left">0</td>
<td align="left">the widget does not accept focus.</td>
</tr>
</tbody></table>
<h1 id="焦点原因"><a href="#焦点原因" class="headerlink" title="焦点原因"></a>焦点原因</h1><h3 id="Qt-FocusReason"><a href="#Qt-FocusReason" class="headerlink" title="Qt::FocusReason"></a>Qt::FocusReason</h3><table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt::MouseFocusReason</td>
<td align="left">0</td>
<td align="left">A mouse action occurred.</td>
</tr>
<tr>
<td align="left">Qt::TabFocusReason</td>
<td align="left">1</td>
<td align="left">The Tab key was pressed.</td>
</tr>
<tr>
<td align="left">Qt::BacktabFocusReason</td>
<td align="left">2</td>
<td align="left">A Backtab occurred. The input for this may include the Shift or Control keys; e.g. Shift+Tab.</td>
</tr>
<tr>
<td align="left">Qt::ActiveWindowFocusReason</td>
<td align="left">3</td>
<td align="left">The window system made this window either active or inactive.</td>
</tr>
<tr>
<td align="left">Qt::PopupFocusReason</td>
<td align="left">4</td>
<td align="left">The application opened&#x2F;closed a pop-up that grabbed&#x2F;released the keyboard focus.</td>
</tr>
<tr>
<td align="left">Qt::ShortcutFocusReason</td>
<td align="left">5</td>
<td align="left">The user typed a label’s buddy shortcut</td>
</tr>
<tr>
<td align="left">Qt::MenuBarFocusReason</td>
<td align="left">6</td>
<td align="left">The menu bar took focus.</td>
</tr>
<tr>
<td align="left">Qt::OtherFocusReason</td>
<td align="left">7</td>
<td align="left">Another reason, usually application-specific.</td>
</tr>
</tbody></table>
<h1 id="焦点信号"><a href="#焦点信号" class="headerlink" title="焦点信号"></a>焦点信号</h1><p><code>QApplication</code> 的信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusChanged</span><span class="params">(QWidget *old, QWidget *now)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="焦点次序"><a href="#焦点次序" class="headerlink" title="焦点次序"></a>焦点次序</h1><p>相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回此部件焦点链中的下一个部件</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::nextInFocusChain</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 返回此部件焦点链中的前一个部件</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::previousInFocusChain</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将焦点顺序中的部件 second 放置在部件 first 之后</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setTabOrder</span><span class="params">(QWidget *, QWidget *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过按 <code>Tab</code> 或者 <code>Shift+Tab</code>，可以实现焦点在各个窗口之间循环移动。</p>
<ul>
<li><p>点击 <code>Tab</code> 键，焦点向后查找，直至找到第一个 <code>FocusPolicy</code> 大于等于 <code>TabFocus</code> 的窗口，并设置该窗口为焦点窗口;</p>
</li>
<li><p>点击 <code>Shift+Tab</code> ，焦点向前查找，直至找到第一个 <code>FocusPolicy</code>  大于等于 <code>TabFocus</code> 的窗口，并设置该窗口为焦点窗口;</p>
</li>
</ul>
<p>默认情况下, 先加入的 <code>QWidget</code> 焦点顺序越靠前。可以通过 <code>setTabOrder</code> 调整顺序.</p>
<p>比如，若默认的焦点链顺序为 <code>a-b-c-d</code> ，则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTabOrder(d,c); //改变后焦点链的顺序为 a-b-d-c</span><br><span class="line">setTabOrder(b,a); //改变后焦点链的顺序为 b-a-d-c</span><br></pre></td></tr></table></figure>

<h1 id="焦点切换"><a href="#焦点切换" class="headerlink" title="焦点切换"></a>焦点切换</h1><p>相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于focusNextPrevChild(true)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusNextChild</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 等同于focusNextPrevChild(false)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusPreviousChild</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// next==true：设置焦点链中下个`FocusPolicy`为`TabFocus`的窗口为焦点窗口</span></span><br><span class="line"><span class="comment">// next==false：设置焦点链中前一个`FocusPolicy`为`TabFocus`的窗口为焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusNextPrevChild</span><span class="params">(<span class="type">bool</span> next)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口为焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocus</span><span class="params">(Qt::FocusReason reason)</span></span>;</span><br><span class="line"><span class="comment">// 取消焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::clearFocus</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="焦点代理"><a href="#焦点代理" class="headerlink" title="焦点代理"></a>焦点代理</h1><p>代为接收焦点事件。比如，<code>Widget A</code> 是 <code>Widget B</code> 的焦点代理，则当 <code>B</code> 获得焦点时，实际获得并处理焦点的是 <code>A</code>。相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回该窗口的焦点代理</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::focusProxy</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">//设置该窗口的焦点代理为w</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocusProxy</span><span class="params">(QWidget* w)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>焦点</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
