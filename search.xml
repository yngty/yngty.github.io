<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 中 malloc 和 new 的区别</title>
    <url>/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">new</th>
<th align="center">malloc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">关键字</td>
<td align="center">标准库函数</td>
</tr>
<tr>
<td align="center">支持语言</td>
<td align="center"><code>C/C++</code></td>
<td align="center">只在 <code>C++</code></td>
</tr>
<tr>
<td align="center">申请内存的位置</td>
<td align="center">自由存储区 <code>free store</code></td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">分配内存的大小</td>
<td align="center">编译器根据类型信息自行计算</td>
<td align="center">显示指定字节数</td>
</tr>
<tr>
<td align="center">内存分配失败</td>
<td align="center">抛出 <code>bac_alloc</code> 异常, 不会返回 <code>NULL</code></td>
<td align="center">返回 <code>NULL</code></td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">返回对象类型的指针</td>
<td align="center">返回<code>void</code> 指针，需要转换</td>
</tr>
<tr>
<td align="center">是否调用构造函数&#x2F;析构函数</td>
<td align="center">调用</td>
<td align="center">不调用</td>
</tr>
<tr>
<td align="center">处理数组</td>
<td align="center"><code>new[]</code></td>
<td align="center">手动指定数组的大小</td>
</tr>
<tr>
<td align="center">是否支持重载</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">是否支持内存扩充</td>
<td align="center">不支持</td>
<td align="center"><code>realloc</code></td>
</tr>
<tr>
<td align="center">内存释放方式</td>
<td align="center"><code>new/delete</code>, <code>new[]/delete[]</code></td>
<td align="center"><code>malloc/free</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>enable_shared_from_this的注意事项</title>
    <url>/2023/03/11/c++/enable-shared-from-this%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>当我们在对象函数中需要返回或者使用自己的 <code>shared_ptr</code> 指针时，该怎么办呢？常见的错误写法如下：用不安全的表达式试图获得 <code>this</code> 的 <code>shared_ptr</code> 对象, 但可能会导致 <code>this</code> 被多个互不知晓的所有者析构.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1 = std::<span class="built_in">make_shared</span>&lt;Bad&gt;();</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;<span class="built_in">getptr</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp2.use_count() = &quot;</span> &lt;&lt; bp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; <span class="comment">// UB: Bad 对象将会被删除两次</span></span><br></pre></td></tr></table></figure>
<p>正确写法是将定义对象公开继承 <code>enable_shared_from_this</code>: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Good&gt; <span class="comment">// 注意：继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>std::enable_shared_from_this</code> 能让其一个对象（假设其名为 <code>t</code> ，且已被一个 <code>std::shared_ptr</code> 对象 <code>pt</code> 管理）安全地生成其他额外的 <code>std::shared_ptr</code> 实例（假设名为 <code>pt1</code>, <code>pt2</code>, … ） ，它们与 <code>pt</code> 共享对象 <code>t</code>的所有权。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><code>enable_shared_from_this</code> 的常见实现为：其内部保存着一个对 <code>this</code> 的弱引用（例如 <code>std::weak_ptr</code> )。 <code>std::shared_ptr</code> 的构造函数发现是并能访问 <code>enable_shared_from_this</code> 的基类，并且若内部存储的弱引用未生成。则 <code>std::shared_ptr</code> 生成内部存储的弱引用。 <code>libc++</code> 的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> enable_shared_from_this</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; __weak_this_;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__weak_this_);&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp <span class="type">const</span>&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Tp&gt;(__weak_this_);&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code> 的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> = <span class="type">__enable_if_t</span>&lt;</span><br><span class="line">        _And&lt;</span><br><span class="line">            __raw_pointer_compatible_with&lt;_Yp, _Tp&gt;</span><br><span class="line">            <span class="comment">// In C++03 we get errors when trying to do SFINAE with the</span></span><br><span class="line">            <span class="comment">// delete operator, so we always pretend that it&#x27;s deletable.</span></span><br><span class="line">            <span class="comment">// The same happens on GCC.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_LIBCPP_CXX03_LANG) &amp;&amp; !defined(_LIBCPP_COMPILER_GCC)</span></span><br><span class="line">            , _If&lt;is_array&lt;_Tp&gt;::value, __is_array_deletable&lt;_Yp*&gt;, __is_deletable&lt;_Yp*&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &gt;::value</span><br><span class="line">    &gt; &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(_Yp* __p) : __ptr_(__p) &#123;</span><br><span class="line">        unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">        <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT&gt; _CntrlBlk;</span><br><span class="line">        __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());</span><br><span class="line">        __hold.<span class="built_in">release</span>();</span><br><span class="line">        __enable_weak_this(__p, __p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_OrigPtr</span>, <span class="keyword">class</span> = <span class="type">__enable_if_t</span>&lt;</span><br><span class="line">        is_convertible&lt;_OrigPtr*, <span class="type">const</span> enable_shared_from_this&lt;_Yp&gt;*&gt;::value</span><br><span class="line">    &gt; &gt;</span><br><span class="line">    _LIBCPP_HIDE_FROM_ABI</span><br><span class="line">    <span class="type">void</span> __enable_weak_this(<span class="type">const</span> enable_shared_from_this&lt;_Yp&gt;* __e, _OrigPtr* __ptr) _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">__remove_cv_t</span>&lt;_Yp&gt; _RawYp;</span><br><span class="line">        <span class="keyword">if</span> (__e &amp;&amp; __e-&gt;__weak_this_.<span class="built_in">expired</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            __e-&gt;__weak_this_ = <span class="built_in">shared_ptr</span>&lt;_RawYp&gt;(*<span class="keyword">this</span>,</span><br><span class="line">                <span class="built_in">const_cast</span>&lt;_RawYp*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Yp*&gt;(__ptr)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>c++17</code> 前对没初始化的 <code>weak_ptr</code> 的对象调用 <code>shared_from_this</code> 行为未定义行,  <code>C++17</code> 起抛出 <code>std::bad_weak_ptr</code> 异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Good not_so_good;</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1 = not_so_good.<span class="built_in">getptr</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span>(std::bad_weak_ptr&amp; e) &#123;</span><br><span class="line">    <span class="comment">// C++17 前为未定义行为； C++17 起抛出 std::bad_weak_ptr 异常</span></span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="什么时候初始化-enable-shared-from-this-中的-weak-ptr？"><a href="#什么时候初始化-enable-shared-from-this-中的-weak-ptr？" class="headerlink" title="什么时候初始化 enable_shared_from_this 中的 weak_ptr？"></a>什么时候初始化 <code>enable_shared_from_this</code> 中的 <code>weak_ptr</code>？</h2><p>参考实现部分，构造 <code>shared_ptr</code> 的对象时判断是 <code>enable_shared_from_this</code>的时候会初始化。</p>
<h2 id="能不能非公有继承-enable-shared-from-this-？"><a href="#能不能非公有继承-enable-shared-from-this-？" class="headerlink" title="能不能非公有继承 enable_shared_from_this ？"></a>能不能非公有继承 <code>enable_shared_from_this</code> ？</h2><p><strong>不能</strong></p>
<p>非公有继承时候，判断 <code>class</code> 是否是 <code>enable_shared_from_this</code> 会失败就不会去初始化 <code>weak_ptr</code>。</p>
<h2 id="能不能在构造函数中调用？"><a href="#能不能在构造函数中调用？" class="headerlink" title="能不能在构造函数中调用？"></a>能不能在构造函数中调用？</h2><p><strong>不能</strong></p>
<p><code>shared_ptr</code> 初始化需要调用构造函数，而 <code>weak_ptr</code> 需要 <code>shared_ptr</code> 构造初始化。<code>GG</code> 了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>shared_ptr</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>std::make_shared vs. new</title>
    <url>/2023/02/07/c++/std-make-shared-vs-new/</url>
    <content><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p><code>std::make_shared</code> 执行<strong>一次</strong>堆分配，而调用<code>std::shared_ptr</code> 构造函数执行<strong>两次</strong>。</p>
<p>在一个典型的实现中 <code>std::shared_ptr</code> 管理两个实体：</p>
<ul>
<li>控制块（存储元数据，如引用计数、类型擦除删除器等）</li>
<li>被管理的对象</li>
</ul>
<p>控制块是一个动态分配的对象，它包含：</p>
<ul>
<li>指向托管对象的指针或托管对象本身；</li>
<li>删除器 (类型擦除)</li>
<li>分配器 (类型擦除)</li>
<li>拥有被管理对象的 <code>shared_ptr</code>的数量</li>
<li>引用托管对象的 <code>weak_ptr</code> 的数量</li>
</ul>
<p><code>std::make_shared</code>执行一次堆分配，计算控制块和数据所需的总空间。在另一种情况 <code>std::shared_ptr&lt;Obj&gt;(new Obj(&quot;foo&quot;))</code>下执行两次, <code>new Obj(&quot;foo&quot;)</code>为托管数据调用堆分配，<code>std::shared_ptr</code>构造函数为控制块执行另一个堆分配。</p>
<span id="more"></span>

<h1 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h1><p><strong>自 <code>C++17</code> 以来，这不是问题，因为函数参数的评估顺序发生了变化。具体来说，函数的每个参数都需要在评估其他参数之前完全执行</strong>。</p>
<p>考虑这个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(std::shared_ptr&lt;int&gt;(new int(42)), g())</span><br></pre></td></tr></table></figure>
<p>因为 C++ 允许对子表达式进行任意顺序的计算，所以一种可能的顺序是：</p>
<ol>
<li><code>new int(42)</code></li>
<li><code>g()</code></li>
<li><code>std::shared_ptr&lt;int&gt;</code></li>
</ol>
<p>现在，假设我们在第 <code>2</code> 步抛出一个异常。然后我们丢失了在步骤 <code>1</code> 分配的内存，因为没有将原始指针传给 <code>std::shared_ptr</code>, 后面没有任何东西有机会清理它。</p>
<p>解决这个问题的一种方法是在不同的行上执行它们，这样就不会发生这种任意排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto ptr = std::shared_ptr&lt;int&gt;(new int(42));</span><br><span class="line">f(ptr, g());</span><br></pre></td></tr></table></figure>

<p>更方便的的是采用 <code>std::make_shared</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(std::make_shared&lt;int&gt;(42), g())</span><br></pre></td></tr></table></figure>

<h1 id="std-make-shared-的一些缺点"><a href="#std-make-shared-的一些缺点" class="headerlink" title="std::make_shared 的一些缺点"></a><code>std::make_shared</code> 的一些缺点</h1><h2 id="weak-ptr内存保活"><a href="#weak-ptr内存保活" class="headerlink" title="weak_ptr内存保活"></a><code>weak_ptr</code>内存保活</h2><ul>
<li>通过 <code>std::make_shared</code> 构造的智能指针, 当没有 <code>shared_ptr</code> 引用计数为 <code>0</code> 时只调用析构函数，<code>weak_ptr</code>引用计数为 <code>0</code> 时才释放内存块。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> logging = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (logging) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Allocated: &quot;</span> &lt;&lt; (<span class="type">uintptr_t</span>)ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> <span class="keyword">noexcept</span>  </span>&#123;</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (logging) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deallocated: &quot;</span> &lt;&lt; (<span class="type">uintptr_t</span>)ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget::~Widget()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span> </span>&#123;</span><br><span class="line">    logging = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="literal">true</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated: 105553162522944 //分配一次</span><br><span class="line">Widget::~Widget() // 没有 shared_ptr 指针，只调用析构函数</span><br><span class="line">No std::shared_ptr&#x27;s anymore.</span><br><span class="line">Deallocated: 105553162522944 //没有 `weak_ptr` 释放整个内存块</span><br><span class="line">No std::weak_ptr&#x27;s anymore.</span><br><span class="line">---------------------</span><br><span class="line">Allocated: 105553164599312</span><br><span class="line">Allocated: 105553162522944 //分配两次</span><br><span class="line">Widget::~Widget()</span><br><span class="line">Deallocated: 105553164599312 //立即释放</span><br><span class="line">No std::shared_ptr&#x27;s anymore.</span><br><span class="line">Deallocated: 105553162522944</span><br><span class="line">No std::weak_ptr&#x27;s anymore.</span><br></pre></td></tr></table></figure>

<h2 id="无法访问公共构造函数"><a href="#无法访问公共构造函数" class="headerlink" title="无法访问公共构造函数"></a>无法访问公共构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">val</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make_shared 无法调用 A(int) </span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;A&gt; createNext()&#123; </span></span><br><span class="line">    <span class="comment">//     return std::make_shared&lt;A&gt;(val+1); </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以调用 A(int) </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">createNext</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(val+<span class="number">1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v): <span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">Difference in make_shared and normal shared_ptr in C++</a></li>
<li><a href="https://www.gamedev.net/forums/topic/695796-stdmake_shared-vs-new/">std::make_shared 与 new</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr/make_shared#Notes">make_shared#Notes</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>可变参数模板</title>
    <url>/2023/04/10/c++/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="可变参数模板的需求"><a href="#可变参数模板的需求" class="headerlink" title="可变参数模板的需求"></a>可变参数模板的需求</h1><ul>
<li>要在模板参数列表中指定一组参数，如 <code>typename...Args</code>，这称为模板参数包。可以为类型模 板、非类型模板和双重模板参数定义的模板参数包。</li>
<li>函数参数列表中指定一组参数，如 <code>Args...args</code>，这称为函数参数包。</li>
<li>函数体中展开包，如在 <code>args...</code> 中，可在 <code>min(args...)</code> 中看到，这称为参数包展开。这种展开的<br>结果是一个由零个或多个值 (或表达式) 组成的逗号分隔列表。</li>
</ul>
<h1 id="可变参数函数模板"><a href="#可变参数函数模板" class="headerlink" title="可变参数函数模板"></a>可变参数函数模板</h1><h1 id="参数包"><a href="#参数包" class="headerlink" title="参数包"></a>参数包</h1><h1 id="可变参数类模板"><a href="#可变参数类模板" class="headerlink" title="可变参数类模板"></a>可变参数类模板</h1><h1 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h1><h1 id="可变参数别名模板"><a href="#可变参数别名模板" class="headerlink" title="可变参数别名模板"></a>可变参数别名模板</h1><h1 id="可变参数变量模板"><a href="#可变参数变量模板" class="headerlink" title="可变参数变量模板"></a>可变参数变量模板</h1>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 踩坑记</title>
    <url>/2023/04/07/cmake/CMake-%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="install-CODE-和-execute-process-配合"><a href="#install-CODE-和-execute-process-配合" class="headerlink" title="install(CODE) 和 execute_process 配合"></a><code>install(CODE)</code> 和 <code>execute_process</code> 配合</h1><h2 id="确保-WORKING-DIRECTORY-存在"><a href="#确保-WORKING-DIRECTORY-存在" class="headerlink" title="确保 WORKING_DIRECTORY 存在"></a>确保 <code>WORKING_DIRECTORY</code> 存在</h2><p>示例代码: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="keyword">export</span>)</span><br><span class="line"><span class="keyword">install</span>(CODE <span class="string">&quot;</span></span><br><span class="line"><span class="string">    execute_process(COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory folder </span></span><br><span class="line"><span class="string">    WORKING_DIRECTORY \$&#123;CMAKE_INSTALL_PREFIX&#125;)</span></span><br><span class="line"><span class="string">    &quot;</span>) </span><br></pre></td></tr></table></figure>

<p>注意确保 <code>CMAKE_INSTALL_PREFIX</code> 存在，可能执行这段代码时还没有 <code>install target</code> 导致 <code>CMAKE_INSTALL_PREFIX</code> 还没有生成。</p>
<span id="more"></span>

<h2 id="注意变量转义"><a href="#注意变量转义" class="headerlink" title="注意变量转义"></a>注意变量转义</h2><p><strong>不转义容易在 <code>package</code> 时，执行 <code>execute_process</code> 因为路径问题出错</strong>。</p>
<p>示例代码: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="keyword">export</span>)</span><br><span class="line"><span class="keyword">install</span>(CODE <span class="string">&quot;</span></span><br><span class="line"><span class="string">    execute_process(COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory folder</span></span><br><span class="line"><span class="string">    WORKING_DIRECTORY \$&#123;CMAKE_INSTALL_PREFIX&#125;)</span></span><br><span class="line"><span class="string">    &quot;</span>) </span><br></pre></td></tr></table></figure>
<p>注意 <code>$&#123;WORKING_DIRECTORY&#125;</code> 之前是有 <code>\</code> 转义，当没有转义时，<code>CMAKE_INSTALL_PREFIX</code>会直接替换，此时 <code>CMAKE_INSTALL_PREFIX</code> 表示的 <code>install</code> 路径。 <code>make package</code>时会到一个临时目录处理，其中的 <code>CMAKE_INSTALL_PREFIX</code> 跟  <code>install</code> 路径是不一样的，所以执行 <code>execute_process</code> 会出问题。当转义了表示 execute_process时再去获取 <code>CMAKE_INSTALL_PREFIX</code>, 这时能获取到正确路径。可以在 <code>cmake_install.cmake</code> 查看生成的代码。注意 <code>WORKING_DIRECTORY</code> 的值。</p>
<h3 id="不转义生成代码："><a href="#不转义生成代码：" class="headerlink" title="不转义生成代码："></a>不转义生成代码：</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_INSTALL_COMPONENT <span class="keyword">STREQUAL</span> <span class="string">&quot;rel&quot;</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> CMAKE_INSTALL_COMPONENT)</span><br><span class="line">    <span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> /Users/xxx/Qt/Tools/CMake/CMake.app/Contents/bin/cmake -E <span class="keyword">make_directory</span> folder</span><br><span class="line">    WORKING_DIRECTORY <span class="string">&quot;/xxx/xxx/xxxx/export&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>转义生成代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_INSTALL_COMPONENT <span class="keyword">STREQUAL</span> <span class="string">&quot;rel&quot;</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> CMAKE_INSTALL_COMPONENT)</span><br><span class="line">    <span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> /Users/xxx/Qt/Tools/CMake/CMake.app/Contents/bin/cmake -E <span class="keyword">make_directory</span> folder</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h1 id="在-MacOS-上-No-CMAKE-CXX-COMPILER-could-be-found"><a href="#在-MacOS-上-No-CMAKE-CXX-COMPILER-could-be-found" class="headerlink" title="在 MacOS 上 No CMAKE_CXX_COMPILER could be found"></a>在 <code>MacOS</code> 上 <code>No CMAKE_CXX_COMPILER could be found</code></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode.app/Contents/Developer </span><br></pre></td></tr></table></figure>

<h1 id="CMAKE-OSX-ARCHITECTURES"><a href="#CMAKE-OSX-ARCHITECTURES" class="headerlink" title="CMAKE_OSX_ARCHITECTURES"></a>CMAKE_OSX_ARCHITECTURES</h1><ul>
<li>设置 <code>macOS</code>和 <code>iOS</code> 的特定架构</li>
<li>应在第一次 <code>project()</code> 或 <code>enable_language()</code> 命令之前设置</li>
<li>应设置为 <code>CACHE</code> 条目, 除非策略 <code>CMP0126</code> 设置为 <code>NEW</code> </li>
<li>在 <code>Apple</code> 以外的平台上被忽略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (APPLE)</span><br><span class="line">    set(CMAKE_OSX_ARCHITECTURES x86_64 CACHE STRING &quot;&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor pattern</title>
    <url>/2023/03/06/design/reactor-pattern/</url>
    <content><![CDATA[<h1 id="什么是Reactor模式"><a href="#什么是Reactor模式" class="headerlink" title="什么是Reactor模式"></a>什么是Reactor模式</h1><h1 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h1><ul>
<li><code>Handles</code>:</li>
<li><code>Synchronous Event Demultiplexer</code></li>
<li><code>Initiation Dispatcher</code></li>
<li><code>Event Handler</code></li>
<li><code>Concrete Event Handler</code></li>
</ul>
<h1 id="Reactor模式模块之间的交互"><a href="#Reactor模式模块之间的交互" class="headerlink" title="Reactor模式模块之间的交互"></a>Reactor模式模块之间的交互</h1><h1 id="Reactor模式实现"><a href="#Reactor模式实现" class="headerlink" title="Reactor模式实现"></a>Reactor模式实现</h1><h1 id="Reactor模式优点"><a href="#Reactor模式优点" class="headerlink" title="Reactor模式优点"></a>Reactor模式优点</h1><h1 id="Reactor模式的缺点"><a href="#Reactor模式的缺点" class="headerlink" title="Reactor模式的缺点"></a>Reactor模式的缺点</h1><ul>
<li>Efficiency</li>
<li>Programming simplicity</li>
<li>Portability</li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 1：将C++视作一系列的语言</title>
    <url>/2020/12/07/effecitve-cpp/effective-cpp-1/</url>
    <content><![CDATA[<blockquote>
<p>Item 1: View C++ as a federation of languages</p>
</blockquote>
<p>一开始，<code>Ｃ++</code> 只是 <code>Ｃ</code> 加上一些面向对象特性，<code>Ｃ++</code> 最初的名称 <code>Ｃ with Classes</code> 也反映了这个血缘关系。现在这个语言逐渐成熟，已经是一个<strong>多重泛型编程语言</strong>(<code>multiparadigm programming language</code>)。同时支持过程形式(<code>procedural</code>)、面向对象形式(<code>object-oriented</code>)、函数形式(<code>functional</code>)、泛型形式(<code>generic</code>)、元编程形式(<code>metaprogramming</code>)</p>
<p>将 <code>C++</code> 视为一个由相关语言组成的联邦而非单一的语言。</p>
<p><code>C++</code> 主要４个子语言：</p>
<ul>
<li><code>C</code>。说到底Ｃ++仍是以Ｃ为基础。许多时候Ｃ++对问题的解法其实不过就是较高级的Ｃ的解法如<code>item2</code>、<code>item13</code>。当只使用<code>C++</code>中<code>C</code>的那部分语法，　会发现<code>C</code>语言的缺陷：没有模板、没有异常、没有重载。</li>
<li><code>Object-Oriented</code>。面向对象程序设计也是<code>C++</code>的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。</li>
<li><code>Template C++</code>。这是C++的泛型编程部分，大多数程序员经验最少的部分。<strong>TMP模板元编程</strong>（<code>template metaprogramming</code>）也是一个新兴的程序设计范式。</li>
<li><code>STL</code>。<code>STL</code>是一个特殊的模板库，它将容器、迭代器和算法优雅地结合在一起。</li>
</ul>
<p><code>C++</code> 程序设计的惯例并非一成不变，而是取决于你使用 <code>C++</code> 语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触 <code>Object-Oriented C++</code> 时会发现，传常量指针是更好的选择。运用<code>Template C++</code>时尤其如此，因为彼时你甚至不知道所处理的对象的类型。 但是你如果又碰到了<code>STL</code>，其中的迭代器和函数对象都是基于<code>C</code>语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 10：赋值运算符要返回自己的引用</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-10/</url>
    <content><![CDATA[<blockquote>
<p>Item 10：Have assignment operators return a reference to *this.</p>
</blockquote>
<p>赋值运算符要返回自己的引用只是个协议，并无强制性。这份协议被所有内置类型和标准程序库提供的类型如<code>string</code>, <code>vector</code>, <code>complex</code> <code>std::shared_ptr</code>等共同遵守。可以用来支持链式的赋值语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>; <span class="comment">//赋值连锁形式</span></span><br></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = ( y = ( z = <span class="number">15</span> ) );</span><br></pre></td></tr></table></figure>

<p>我们自定义的对象最好也能支持链式的赋值，这需要重载&#x3D;运算符时返回当前对象的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;   </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算 +=, -=, *=, etc.</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;  </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 11：赋值运算符需要考虑自我赋值问题</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-11/</url>
    <content><![CDATA[<blockquote>
<p>Item 11: Handle assignment to self in operator&#x3D;</p>
</blockquote>
<p>我们在重载一个类的赋值运算符时要考虑自我赋值的问题。有了指针和引用自我赋值不总是第一时间能够识别出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line">*px = *py;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">const</span> Base&amp; rb, Derived* pd)</span></span>;<span class="comment">// rb和女pd 有可能其实是同一对象</span></span><br><span class="line">rb = pd;</span><br></pre></td></tr></table></figure>

<p>自我赋值主要考虑到 <strong>自我赋值安全性</strong> 和 <strong>异常安全性</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">//指针，指向一个从heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既不自我赋值安全性也不异常安全性, 当 rhs &#x3D;&#x3D; *this时，delete pb使得rhs.pb成为空值，接下来 new 的数据便是空的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断两个地址是否相同，如果是自我赋值，就不做任何事。但开始就delete pb， 但 new 出现异常， pb就会置空出现风险。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 证同测试</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中<strong>仔细地排列语句顺序</strong>通常可以达到异常安全， 比如我们可以先申请空间，最后再delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap *pOrig = pb;  </span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更加通用的技术便是复制和交换（copy and swap）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this rhs 的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs); <span class="comment">//rhs 数据制作一份复件(副本)</span></span><br><span class="line">    <span class="built_in">swap</span> (temp); <span class="comment">//*this 数据和上述复件的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 12：复制对象时勿忘其每一个成分</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-12/</url>
    <content><![CDATA[<blockquote>
<p>Item 12: Copy all parts of an object</p>
</blockquote>
<p>正确拷贝函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="情形一：-新添加了一个数据成员，忘记了更新拷贝函数"><a href="#情形一：-新添加了一个数据成员，忘记了更新拷贝函数" class="headerlink" title="情形一： 新添加了一个数据成员，忘记了更新拷贝函数"></a>情形一： 新添加了一个数据成员，忘记了更新拷贝函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line">  Date lastTransaction;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时 <code>lastTransaction</code> 便被你忽略了，编译器也不会给出任何警告（即使在最高警告级别）</p>
<h3 id="情形二：-继承父类忘记了拷贝父类的部分"><a href="#情形二：-继承父类忘记了拷贝父类的部分" class="headerlink" title="情形二： 继承父类忘记了拷贝父类的部分"></a>情形二： 继承父类忘记了拷贝父类的部分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : <span class="built_in">priority</span>(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确写法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : <span class="built_in">Customer</span>(rhs), <span class="built_in">priority</span>(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 13：以对象管理资源</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-13/</url>
    <content><![CDATA[<blockquote>
<p>Item 13: Use objects to manage resources.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 14：在资源管理类中小心 copying 行为</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-14/</url>
    <content><![CDATA[<blockquote>
<p>Item 14: Think carefully about copying behavior in resource-managing classes.</p>
</blockquote>
<p>设计一个 <strong><code>RAII</code></strong> 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>:mutexPtr(pm)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>()&#123; <span class="built_in">unlock</span>(mutexPtr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户对<code>Lock</code>的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <strong><code>RAII</code></strong> 对象被复制，会发生什么事？ 不确定？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(&amp;ml1)</span></span></span><br></pre></td></tr></table></figure>

<p>记住<strong>资源管理对象的拷贝行为取决于资源本身的拷贝行为，同时资源管理对象也可以根据业务需要来决定自己的拷贝行为</strong>。一般有如下四种方式：</p>
<ul>
<li><p><strong>禁止复制</strong>。参考<a href="/2021/10/25/effecitve-cpp/effective-cpp-6/" title="Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝">若不想使用编译器自动生成的函数，就该明确拒绝</a>。对Lock而言看起来是这样：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>引用计数</strong>，采用 <code>shared_ptr</code> 的逻辑。<code>shared_ptr</code> 构造函数提供了第二个参数 <code>deleter</code>，当引用计数到 <code>0</code> 时被调用。 所以 <code>Lock</code> 可以通过聚合一个 <code>shared_ptr</code> 成员来实现引用计数：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm, unlock)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutexPtr; <span class="comment">//shared_ptr替换 raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>   <code>Lock</code> 的析构会引起 <code>mutexPtr</code> 的析构，而 <code>mutexPtr</code> 计数到0时<code>unlock(mutexPtr.get())</code> 会被调用。</p>
</li>
<li><p><strong>拷贝底部资源</strong>。复制资源管理对象时，进行的是<strong>深拷贝</strong>。比如 <code>string</code> 的行为：内存存有指向对空间的指针，当它被复制时会复制那片空间。</p>
</li>
<li><p><strong>转移底部资源的拥有权</strong>。<code>auto_ptr</code> 就是这样做的，把资源移交给另一个资源管理对象，自己的资源置空。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 15：在资源管理类中提供对原始资源的访问</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-15/</url>
    <content><![CDATA[<blockquote>
<p>Item 15: Provide access to raw resources in resource-managing classes.</p>
</blockquote>
<p><code>APIs</code> 往往要求访问原始资源(<code>raw resources</code>)，所以每一个RAII class 应该<strong>提供提供对原始资源访问的方法。获取资源的方式有两类：隐式地获取和显式地获取。</strong> 显式的资源获取会更安全，它最小化了无意中进行类型转换的机会。</p>
<ul>
<li><strong>显示获取</strong></li>
</ul>
<p><code>shared_ptr</code> 提供了 <code>get</code> 方法来得到资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Investment&gt; pInv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daysHeld</span><span class="params">(Investment *pi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<p>为了让 <code>pInv</code> 表现地更像一个指针，<code>shared_ptr</code>还重载了解引用运算符（<code>dereferencing operator</code>） <code>operator-&gt;</code>和 <code>operator*</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>());</span><br><span class="line"><span class="type">bool</span> texable2 = !((*pi1).<span class="built_in">isTaxFree</span>());</span><br></pre></td></tr></table></figure>

<p>我们封装了Font来管理资源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line">FontHandle f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span>: f(fh)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Font</span>()&#123; <span class="built_in">releaseFont</span>(f); &#125;;</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过get方法来访问FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>隐式地获取</strong></li>
</ul>
<p>可以隐式类型转换运算符将 <code>Font</code> 转换为 <code>FontHandle</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> f;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize);</span><br></pre></td></tr></table></figure>

<p>然而问题也随之出现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FontHandle h2 = f1;</span><br></pre></td></tr></table></figure>
<p>无意间 <code>h2</code> 并没有被资源管理起来，这将会引发意外的资源泄漏。所以隐式转换在提供便利的同时， 也引起了资源泄漏的风险。 </p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 16：使用同样的形式来new和delete</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-16/</url>
    <content><![CDATA[<blockquote>
<p>Item 16: Use the same form in corresponding uses of new and delete.</p>
</blockquote>
<p><strong>如果你用 <code>new</code> 申请了动态内存，请用 <code>delete</code> 来销毁；如果你用 <code>new xx[]</code> 申请了动态内存，请用 <code>delete[]</code> 来销毁</strong>: </p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string* stringPtrl = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* stringPtr2 = <span class="keyword">new</span> std::string[lOO];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringptrl;      <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;  <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure>

<p>上面很容易理解但需要注意<code>typedef</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];    <span class="comment">//每个人的地址有四行，</span></span><br><span class="line">                                        <span class="comment">//每行是一个string</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>AddressLines</code> 是个数组，如果这样使用 <code>new</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string *pal = <span class="keyword">new</span> AddressLines;     <span class="comment">//注意. &quot;new AddressLines&quot; 返回</span></span><br><span class="line">                                         <span class="comment">//一个 string*，就像 &quot;new string[4]&quot; 一样</span></span><br></pre></td></tr></table></figure>
<p>那就必须匹配 “<strong>数组形式</strong>“的 <code>delete</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pal;         <span class="comment">//行为未有定义!</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;     <span class="comment">//很好。</span></span><br></pre></td></tr></table></figure>

<p>为避免诸如此类的错误，最好尽量不要对数组形式做 <code>typedefs</code> 动作。可以使用更加面向对象的<code>vector</code>、<code>string</code>等对象。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 17：在单独的语句中将 new 的对象放入智能指针</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-17/</url>
    <content><![CDATA[<blockquote>
<p>Item 17: Store newed objects in smart pointers in standalone statements.</p>
</blockquote>
<p><strong>以单独的语句将 <code>new</code> 的对象放入智能指针内。这是为了防止由于其他表达式抛出异常而导致的资源泄漏</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>上述代码中，在 <code>processWidget</code> 函数被调用之前参数会首先得到计算。可以认为包括三部分的过程：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
<li>调用 <code>priority()</code></li>
</ol>
<p><strong>因为C++不同于其他语言，函数参数的计算顺序很大程度上决定于编译器</strong>，编译器认为顺序应当是1, 3, 2，即：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>调用 <code>priority()</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
</ol>
<p>那么如果 <code>priority</code>抛出了异常，新的 <code>Widget</code> 便永远地找不回来了。虽然我们使用了智能指针，但资源还是泄漏了！</p>
<p>于是更加健壮的实现中，应当将创建资源和初始化智能指针的语句独立出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Widget&gt; pw = <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget);</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 18：让接口容易被正确使用，不易被误用</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-18/</url>
    <content><![CDATA[<blockquote>
<p>Item 18: Make interfaces easy to use correctly and hard to use incorrectly.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 19：设计 class 犹如设计 type</title>
    <url>/2021/11/11/effecitve-cpp/effective-cpp-19/</url>
    <content><![CDATA[<blockquote>
<p>Item 19: Teat class design as type design.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 2：尽量以const, enum, inline 替换 &amp;#35;define</title>
    <url>/2020/12/14/effecitve-cpp/effective-cpp-2/</url>
    <content><![CDATA[<blockquote>
<p>Item 2: Prefer consts, enums, and inlines to #defines</p>
</blockquote>
<p>我们先看看<code>#deifne</code> 有哪些的问题:</p>
<h1 id="不利于调试"><a href="#不利于调试" class="headerlink" title="不利于调试"></a>不利于调试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ASPECT_RATION 1.653</span><br></pre></td></tr></table></figure>
<p>在预处理时候 <code>ASPECT_RATION</code> 可能就被移走了,<code>ASPECT_RATION</code> 没有进入 符号表, 运行此常量获得编译错误信息时, 可能会疑惑。因为这个错误信息总是提到 <code>1.653</code>，而不是<code>ASPECT_RATION</code> ， 如果 <code>ASPECT_RATION</code> 定义不是自己写的头文件中，可能对 <code>1.653</code> 的来源毫无概念，将因追踪它浪费时间，解决之道是以一个常量替换上述宏 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏</span></span><br><span class="line">                                 <span class="comment">//因此这里改变名称写法</span></span><br></pre></td></tr></table></figure>
<p>作为一个语言常量，<code>ASPECT_RATION</code> 肯定会被编译器看到，当然会进入记号表内。此外对于浮点常量(<code>floating point constant</code>)而言，使用常量可能比使用<code>#define</code> 导致较少量的码。</p>
<h1 id="不重视scope"><a href="#不重视scope" class="headerlink" title="不重视scope"></a>不重视scope</h1><p>无法利用 <code>#define</code> 创建<code>class</code>专属常量。一旦宏定义，它就在其后的编译过程中有效（除非在某处 <code>#undef</code> ）。而 <code>const</code> 可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns; <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];      <span class="comment">//使用该常量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum-比-const-更好用"><a href="#enum-比-const-更好用" class="headerlink" title="enum 比 const 更好用"></a>enum 比 const 更好用</h2><p>旧式编译器也许不支持上述语法，　它们不允许static在声明式上获得初值，此外所谓的“<code>in-classs　初值设定</code>”也只运行对<strong>整数常量</strong>进行，　如果编译器不支持上述语法，可以将初值放在定义式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CostEstimate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> FudgeFactor;  <span class="comment">//staitc class　常量声明位于头文件内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>; <span class="comment">//staitc class　常量定义位于实现文件内</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>emnu</code>就很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];　<span class="comment">//the enum hack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　</p>
<h1 id="不易理解"><a href="#不易理解" class="headerlink" title="不易理解"></a>不易理解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b)  f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);     　<span class="comment">//ａ被累加二次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b + <span class="number">10</span>);　<span class="comment">//ａ被累加一次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须记住为宏的所有实参加上小括号</li>
<li>在这里调用ｆ之前，ａ的递增次取决与“它被拿来与谁比较”</li>
</ul>
<p>更好的做法是使用　<code>template inline</code>　函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 20：传常量引用比传值更好</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-20/</url>
    <content><![CDATA[<blockquote>
<p>Item 20: Prefer pass-by-reference-to-const to pass-by-value.</p>
</blockquote>
<p>缺省情况下<code>C++</code> 用传值得方式(一个继承自<code>C</code>的方式)传递对象至(或来自)函数。除非你另外指定，否则函数参数都是以实际实参的复件(副本)为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件(副本)系由对象的<code>copy</code>构造函数产出。</p>
<p><strong>尽量以传常量引用替换传值前者通常比较高效，并可避免切割问题 (<code>slicing problem</code>)，但是内置类型和 <code>STL</code> 迭代器，还是传值更加合适。</strong>。</p>
<span id="more"></span>

<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题:"></a>性能问题:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> ();</span><br><span class="line">    <span class="keyword">virtual</span> -<span class="built_in">Person</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    -<span class="built_in">Student</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑以下代码，其中调用函数 <code>validateStudent</code> ，后者需要一个 <code>Student</code><br>(<code>by value</code>) 并返回它是否有效:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;           <span class="comment">// function taking a Student by value</span></span><br><span class="line"></span><br><span class="line">Student plato;                             <span class="comment">// Plato studied under Socrates</span></span><br><span class="line"><span class="type">bool</span> platoIsOK = <span class="built_in">validateStudent</span>(plato);   <span class="comment">// call the functio</span></span><br></pre></td></tr></table></figure>

<p>在调用 <code>validateStudent(</code>) 时进行了 <strong>6</strong> 个函数调用：</p>
<ol>
<li><code>Person</code> 的拷贝构造函数，为什么 <code>Student</code> 的拷贝构造一定要调用 <code>Person</code> 的拷贝构造请参见：<a href="/2021/11/02/effecitve-cpp/effective-cpp-12/" title="Effective C++ 12：复制对象时勿忘其每一个成分">Item:12 复制对象时勿忘其每一个成分</a></li>
<li><code>Student</code> 的拷贝构造函数</li>
<li><code>name</code>, <code>address</code>, <code>schoolName</code>, <code>schoolAddress</code> 的拷贝构造函数</li>
</ol>
<p>解决办法便是传递常量引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先以引用的方式传递，不会构造新的对象，避免了上述例子中 <strong>6</strong> 个构造函数的调用。 同时 const 也是必须的：传值的方式保证了该函数调用不会改变原来的 <code>Student</code>， 而传递引用后为了达到同样的效果，需要使用 <code>const</code> 声明来声明这一点，让编译器去进行检查!</p>
<h2 id="截断问题"><a href="#截断问题" class="headerlink" title="截断问题"></a>截断问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// return name of window</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// draw window and contents</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在假设你希望写个函数打印窗口名称，然后显示该窗口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; w.<span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    w.<span class="built_in">display</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br></pre></td></tr></table></figure>

<p>当调用 <code>printNameAndDisplay</code> 时参数类型从 <code>WindowWithScrollBars</code> 被隐式转换为 <code>Window</code>。 该转换过程通过调用 <code>Window</code> 的拷贝构造函数来进行。 导致的结果便是函数中的 <code>w</code> 事实上是一个 <code>Window</code> 对象， 并不会调用多态子类 <code>WindowWithScrollBars</code> 的 <code>display()</code>。</p>
<p>正确做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fine, parameter won&#x27;t be sliced</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>一般情况下相比于传递值，传递常量引用是更好的选择。但也有例外情况，比如 <strong>内置类型</strong> 和 <strong>STL 迭代器</strong>和<strong>函数对象</strong>。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 21：需要返回对象时，不要返回引用</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-21/</url>
    <content><![CDATA[<blockquote>
<p>Item 21: Don’t to return a reference when you must return an object.</p>
</blockquote>
<p>Item 20 中提到，多数情况下传引用比传值更好。但不要无脑追求这一点，一定不要返回空引用或指针。</p>
<span id="more"></span>

<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line">  <span class="type">int</span> n, d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Raitonal</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为什么是const请参考Item 3</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a, b;</span><br><span class="line">Rational c = a*b;</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>operator*</code> 返回的是一个实例，<code>a*b</code>时便会调用<code>operator*()</code>， 返回值被拷贝后用来初始化<code>c</code>。</p>
<p>不考虑编译器优化和 <code>C11</code> 的 <code>move</code> ,这个过程涉及到多个构造和析构过程：</p>
<ol>
<li><code>operator*</code>调用结束前，返回值被拷贝，调用拷贝构造函数</li>
<li><code>operator*</code>调用结束后，返回值被析构</li>
<li><code>c</code> 被初始化，调用拷贝构造函数</li>
</ol>
<p>我们能否通过传递引用的方式来避免这些函数调用？这要求在函数中创建那个要被返回给调用者的对象，而函数只有两种办法来创建对象：在栈空间中创建、或者在堆中创建。</p>
<p>在栈空间中创建显然是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n*rhs.n, lhs.d*rhs.d)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目标是要避免调用构造函数，而 <code>result</code> 却必须像任何对象一样地由构造函数构造起, 而且得到的 <code>result</code> 永远是空。因为 <code>result</code> 是一个 <code>local</code> 对象，当函数调用结束后 <code>result</code>即被销毁。</p>
<p>在堆中创建也会问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  Rational *result  = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n*rhs.n, lhs.d*rhs.d);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是得必须付出一个”构造函数调用”代价， 并且谁去 <code>delete</code>?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x*y*z;</span><br></pre></td></tr></table></figure>

<p>上面这样合理的代码都会导致内存泄露。</p>
<p>使用静态变量的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="type">static</span> Rational result; <span class="comment">// static 对象，此函数将返回</span></span><br><span class="line">    result = ... ; <span class="comment">// lhs 乘以 rhs. 并将结果置于 result 内。</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量首先便面临着线程安全问题，除此之外当我们需要不止一个的返回值同时存在时也会产生问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a*b) == (c*d))&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果operator*的返回值是静态变量，那么上述条件判断恒成立，因为等号两边是同一个对象。所以我们还是老老实实返回对象实例就好，并且考虑到编译器优化和<code>move</code>语意，拷贝构造返回值带来的代价没那么高。</p>
<p><strong>永远不要返回局部对象的引用或指针或堆空间的指针，如果需要多个返回对象时也不能是局部静态对象的指针或引用</strong>。<a href="/2021/01/13/effecitve-cpp/effective-cpp-4/" title="Effective C++ 4：确定对象被使用前已先被初始化">Item:4 确定对象被使用前已先被初始化</a>， 对于单例模式，返回局部静态对象的引用也是合理的。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 22：将成员变量声明为private</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-22/</url>
    <content><![CDATA[<blockquote>
<p>Item 22: Declare data members private.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 23：用非成员函数、非友元函数替换成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-23/</url>
    <content><![CDATA[<blockquote>
<p>Item 23: Prefer non-member non-friend functions to member functions</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 24：若所有参数皆需类型转换，请采用非成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-24/</url>
    <content><![CDATA[<blockquote>
<p>Item 24: Declare non-member functions when type conversions should apply all parameters.</p>
</blockquote>
<p>令 <code>classes</code> 支持隐式转换通常是糟糕的设计，但也有例外，最常见的是在建立数值类型时。 比如设计一个有理数 <code>class</code> 允许整数隐式转换。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>); <span class="comment">//构造函数刻意不使用 explicit; 允许 int-to-Rational 隐式转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时我们想设计一个乘法，该使用 <code>member</code> 函数，还是 <code>non-member</code> 函数， 还是 <code>non-member-friend</code> 函数？</p>
<p>我们先采用 <code>member</code> 函数看有什么问题？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用如下没有什么问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational result = oneEighth * oneHalf; <span class="comment">//ok</span></span><br><span class="line">result = result * oneEighth;  <span class="comment">// ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但当我们想支持混合运算，那 <code>Rational</code> 和 <code>ints</code> 相乘, 就只有一半行的通。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">//ok  隐式转换</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">// no</span></span><br></pre></td></tr></table></figure>

<p>当我们设计成 <code>non-member</code> 函数就都支持：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>(), rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;  <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth;  <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>

<p><strong>如果需要为某个函数的所有参数进行类型转换，那这个函数必须是 <code>non-member</code></strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 25：设计一个不抛异常的 swap 函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-25/</url>
    <content><![CDATA[<blockquote>
<p>Item 25: Consider support for a non-throwing swap.</p>
</blockquote>
<p><code>swap</code> 函数能置换两对象值，功能很重要!</p>
<ul>
<li>异常安全性编程</li>
<li>处理自我赋值可能性：<a href="/2021/11/01/effecitve-cpp/effective-cpp-11/" title="Effective C++ 11：赋值运算符需要考虑自我赋值问题">赋值运算符需要考虑自我赋值问题</a></li>
</ul>
<p><code>std</code> 的缺省基本实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="类的-swap"><a href="#类的-swap" class="headerlink" title="类的 swap"></a>类的 swap</h2><p>只要类型 <code>T</code> 支持 <code>copying</code>运算(拷贝构造和拷贝赋值运算)就能使用。 但缺省实现会有多次拷贝，在某些情况下不是性能最好的实现。比如针对 <code>pimpl</code> 手法实现的 <code>class</code>, 不仅要复制三次 <code>Widget</code> 还需要复制三次 <code>WdigetImpl</code>, 非常缺乏效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;);</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实我们发现这种情况只需要将 <code>pImpl</code> 指针交换就好， 我们可以将 <code>std::swap</code> 对 <code>Widget</code> 的特化来实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上述代码不能通过编译， 因为 <code>pImpl</code> 是私有变量， 所以，<code>Widget</code> 应当提供一个 <code>swap</code> 成员函数或友元函数。 惯例上会提供一个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap; <span class="comment">// 为何要这样？请看下文</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;</span><br><span class="line">      a.<span class="built_in">swap</span>(b);              <span class="comment">// 调用成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现与 STL 容器是一致的：<strong>提供公有 <code>swap</code> 成员函数， 并特化 <code>std::swap</code> 来调用那个成员函数</strong>。</p>
<h2 id="类模板的-swap"><a href="#类模板的-swap" class="headerlink" title="类模板的 swap"></a>类模板的 swap</h2><p>如果 <code>Widget</code> 和 <code>WidgetImpl</code> 是 <code>class templates</code> 而非 <code>classes</code>, 按照上面的 <code>swap</code> 实现方式，你可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;  ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但上述代码不能通过编译， <code>c++</code> 允许偏特化类模版，却不允许偏特化函数模版(虽然有的编译器中可以编译)。那我们继续尝试重载 <code>std::swap</code>  函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重载了 <code>std::swap</code>，相当于在 <code>std</code> 命名空间添加了一个函数模板。但这在 <code>C++</code> 标准中是不允许的！ <code>C++</code> 标准中，客户只能特化 <code>std</code> 中的模板，但不允许在 <code>std</code> 命名空间中添加任何新的模板。 上述代码虽然在有些编译器中可以编译，但会引发未定义的行为，所以不要这么做。所以我们最终可以把 <code>swap</code> 定义在 <code>Widget</code> 所在的命名空间中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何地方在两个 <code>Widget</code> 上调用 <code>swap</code> 时，<code>C++</code> 根据其 <code>argument-dependent lookup</code>（又称 <code>Koenig lookup</code>） 会找到 <code>WidgetStuff</code> 命名空间下的具有 <code>Widget</code> 参数的 <code>swap</code>。</p>
<p>其实类的 <code>swap</code> 也可以在同一命名空间下定义 <code>swap</code> 函数，而不必特化 <code>std::swap</code>。 但有人可能直接写 <code>std::swap(w1, w2)</code>，特化 <code>std::swap</code> 可以让你的类更加健壮。</p>
<p><strong>在成员函数中不要直接调用 <code>swap(pImpl, other.pImpl);</code> 因为指定了调用 <code>std::swap</code>，<code>argument-dependent lookup</code> 便失效了，<code>WidgetStuff::swap</code> 不会得到调用</strong>。</p>
<p>如果希望优先调用 <code>WidgetStuff::swap</code>，如果未定义则取调用 <code>std::swap</code>，那么应该如何写呢？ 看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;           <span class="comment">// 使得 std::swap 在该作用域内可见</span></span><br><span class="line">  <span class="built_in">swap</span>(obj1, obj2);          <span class="comment">// 现在，编译器会帮你选最好的 swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>C++</code> 编译器还是会优先调用指定了 <code>T</code> 的 <code>std::swap</code>，其次是 <code>obj1</code> 的类型 <code>T</code> 所在命名空间下的对应 <code>swap</code> 函数， 最后才会匹配 <code>std::swap</code> 的默认实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何实现 <code>swap</code> 呢？</p>
<ul>
<li>提供一个更加高效的，不抛异常的公有成员函数（比如 <code>Widget::swap</code>）。</li>
<li>在你类（或类模板）的同一命名空间下提供非成员函数 <code>swap</code>，调用你的成员函数。</li>
<li>如果你写的是类而不是类模板，也可以特化 <code>std::swap</code>，同样地在里面调用你的成员函数。</li>
<li>调用时，请首先用 <code>using</code> 使 <code>std::swap</code> 可见，然后直接调用 <code>swap</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 26：尽可能推迟变量的定义</title>
    <url>/2022/04/15/effecitve-cpp/effective-cpp-26/</url>
    <content><![CDATA[<blockquote>
<p>Item 26:Postpone variable definitions as long as possible.</p>
</blockquote>
<p>推迟变量的定义有两个好处：</p>
<ul>
<li>改善程序效率，减少无用的构造和析构。</li>
<li>增加程序流程清晰度。</li>
</ul>
<p>这条规则看似简单，但存在流程控制语句的时候容易疏忽。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted = password;</span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="推迟到需要构造时执行"><a href="#推迟到需要构造时执行" class="headerlink" title="推迟到需要构造时执行"></a>推迟到需要构造时执行</h2><p>当 <code>encryptPassword</code> 抛出异常时，<code>encrypted</code> 是无用的, 根本不需要构造它。所以更好的写法是推迟 <code>encrypted</code> 的构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;       <span class="comment">// 默认构造函数</span></span><br><span class="line">    encrypted = password;   <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推迟到有构造参数时"><a href="#推迟到有构造参数时" class="headerlink" title="推迟到有构造参数时"></a>推迟到有构造参数时</h2><p> <strong>“尽可能延后”</strong> 的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至<strong>应该尝试延后这份定义直到能够给它初值实参为止</strong>。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的 <code>default</code> 构造行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">encrypted</span><span class="params">(password)</span></span>;     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环中的变量"><a href="#循环中的变量" class="headerlink" title="循环中的变量"></a>循环中的变量</h2><p>循环中的变量定义也是一个常见的争论点。常有两种写法：</p>
<p>写法 <code>A</code>，在循环外定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; </span><br><span class="line">  w = some value dependent on i;</span><br><span class="line">  ...                           </span><br><span class="line">&#125;                  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写法 <code>B</code> ，在循环内定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>A</code>：<code>1</code> 个构造函数，<code>1</code> 个析构函数，<code>n</code> 个赋值运算符</li>
<li><code>B</code>：<code>n</code> 个构造函数，<code>n</code> 个析构函数</li>
</ul>
<p>但 <code>A</code> 使得循环内才使用的变量进入外部的作用域，不利于程序的理解和维护。软件工程中倾向于认为人的效率比机器的效率更加难得， 所以推荐采用 <code>B</code> 来实现。除非：</p>
<ul>
<li>这段代码是性能的关键.</li>
<li>赋值比一对构造&#x2F;析构更加廉价。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 28：避免返回 handles 指向对象内部成分</title>
    <url>/2022/04/16/effecitve-cpp/effective-cpp-28/</url>
    <content><![CDATA[<blockquote>
<p>Item28: Avoid returning “handles” to object internals.</p>
</blockquote>
<p>避免返回 <code>handles</code> (包括 <code>references</code> 、指针、迭代器)指向对象内部。</p>
<span id="more"></span>

<h2 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h2><p><code>const</code> 函数不再是 <code>const</code>, 修改了私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;</span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这样的设计可通过编译，但却是错误的。<code>upperLeft</code> 和 <code>lowerRight</code> 被声明为 <code>const</code> 成员函数，但是可以更改内部数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>; <span class="comment">// rec是个const矩形, 从 (0 ，0) 到 (100 ， 100)</span></span><br><span class="line"></span><br><span class="line">rec.<span class="built_in">upperLeft</span>( ) .<span class="built_in">setX</span>(<span class="number">50</span>);  <span class="comment">// 现在rec却变成从 (50 ， 0) 到 (100 ， 100)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>成员变量的封装性最多只等于”返回其 <code>reference</code>“ 的函数的访问级别。</li>
<li>如果 <code>const</code> 成员函数传出一个 <code>reference</code>，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。(<code>bitwise constness</code>原因)</li>
</ul>
<h2 id="悬空问题"><a href="#悬空问题" class="headerlink" title="悬空问题"></a>悬空问题</h2><p>虽然我们可以修改函数，达到不能修改私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br></pre></td></tr></table></figure>
<p>但也不能解决悬空问题。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">boundingBox</span><span class="params">(<span class="type">const</span> GUIObject&amp; obj)</span></span>; <span class="comment">//以 by value 方式返回一个矩形</span></span><br></pre></td></tr></table></figure>

<p>现在，客户有可能这么使用这个函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIObject* pgo; <span class="comment">// 让pgo指向某个GUIObject</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Point* pUpperLeft = &amp;(<span class="built_in">boundingBox</span>(*pgo) .<span class="built_in">upperLeft</span>()); <span class="comment">// 取得一个指针指向外框左上点</span></span><br></pre></td></tr></table></figure>

<p><code>pUpperLeft</code> 被悬空了，<code>boundingBox(*pgo)</code> 返回的是一个临时变量，在语句执行结束后就会销毁，导致 <code>pUpperLeft</code> 指针失效。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 3：尽可能使用 const</title>
    <url>/2021/01/05/effecitve-cpp/effective-cpp-3/</url>
    <content><![CDATA[<blockquote>
<p>Item3: Use const whenever possible.</p>
</blockquote>
<h1 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h1><p>指针的常量声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting;                 <span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;           <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;           <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;     <span class="comment">//const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>const</code> 出现在<code>*</code>左边，表示被指物为常量;　如果出现在<code>*</code>右边，表示指针自身为常量；如果出现在<code>*</code>两边，表示被指物和指针两者都是常量。</p>
<p>如果被指物是常量，<code>const</code> 放在类型之前和放在类型之后<code>*</code>之前表示的意义一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget* p)</span></span>;　<span class="comment">//f1　获得一个指针，指向一个常量Ｗidget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(widget <span class="type">const</span> *p)</span></span>;　<span class="comment">//f2 也是</span></span><br></pre></td></tr></table></figure>


<p>STL的<code>iterator</code> 系以指针塑模出来，所以<code>iterator</code>的作用像个<code>T*</code>指针。如果希望指针是常量，可以声明为 <code>const iterator</code>，如果希望被指物为常量，需使用 <code>const_iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">//iter的作用像个Ｔ* const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                             <span class="comment">//没问题，改变iter所指物  </span></span><br><span class="line">++iter;　　　　　　　　　　　　　　　　　　　　　　 　　　　     <span class="comment">//错误，iter是const</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();   <span class="comment">//cIter的作用像个const Ｔ*</span></span><br><span class="line">*cIter = <span class="number">10</span>;                                            <span class="comment">//错误，*cIter是const</span></span><br><span class="line">++cIter;                                                <span class="comment">//没问题，　改变cIter</span></span><br></pre></td></tr></table></figure>
<p>返回值声明为常量，可以降低代码被错误使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>　&#123;...&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*&#123;<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们本来想做个比较，错误地输入<code>=</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) ...</span><br></pre></td></tr></table></figure>
<p>编译器就会报错误：不可给常量赋值。</p>
<h1 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h1><p>声明const 成员函数，是为了确认该成员函数可以作用与const对象，也使class接口比较容易理解，可以得知哪些函数可以改动对象内容，哪些不可以。</p>
<p>成员函数只是常量性不同是可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>   <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// const objects</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)               <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// non-const objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;             <span class="comment">// fine — writing a non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;            <span class="comment">// error! — writing a const TextBlock</span></span><br></pre></td></tr></table></figure>

<h1 id="bitsise-constness-和-logical-constness"><a href="#bitsise-constness-和-logical-constness" class="headerlink" title="bitsise constness 和　logical constness"></a>bitsise constness 和　logical constness</h1><p><code>bitsise constness</code>: 成员函数只有在不改变对象的任何非静态成员变量时才可以被称为常量函数。也是C++对常量性的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pText[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TextBlock tb;</span><br><span class="line"><span class="type">char</span> *p = &amp;tb[<span class="number">1</span>];</span><br><span class="line">*p = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>函数调用<code>const</code>函数可以避免代码重复。不可以反着来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position]</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">            [position]</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>*this</code> 的类型是 <code>TextBlock</code>，先把它强制隐式转换为 <code>const TextBlock</code>，这样我们才能调用那个常量方法。</li>
<li>调用 <code>operator[](std::size_t) const</code>，得到的返回值类型为 <code>const char&amp;</code>。</li>
<li>把返回值去掉 <code>const</code> 属性，得到类型为 <code>char&amp;</code> 的返回值。</li>
</ol>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 4：确定对象被使用前已先被初始化</title>
    <url>/2021/01/13/effecitve-cpp/effective-cpp-4/</url>
    <content><![CDATA[<blockquote>
<p>Item 4: Make sure that objects are initialized before they’re used.</p>
</blockquote>
<h1 id="手工初始化内置对象"><a href="#手工初始化内置对象" class="headerlink" title="手工初始化内置对象"></a>手工初始化内置对象</h1><p>为内置对象进行手工初始化，因为<code>C++</code>不保证初始化他们。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;                                  <span class="comment">//对 int 进行手工初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;A C-style string&quot;</span>;      <span class="comment">//对指针进行手工初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">std::cin &gt;&gt; d;                              <span class="comment">//以读取 input stream 的方式完成初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="构造函数最好使用成员初值列"><a href="#构造函数最好使用成员初值列" class="headerlink" title="构造函数最好使用成员初值列"></a>构造函数最好使用成员初值列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones) &#123;</span><br><span class="line">    theName = name;             <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address;       <span class="comment">//而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在<code>class</code>中的声明次序相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones) : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address), <span class="built_in">thePhones</span>(phones), <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="local-static-对象替换-non-local-static-对象。"><a href="#local-static-对象替换-non-local-static-对象。" class="headerlink" title="local static 对象替换 non-local static 对象。"></a><code>local static</code> 对象替换 <code>non-local static</code> 对象。</h1><p>为免除”跨单元之初始化次序“问题，请以 <code>local static</code> 对象替换 <code>non-local static</code> 对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;     </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户使用使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params )</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在初始化次序的重要性体现出来了，除非 <code>tfs</code> 在 <code>tempDir</code> 之前先被初始化，否则<code>tempDir</code>的构造函数会用到尚未初始化的<code>tfs</code>。但<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源文件建立起来的，它们是定义于不同编译单元内的 <code>non-local static</code> 对象。它们初始化相对次序并无明确定义。但我们可以将 <code>local static</code> 对象替换<code>non-local static</code> 对象来解决。这也是<strong>Singleton</strong>模式的常见实现手法。</p>
<p>这个手法的基础在于：C++保证，函数内的 <code>local static</code> 对象会在调用该函数时首次遇上该对象的定义式时被初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 5：了解c++默默编写并调用哪些函数</title>
    <url>/2021/10/24/effecitve-cpp/effective-cpp-5/</url>
    <content><![CDATA[<blockquote>
<p>Item 5: Know what functions C++ silently writes and calls</p>
</blockquote>
<h1 id="默认函数"><a href="#默认函数" class="headerlink" title="默认函数"></a>默认函数</h1><p>在 <code>C++</code> 中，一个类有八个默认函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="built_in">Empty</span> () &#123;&#125; <span class="comment">//默认构造函数    </span></span><br><span class="line">    <span class="built_in">Empty</span> (<span class="type">const</span> Empty &amp;) &#123;&#125; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span> (<span class="type">const</span> Empty &amp;&amp;) &#123;&#125; <span class="comment">// 默认移动构造函数(`C++11`)</span></span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123;&#125; <span class="comment">// 默认析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;) &#123;&#125; <span class="comment">// 默认重载赋值运算符函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;&amp;)&#123;&#125; <span class="comment">// 默认重载移动赋值操作符函数函数</span></span><br><span class="line">    Empty* <span class="keyword">operator</span> &amp;() &#123;&#125; <span class="comment">// 默认重载取址运算符函数</span></span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="type">const</span> &#123;&#125; <span class="comment">// 默认重载取址运算符 `const` 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h1><p>只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。</p>
<h1 id="引用成员"><a href="#引用成员" class="headerlink" title="引用成员"></a>引用成员</h1><p>如果你打算在一个“内含引用成员”或者“内含<code>const</code>成员”的类内支持赋值操作，就必须定义自己的默认拷贝赋值操作符。因为 <code>C++</code> 本身不允许引用改指不同的对象，也不允许更改 <code>const</code> 成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string &amp; name;</span><br><span class="line">    <span class="built_in">Person</span>(string &amp;str):<span class="built_in">name</span>(str) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(s1)</span>, <span class="title">p2</span><span class="params">(s2)</span></span>;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: object of type &#x27;Person&#x27; cannot be assigned because its copy assignment operator is implicitly deleted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-6/</url>
    <content><![CDATA[<blockquote>
<p>Item 6: Explicitly disallow the use of compiler-generated functions you do not want.</p>
</blockquote>
<p>在C++中，编译器会自动生成一些你没有显式定义的函数。可以参考:<a href="/2021/10/24/effecitve-cpp/effective-cpp-5/" title="Effective C++ 5：了解c++默默编写并调用哪些函数">了解c++默默编写并调用哪些函数</a><br>然而有时候我们希望禁用掉这些函数，可以通过把自动生成的函数设为 <code>private</code> 来禁用它或者在 <code>c++11</code> 中使用 <code>delete</code> 关键字。</p>
<p>比如我们禁用拷贝的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale &amp;);  <span class="comment">// 只有声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;) = <span class="keyword">delete</span>； <span class="comment">// c++11</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以专门设计一个阻止<code>copying</code> 的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> noncopyable_ &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">noncopyable</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>() &#123;&#125;</span><br><span class="line">            ~<span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable() = default;</span></span><br><span class="line"><span class="comment">            ~noncopyable() = default;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">            noncopyable&amp; <span class="keyword">operator</span>=( <span class="type">const</span> noncopyable&amp; );</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            noncopyable&amp; operator=( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> noncopyable_::noncopyable</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HomeForSale p1, p2;</span><br><span class="line">p1 = p2;</span><br><span class="line"></span><br><span class="line">error: object of type <span class="string">&#x27;HomeForSale&#x27;</span> cannot be assigned because its copy assignment <span class="keyword">operator</span> is implicitly deleted</span><br><span class="line">    p1 = p2;</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 7：为多态基类声明 virtual 析构函数</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-7/</url>
    <content><![CDATA[<blockquote>
<p>Item 7: Declare destructors virtual in polymorphic base classes.</p>
</blockquote>
<p>析构函数声明为虚函数目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。 否则子类部分的内存将会泄漏，正确的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper *ptk = <span class="built_in">getTimeKeeper</span>():  <span class="comment">// 可能返回任何一种子类</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>

<ul>
<li>polymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果<br>class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。</li>
<li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性<br>(polymorphically) ，就不该声明 virtual 析构函数。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 8：析构函数不要抛出异常</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-8/</url>
    <content><![CDATA[<blockquote>
<p>Item 8: Prevent exceptions from leaving destructors.</p>
</blockquote>
<p><code>C++</code> 本身不阻止在析构函数抛出异常，但在析构函数中抛出的异常往往会难以捕获，引发程序非正常退出或未定义行为。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123; ... &#125; <span class="comment">//假设这里可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::vector&lt;Widget&gt; v;  <span class="comment">// v 这里被自动析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。</p>
<p>不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在 <code>C++</code> 中，不要让析构函数抛出异常！</p>
<p>但是如果析构函数所使用的代码可能无法避免抛出异常呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span>&#123;                   <span class="comment">//某用来建立数据库连接的类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;     <span class="comment">//建立一个连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;                     <span class="comment">//关闭一个连接，假设可以抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;                         <span class="comment">//创建一个资源管理类来提供更好的用户接口</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    ~DBConn&#123; db.<span class="built_in">close</span>(); &#125;            <span class="comment">//终止时自动调用关闭连接的方法</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...&#123;                                 </span><br><span class="line">  <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>; <span class="comment">//创建一个DBConn类的对象</span></span><br><span class="line">  ...                                 <span class="comment">//使用这个对象</span></span><br><span class="line">&#125;                                     <span class="comment">//对象dbc被释放资源</span></span><br><span class="line">          </span><br></pre></td></tr></table></figure>

<p>析构函数所调用的 <code>close()</code> 方法可能会抛出异常，那么有什么方法来解决呢？</p>
<p><strong>吞掉异常</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>主动关闭程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">    std::<span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把可能抛出异常的代码移出析构函数</strong></p>
<p>客户在需要关闭的时候主动调用 <code>close()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;        <span class="comment">//当要关闭连接时，手动调用此函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    closed = <span class="literal">false</span>;      <span class="comment">//显示连接是否被手动关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBConn::close</span><span class="params">()</span></span>&#123;    <span class="comment">//当需要关闭连接，手动调用此函数</span></span><br><span class="line">  db.<span class="built_in">close</span>();</span><br><span class="line">  closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DBConn::~<span class="built_in">DBcon</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!closed)            <span class="comment">//析构函数还是要留有备用，但不用每次都承担风险了</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">      <span class="comment">//记录访问历史</span></span><br><span class="line">      <span class="comment">//消化异常或者主动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析<br>构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 <code>class</code> 应该提<br>供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 9：绝不在构造和析构过程中调用 virtual 函数</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-9/</url>
    <content><![CDATA[<blockquote>
<p>Item 9: Never call virtual functions during construction or destruction.</p>
</blockquote>
<p>在构造和析构期间不要调用 <code>virtual</code> 函数，因为这类调用不会下降至 <code>derived class</code><br>(比起当前执行构造函数和析构函数的那层)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;                               <span class="comment">// base class for all</span></span><br><span class="line"><span class="keyword">public</span>:                                           <span class="comment">// transactions</span></span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;                                <span class="comment">// base class ctor           </span></span><br><span class="line">        <span class="built_in">logTransaction</span>();                         <span class="comment">// as final action, log this               </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;      <span class="comment">// make type-dependent</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;        <span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// how to log trans-</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p><code>b</code> 在构造时，调用到父类Transaction的构造函数，其中对 <code>logTransaction</code> 的调用会被解析到 <code>Transaction</code> 类。 那是一个纯虚函数，因此程序会非正常退出。</p>
<p>在<code>derived class</code> 对象的 <code>base class</code> 构造期间，对象的类型是 <code>base class</code> 而不是 <code>derived classo</code> 不只 <code>virtual</code> 函数会被编译器解析至(resolve to) <code>base class</code> ，若使用运行期类型信息 <code>RTTI</code>(runtime type information, 例如 <code>dynamic_cast</code>  <code>typeid</code>) ，也会把对象视为 <code>base class</code> 类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P11Transaction</span><br><span class="line">P14BuyTransaction</span><br></pre></td></tr></table></figure>

<p><strong>相同道理也适用于析构函数.</strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-STL 21：总是让比较函数在等值情况下返回 false</title>
    <url>/2023/03/10/effective-stl/effective-stl-21/</url>
    <content><![CDATA[<blockquote>
<p>Item 21: Always have comparison functions return false for equal values.</p>
</blockquote>
<h1 id="严格弱序-strict-weak-ordering"><a href="#严格弱序-strict-weak-ordering" class="headerlink" title="严格弱序( strict weak ordering )"></a>严格弱序( <code>strict weak ordering</code> )</h1><p>先补充下严格弱序的概念: 对两个变量 <code>x</code> 和 <code>y</code>：</p>
<ul>
<li><code>x &gt; y</code> 等同于 <code>y &lt; x</code></li>
<li><code>x == y</code> 等同于 <code>!(x &lt; y) &amp;&amp; !(x &gt; y)</code></li>
</ul>
<p>要想严格弱序，就需要遵循如下规则：</p>
<ul>
<li>每个变量值必须等于其本身（<code>irreflexivity</code>）：<code>x &lt; x</code> 永远不能为 <code>true</code></li>
<li>不对称性（<code>asymmetry</code>）：如果 <code>x &lt; y</code>，那么 <code>y &lt; x</code> 就不能为 <code>true</code></li>
<li>有序性必须可传递性：如果 <code>x &lt; y</code> 并且 <code>y &lt; z</code>，那么 <code>x &lt; z</code></li>
<li>值相同必须具有可传递性：如果 <code>x == y</code> 并且 <code>y == z</code>，那么 <code>x == z</code></li>
</ul>
<span id="more"></span>

<h1 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h1><h2 id="1-关联容器中的比较算法"><a href="#1-关联容器中的比较算法" class="headerlink" title="1. 关联容器中的比较算法"></a>1. 关联容器中的比较算法</h2><p>比如我们创建一个 <code>set</code> ， 用 <code>less_euqal</code> 作为比较类型，然后插入两个 <code>10</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>我们将第一个 <code>10</code> 记为 <code>10A</code>, 第二个 <code>10</code> 记为 <code>10B</code>, 我们在插入 <code>10B</code> 的时候会检查是否与 <code>10A</code> 相同, 我们用的是 <code>less_equal</code>，下面的表达式会为假，就会重复插入，显然不合理。:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!(10A &lt;= 10B) &amp;&amp; !(10B &lt;= 10A) //  !(true) &amp;&amp; !(true)</span><br></pre></td></tr></table></figure>

<p>另外在 <code>multiset</code> 中也不行: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>, less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入10A</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入10B</span></span><br></pre></td></tr></table></figure>

<p>当我们想要一个 <code>equal_range</code>, <code>10A</code> 和 <code>10B</code> 同样认为是不等，永远不会在同一个区间。</p>
<h2 id="2-sort-算法"><a href="#2-sort-算法" class="headerlink" title="2. sort 算法"></a>2. <code>sort</code> 算法</h2><p>对于 <code>std::sort</code>，当容器里面元素个数大于 <code>_S_threshold</code> 的值时（<code>16</code>），就会使用快速排序，会将所有的元素与中间值比较是无边界保护的，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">     _RandomAccessIterator</span><br><span class="line">     __unguarded_partition(_RandomAccessIterator __first,</span><br><span class="line">               _RandomAccessIterator __last,</span><br><span class="line">               _Tp __pivot, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span> (__comp(*__first, __pivot)) <span class="comment">// &lt;-------------------</span></span><br><span class="line">         ++__first;</span><br><span class="line">       --__last;</span><br><span class="line">       <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">         --__last;</span><br><span class="line">       <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">         <span class="keyword">return</span> __first;</span><br><span class="line">       std::<span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">       ++__first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入的 <code>vector</code> 中，后面的元素完全相等， <code>__comp()</code>函数一直返回 <code>true</code> ，在进行快速排序的时候，<code>++first</code> 就可能越界失效，导致 <code>coredump</code>。</p>
]]></content>
      <categories>
        <category>Effective-STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-STL</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-STL 9：慎重选择删除元素的方法</title>
    <url>/2023/02/16/effective-stl/effective-stl-9/</url>
    <content><![CDATA[<blockquote>
<p>Item9. Choose carefully among easing options.</p>
</blockquote>
<h1 id="一、删除特定值"><a href="#一、删除特定值" class="headerlink" title="一、删除特定值"></a>一、删除特定值</h1><ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code></p>
<p> 最好使用 <code>erase-remove</code>习惯用法: </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1963</span>, c.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器</p>
<p> 直接使用 <code>remove</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove</span>(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>对于标准关联容器</p>
<p> 直接使用 <code>erase</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="number">1963</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>
<h1 id="二、删除满足特定判定条件的值"><a href="#二、删除满足特定判定条件的值" class="headerlink" title="二、删除满足特定判定条件的值"></a>二、删除满足特定判定条件的值</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">badValue</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// 返回x是否为&quot;坏值&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code><br> 使用 <code>erase-remove-if</code>方法: </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), badValue, c.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器<br> 直接使用 <code>remove_if</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove_if</span>(badValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于标准关联容器</p>
<p> <strong>把当前的i传给erase，i后缀递增</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c3.<span class="built_in">erase</span>(i++); </span><br><span class="line">    <span class="keyword">else</span> ++i;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="三、循环内部删除对象之外还要做某些事"><a href="#三、循环内部删除对象之外还要做某些事" class="headerlink" title="三、循环内部删除对象之外还要做某些事"></a>三、循环内部删除对象之外还要做某些事</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code></p>
<p> <strong>接收 <code>erase</code>返回的迭代器值。</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">badValue</span>(*i)) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(*i);</span><br><span class="line">        i = c.<span class="built_in">rease</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器</p>
<p> 虽然也可以采用标准关联容器方法，但建议采用跟 <code>vector</code>、 <code>string</code> 或 <code>deque</code> 一致。</p>
</li>
<li><p>对于标准关联容器</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">badValue</span>(*i)) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(*i);</span><br><span class="line">        c.<span class="built_in">rease</span>(i++);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Effective-STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-STL</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之tr</title>
    <url>/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/</url>
    <content><![CDATA[<p><code>Linux</code> 中 <code>tr</code> 命令用于转换或删除文件中的字符。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> [OPTION] SET1 [SET2]</span></span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c, --complerment：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换;</span><br><span class="line">-d, --delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s, --squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t, --truncate-set1：先删除第一字符集较第二字符集多出的字符;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>字符集1(<code>SET1</code>)：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数 “字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</li>
<li>字符集2(<code>SET2</code>)：指定要转换成的目标字符集。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol>
<li><p>小写字母转换为大写字母:</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;HELLO WORLD&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -d &#x27;0-9&#x27;</span><br><span class="line">hello  world</span><br><span class="line"></span><br><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -cd &#x27;0-9&#x27;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></li>
<li><p>压缩字符</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello          world&quot; | tr -s &#x27;[:space:]&#x27;</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">➜  share echo &quot;hellooooo worldddddddddddd&quot; | tr -s &#x27;od&#x27; </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="常用的字符类"><a href="#常用的字符类" class="headerlink" title="常用的字符类"></a>常用的字符类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:print:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY</title>
    <url>/2022/04/19/linux/NO_PUBKEY/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt update </span><br><span class="line">命中:1 https://pro-driver-packages.uniontech.com eagle InRelease</span><br><span class="line">获取:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease [269 kB]                                 </span><br><span class="line">命中:3 http://packages.microsoft.com/repos/code stable InRelease                                             </span><br><span class="line">命中:4 https://home-packages.chinauos.com/home plum InRelease                                                </span><br><span class="line">命中:5 https://home-packages.chinauos.com/home plum/beta InRelease   </span><br><span class="line">命中:6 https://home-packages.chinauos.com/printer eagle InRelease</span><br><span class="line">错误:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease</span><br><span class="line">  由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">命中:7 https://home-store-img.uniontech.com/appstore eagle InRelease</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">W: GPG 错误：http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">E: 仓库 “http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease” 没有数字签名。</span><br><span class="line">N: 无法安全地用该源进行更新，所以默认禁用该源。</span><br><span class="line">N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 871920D1991BC93C</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>文件MIME类型</title>
    <url>/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="什么是-MIME-类型？"><a href="#什么是-MIME-类型？" class="headerlink" title="什么是 MIME 类型？"></a>什么是 MIME 类型？</h1><p><code>MIME</code>（多用途 <code>Internet</code> 邮件扩展）的类型来识别文件格式。 <code>MIME</code> 类型构成了 <code>Internet</code> 上对文件类型进行分类的标准方法。</p>
<ul>
<li><code>MIME Type</code>是用于描述文件的类型的一种表述方法，其将文件划分为多种类型，方便对其进行统一的管理。</li>
<li><code>MIME Type</code>指定了文件的类型名称、描述、图标信息，同时通过与.desktop应用程序描述文件整合，指定了文件的打开方式。</li>
</ul>
<span id="more"></span>
<p><code>MIME</code> 类型名字遵循指定的格式：</p>
<p>类型和子类型， 在 MIME 类型中，类型和子类型不区分大小写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-type/subtype-identifier</span><br></pre></td></tr></table></figure>

<p>目前，有十种注册类型：<code>application</code>，<code>audio</code>，<code>example</code>，<code>font</code>，<code>image</code>，<code>message</code>，<code>model</code>，<code>multipart</code>，<code>text</code>和<code>video</code>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multipart/form-data</span><br><span class="line">text/xml</span><br><span class="line">text/csv</span><br><span class="line">text/plain</span><br><span class="line">application/xml</span><br><span class="line">application/zip</span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<p>完整MIME 类型示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application/vnd.api+json</span><br></pre></td></tr></table></figure>

<p><code>application</code>作为类型，<code>api</code>作为子类型，<code>vnd</code>是厂商前缀，<code>+json</code>是后缀，表示可以解析为<code>JSON</code>。</p>
<h1 id="获取文件的-MIME-类型"><a href="#获取文件的-MIME-类型" class="headerlink" title="获取文件的 MIME 类型"></a>获取文件的 MIME 类型</h1><h2 id="xdg-mime命令"><a href="#xdg-mime命令" class="headerlink" title="xdg-mime命令"></a>xdg-mime命令</h2><ul>
<li><p>显示文件的<code>MIME</code>类型：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query filetype &#123;file&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query filetype one.jpg </span><br><span class="line">image/jpeg</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示<code>MIME</code> 类型的默认应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &#123;mimetype&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query default image/jpeg</span><br><span class="line">/usr/share/applications/deepin-image-viewer.desktop</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>显示文件默认应用程序的语法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &quot;$(xdg-mime query filetype &#123;file&#125;)&quot;</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default \</span><br><span class="line">    `xdg-mime query filetype &quot;$(find ~ / -iname &#x27;*.png&#x27; -print -quit)&quot;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>MIME</code> 类型的默认打开应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dekstop filetype</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dde-file-manager.desktop inode/directtory</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a>file 命令</h2><ul>
<li><p>查询文件类型：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file --mime-type INPUT_FILE</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ file --mime-type one.jpg </span><br><span class="line">one.jpg: inode/symlink</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="自定义的-MIME-类型"><a href="#自定义的-MIME-类型" class="headerlink" title="自定义的 MIME 类型"></a>自定义的 MIME 类型</h1><p>如需为系统上的所有用户添加一个自定义的 <code>MIME</code> 类型，并为该 <code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>/usr/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，在 <code>/usr/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<p>比如我们创建一个<code>application/x-newtype</code>类型：</p>
<ol>
<li><p>创建 &#x2F;usr&#x2F;share&#x2F;mime&#x2F;packages&#x2F;application-x-newtype.xml 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;mime-info xmlns=&quot;http://www.freedesktop.org/standards/shared-mime-info&quot;&gt;</span><br><span class="line">&lt;mime-type type=&quot;application/x-newtype&quot;&gt;</span><br><span class="line">    &lt;comment&gt;new mime type&lt;/comment&gt;</span><br><span class="line">    &lt;glob pattern=&quot;*.xyz&quot;/&gt;</span><br><span class="line">&lt;/mime-type&gt;</span><br><span class="line">&lt;/mime-info&gt;</span><br></pre></td></tr></table></figure>
<p> 上述 <code>application-x-newtype.xml</code> 文件定义了一种新的 <code>MIME</code> 类型<code>application/x-newtype</code>，并指定拓展名是 <code>.xyz</code> 的文件为该 <code>MIME</code> 类型。</p>
</li>
<li><p>创建一个名为例如 <code>myapplication1.desktop</code> 的新的 <code>.desktop</code> 文件，并将它放置在 <code>/usr/share/applications/</code> 目录下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=application/x-newtype</span><br><span class="line">Name=My Application 1</span><br><span class="line">Exec=myapplication1</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新 <code>MIME</code> 数据库以使您的更改生效：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-mime-database /usr/share/mime</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新应用程序数据库：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-desktop-database /usr/share/applications</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如需为个别用户添加自定义的 <code>MIME</code> 类型，并为该<code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>~/.local/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，并在 <code>~/.local/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/desktop_migration_and_administration_guide/file_formats">配置文件关联</a></p>
</li>
<li><p><a href="https://www.baeldung.com/linux/file-mime-types">file-mime-types</a></p>
</li>
<li><p><a href="https://specifications.freedesktop.org/mime-apps-spec/mime-apps-spec-latest.html">mime-apps-spec</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mime</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM64汇编入门</title>
    <url>/2023/03/18/macos/ARM64%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="ARM-指令概要介绍"><a href="#ARM-指令概要介绍" class="headerlink" title="ARM 指令概要介绍"></a><code>ARM</code> 指令概要介绍</h1><ul>
<li><code>A64</code> 指令集只能运行在 <code>aarch64</code> 环境中</li>
<li>所有的A64汇编指令都是 <code>32bits</code> 宽</li>
<li><code>A64</code> 支持全部是大写或者全部是小写的书写方式</li>
</ul>
<p>寄存器名：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Size</th>
<th align="left">Encoding</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Wn</td>
<td align="left">32 bits</td>
<td align="left">0-30</td>
<td align="left">Genral-purpose register 0-30</td>
</tr>
<tr>
<td align="left">Xn</td>
<td align="left">64 bits</td>
<td align="left">0-30</td>
<td align="left">Genral-purpose register 0-30</td>
</tr>
<tr>
<td align="left">WZR</td>
<td align="left">32 bits</td>
<td align="left">31</td>
<td align="left">Zero register</td>
</tr>
<tr>
<td align="left">XZR</td>
<td align="left">64 bits</td>
<td align="left">31</td>
<td align="left">Zero register</td>
</tr>
<tr>
<td align="left">WPS</td>
<td align="left">32 bits</td>
<td align="left">31</td>
<td align="left">Current stack pointer</td>
</tr>
<tr>
<td align="left">SP</td>
<td align="left">64 bits</td>
<td align="left">31</td>
<td align="left">Current stack pointer</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="ARM-指令的分类"><a href="#ARM-指令的分类" class="headerlink" title="ARM 指令的分类"></a><code>ARM</code> 指令的分类</h2><ul>
<li>内存加载和存储指令</li>
<li>多字节内存加载和存储</li>
<li>算术和位移指令</li>
<li>移位操作</li>
<li>位操作</li>
<li>条件操作</li>
<li>跳转指令</li>
<li>独占访存指令</li>
<li>内存屏障指令</li>
<li>异常处理指令</li>
<li>系统寄存器访问指令</li>
</ul>
<h2 id="ARM-指令的一般编码格式"><a href="#ARM-指令的一般编码格式" class="headerlink" title="ARM 指令的一般编码格式"></a><code>ARM</code> 指令的一般编码格式</h2><p>一条典型的 <code>ARM64</code> 指令语法格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;opcode&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125; &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;opcode&gt;</code>：是指令助记符，如 <code>ADD</code> 表示算术加操作指令。</li>
<li><code>&#123;&lt;cond&gt;&#125;</code>：表示指令执行的条件。</li>
<li><code>&#123;S&#125;</code>：决定指令的操作是否影响 <code>CPSR</code> 的值。</li>
<li><code>&lt;Rd&gt;</code>：表示目标寄存器。</li>
<li><code>&lt;Rn&gt;</code>：表示包含第 <code>1</code> 个操作数的寄存器。</li>
<li><code>&lt;shifter_operand&gt;</code>：表示第 <code>2</code> 个操作数。</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>Disk Arbitration</title>
    <url>/2023/02/16/macos/Disk-Arbitration/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>Disk Arbitration framework</code> 是一个基于 <code>Core Foundation</code> 的低级框架。会在磁盘出现和消失时通知您的应用程序，并让您的应用程序影响该过程。借助 <code>Disk Arbitration</code>，我们可以：</p>
<ul>
<li>检测何时出现新磁盘</li>
<li>阻止挂载</li>
<li>使用不同的标志或在不同的安装点上安装卷</li>
<li>卸载卷</li>
<li>观察卷的变化</li>
</ul>
<span id="more"></span>

<h1 id="使用磁盘仲裁通知和批准回调"><a href="#使用磁盘仲裁通知和批准回调" class="headerlink" title="使用磁盘仲裁通知和批准回调"></a>使用磁盘仲裁通知和批准回调</h1><ol>
<li>通过调用创建会话对象 <code>DASessionCreate</code>。</li>
<li>如果您想知道磁盘相关事件何时发生，请注册通知回调；如果您想积极参与仲裁过程，请注册批准回调。</li>
<li>在运行循环或调度队列上安排会话对象（并在必要时启动运行循环或调度队列）。</li>
<li>处理您的应用收到的任何回调。</li>
<li>当应用程序不再需要接收回调时，取消调度会话对象并释放它。</li>
</ol>
<h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p>编写磁盘仲裁通知客户端时必须做的第一件事是创建一个会话 (<code>DASessionRef</code>)。要创建磁盘仲裁会话，请调用<code>DASessionCreate</code>，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DASessionRef session;</span><br><span class="line">session = DASessionCreate(kCFAllocatorDefault);</span><br></pre></td></tr></table></figure>

<h2 id="注册通知和批准"><a href="#注册通知和批准" class="headerlink" title="注册通知和批准"></a>注册通知和批准</h2><p>磁盘仲裁支持两种类型的回调。通知回调告诉您发生了某些事情。批准回调允许您阻止挂载、卸载或弹出操作发生。</p>
<h3 id="通知回调"><a href="#通知回调" class="headerlink" title="通知回调"></a>通知回调</h3><ul>
<li><code>DADiskAppearedCallback</code>—出现磁盘或出现分区时调用</li>
<li><code>DADiskDescriptionChangedCallback</code>—当磁盘的描述发生变化时调用（在 <code>OS X v10.7</code> 及更高版本中，当首次安装卷时）</li>
<li><code>DADiskDisappearedCallback</code>—弹出可移动磁盘时调用</li>
<li><code>DADiskPeekCallback</code>—在首次探测磁盘时、自动挂载开始之前以及发送任何其他通知之前调用</li>
</ul>
<h3 id="注册函数"><a href="#注册函数" class="headerlink" title="注册函数"></a>注册函数</h3><ul>
<li><code>DARegisterDiskAppearedCallback</code></li>
<li><code>DARegisterDiskDescriptionChangedCallback</code></li>
<li><code>DARegisterDiskDisappearedCallback</code></li>
<li><code>DARegisterDiskPeekCallback</code></li>
</ul>
<p>这些注册函数中的大多数都采用匹配字典。您通常应该传递 <code>NULL``（以匹配所有磁盘）或传递标准匹配字典，例如kDADiskDescriptionMatchMediaUnformatted</code>. 这些匹配字典的详细匹配行为如下所示:</p>
<table>
<thead>
<tr>
<th align="left">标准字典</th>
<th align="left">内容</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">kDADiskDescriptionMatchMediaUnformatted</td>
<td align="left">kDADiskDescriptionMediaSizeKey价值为0</td>
<td align="left">匹配未格式化的媒体（如空白 DVD）。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchMediaWhole</td>
<td align="left">kDADiskDescriptionMediaWholeKey有价值true</td>
<td align="left">仅匹配整盘媒体（&#x2F;dev&#x2F;disk0例如 ）。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchVolumeMountable</td>
<td align="left">kDADiskDescriptionVolumeMountableKey有价值true</td>
<td align="left">匹配可安装的卷。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchVolumeUnrecognized</td>
<td align="left">kDADiskDescriptionVolumeMountableKey有价值false</td>
<td align="left">匹配不可挂载的磁盘。</td>
</tr>
</tbody></table>
<p>例如，要限制与 USB 连接媒体的匹配，您可以创建一个匹配字典，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFMutableDictionaryRef matchingDict =</span><br><span class="line">    CFDictionaryCreateMutable(</span><br><span class="line">        kCFAllocatorDefault,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">        &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"> </span><br><span class="line">CFDictionaryAddValue(matchingDict,</span><br><span class="line">    kDADiskDescriptionDeviceProtocolKey,</span><br><span class="line">    CFSTR(kIOPropertyPhysicalInterconnectTypeUSB));</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/kernel/kiopropertyphysicalinterconnecttypeusb">IOStorageProtocolCharacteristics.h User-Space Reference</a>中描述了其他互连类型和其他相关常量。最后，只要磁盘事件与指定的匹配字典（或多个字典）和使用上下文指针的事件类型匹配，您就可以将任意数据传递给回调。通过传递不同的上下文指针，您可以使用不同的匹配字典多次注册相同的回调，并向回调提供指示哪个注册匹配的信息。如果您不需要提供此类上下文信息，只需传递NULL此参数即可。</p>
<p>每个回调的详细信息在以下部分中有更详细的描述。</p>
<h3 id="注销通回调"><a href="#注销通回调" class="headerlink" title="注销通回调"></a>注销通回调</h3><p>当您不再需要通知回调时，通过调用取消注册 <code>DAUnregisterCallback</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DAUnregisterCallback(session, mycallbackfuntion, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>请务必传入注册函数时使用的原始上下文指针值</strong>。</p>
<h3 id="批准回调"><a href="#批准回调" class="headerlink" title="批准回调"></a>批准回调</h3><p>通过三种方式在磁盘仲裁中注册批准回调，具体取决于您希望何时收到通知。</p>
<ul>
<li>如果您希望在弹出磁盘之前获得许可，请调用 <code>DARegisterDiskEjectApprovalCallback</code>.</li>
<li>如果您希望在安装卷之前获得许可，请调用 <code>DARegisterDiskMountApprovalCallback</code>.</li>
<li>如果您希望在卸载卷之前获得许可，请调用 <code>DARegisterDiskUnmountApprovalCallback</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DADissenterRef <span class="title function_">allow_mount</span><span class="params">(DADiskRef disk, <span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">session = DASessionCreate(kCFAllocatorDefault);</span><br><span class="line"> </span><br><span class="line">DARegisterDiskMountApprovalCallback(session,</span><br><span class="line">                <span class="literal">NULL</span>, <span class="comment">/* Match all disks */</span></span><br><span class="line">                allow_mount,</span><br><span class="line">                <span class="literal">NULL</span>); <span class="comment">/* No context */</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">DADissenterRef <span class="title function_">allow_mount</span><span class="params">(</span></span><br><span class="line"><span class="params">        DADiskRef disk,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> allow = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (allow) &#123;</span><br><span class="line">                <span class="comment">/* Return NULL to allow */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;allow_mount: allowing mount.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Return a dissenter to deny */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;allow_mount: refusing mount.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> DADissenterCreate(</span><br><span class="line">                        kCFAllocatorDefault, kDAReturnExclusiveAccess,</span><br><span class="line">                        CFSTR(<span class="string">&quot;It&#x27;s mine!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注销批准回调"><a href="#注销批准回调" class="headerlink" title="注销批准回调"></a>注销批准回调</h3><p>当您不再需要批准回调时，您应该通过调用取消注册 <code>DAUnregisterApprovalCallback</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DAUnregisterApprovalCallback(session, mycallbackfuntion, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>请务必传入注册函数时使用的原始上下文指针值</strong>。</p>
<h2 id="使用调度队列"><a href="#使用调度队列" class="headerlink" title="使用调度队列"></a>使用调度队列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Schedule the session on a dispatch queue. */</span></span><br><span class="line">DASessionSetDispatchQueue(session, <span class="built_in">queue</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Unschedule the session on a dispatch queue. */</span></span><br><span class="line">DASessionSetDispatchQueue(session, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Clean up the session resources. */</span></span><br><span class="line">CFRelease(session);</span><br></pre></td></tr></table></figure>
<h2 id="使用运行循环"><a href="#使用运行循环" class="headerlink" title="使用运行循环"></a>使用运行循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Schedule a disk arbitration session. */</span></span><br><span class="line">DASessionScheduleWithRunLoop(session, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Start the run loop.  (Don&#x27;t do this if you already have</span></span><br><span class="line"><span class="comment">   a running Core Foundation or Cocoa run loop.) */</span></span><br><span class="line">CFRunLoopRun();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Clean up a session. */</span></span><br><span class="line">DASessionUnscheduleFromRunLoop(session,</span><br><span class="line">    CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</span><br><span class="line">CFRelease(session);</span><br></pre></td></tr></table></figure>

<h1 id="操作磁盘和卷"><a href="#操作磁盘和卷" class="headerlink" title="操作磁盘和卷"></a>操作磁盘和卷</h1><h2 id="获取磁盘对象"><a href="#获取磁盘对象" class="headerlink" title="获取磁盘对象"></a>获取磁盘对象</h2><p>在您可以操作磁盘或卷之前，您必须<code>DADiskRef</code>为该磁盘或卷获取一个对象。通过四种方式获取对象：</p>
<ul>
<li>作为传递给事件回调的参数（在使用磁盘仲裁通知和批准回调中描述）</li>
<li>通过调用从 <code>io_service_t</code>用户空间引用到有效设备切片的对象 <code>IOMediaDADiskCreateFromIOMedia</code></li>
<li>您可以通过调用或io_service_t来获取对象的用户空间引用。</li>
<li>从 <code>BSD</code> 设备名称（disk1s1例如）使用 <code>DADiskCreateFromBSDName</code></li>
<li>从挂载点调用 <code>DADiskCreateFromVolumePath</code></li>
</ul>
<p>如果您有一个<code>io_service_t</code>对象或一个 <code>BSD</code> 设备名称，您的应用程序可以创建一个<code>DADiskRef</code>对象，如下所示：</p>
<p><code>DASessionRef</code>按照创建会话中的描述创建一个对象。</p>
<ul>
<li>按照<code>Scheduling the Session with the Run Loop or Dispatch Queue</code>中的描述安排它。确保您的调度队列或运行循环正在运行。</li>
<li>创建磁盘对象。</li>
<li>根据需要操纵它们。</li>
</ul>
<h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><p>盘仲裁提供三个函数来获取有关磁盘和分区的附加信息：<code>DADiskCopyDescription</code> 、<code>DADiskGetBSDName</code> 和<code>DADiskCopyIOMedia</code>。通常，您可以通过调用 获得关于特定磁盘的几乎所有信息 <code>DADiskCopyDescription</code>。然而，对于一些相当深奥的信息，您可能必须<code>IOMedia</code>为磁盘获取一个对象并查询该对象。</p>
<p>如果您需要磁盘或分区的 <code>BSD</code> 设备名称（<code>disk1s1</code>例如）作为 <code>C</code> 字符串（通常在使用 <code>POSIX</code> 级 <code>API</code> 时使用），请调用 <code>DADiskGetBSDName</code>.<br>对于大多数其他信息，请调用<code>DADiskCopyDescription</code>，如获取描述字典中所述。<br>如果无法通过 获得您需要的信息 <code>DADiskCopyDescription</code>，请调用DADiskCopyIOMedia。</p>
<h3 id="获取描述字典"><a href="#获取描述字典" class="headerlink" title="获取描述字典"></a>获取描述字典</h3><p><code>DADiskCopyDescription</code>方法返回一个 <code>CFDictionaryRef</code> 对象，其中包含有关磁盘或分区的几十条信息。一些常用的数据包括：</p>
<ul>
<li>挂载点和卷名</li>
<li><code>BSD</code> 设备节点名称和主要和次要编号</li>
<li>有关硬件的信息（<code>设备 ID</code> 、<code>供应商 ID</code> 、<code>GUID</code> 等）</li>
<li>连接信息（总线名称和路径</li>
</ul>
<p>您可以在磁盘仲裁框架的标头中找到完整的属性列表 <a href="https://developer.apple.com/documentation/diskarbitration/dadisk_h?language=objc">DADisk.h Reference.</a>，以及每个键值的预期数据类型的描述。</p>
<h3 id="从-I-O-Kit-获取附加信息"><a href="#从-I-O-Kit-获取附加信息" class="headerlink" title="从 I/O Kit 获取附加信息"></a>从 <code>I/O Kit</code> 获取附加信息</h3><p>在极少数情况下，您可能需要获取有关磁盘的其他信息，而不是磁盘仲裁提供的信息。如果这样做，您可以调用<code>DADiskCopyIOMedia</code>以获取一个 <code>io_service_t</code>对象，该对象是对象的用户空间表示 <code>IOMedia</code>。您可以像操作任何 <code>I/O Registry</code> 对象一样操作此对象。</p>
<p>例如，您可以通过调用 <code>IORegistryEntryCreateCFProperties</code>结果对象来获取具有媒体 <code>I/O</code> 注册表属性的 <code>Core Foundation</code> 字典。</p>
<p><code>I/O Registry</code> 字典中的属性在 <code>I/O Kit Framework</code> 中定义。有关详细信息，请参阅<a href="https://developer.apple.com/documentation/iokit">I&#x2F;O Kit Framework Reference</a>。</p>
<h2 id="安装和卸载卷"><a href="#安装和卸载卷" class="headerlink" title="安装和卸载卷"></a>安装和卸载卷</h2><ul>
<li><p><code>DADiskMount</code></p>
</li>
<li><p><code>DADiskMountWithArguments</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *mppath = <span class="string">&quot;/mnt/mydisk&quot;</span>;</span><br><span class="line"></span><br><span class="line">path = CFURLCreateFromFileSystemRepresentation(</span><br><span class="line">    kCFAllocatorDefault,</span><br><span class="line">    mppath,</span><br><span class="line">    <span class="built_in">strlen</span>(mppath),</span><br><span class="line">    <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">DADiskMountWithArguments(disk, path, kDADiskMountOptionDefault,</span><br><span class="line">    mount_complete_callback, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>DADiskUnmount</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">DADissenterRef dissenter,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">DADiskUnmount(disk, kDADiskUnmountOptionDefault,</span><br><span class="line">    unmount_done, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        <span class="comment">/* Unmount failed. */</span></span><br><span class="line">        <span class="type">char</span> buf[MAXPATHLEN];</span><br><span class="line">        <span class="keyword">if</span> (CFURLGetFileSystemRepresentation(fspath, <span class="literal">false</span>, (UInt8 *)buf, <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unmount failed (Error: 0x%x Reason: %s).  Retrying.\n&quot;</span>,</span><br><span class="line">                DADissenterGetStatus(dissenter),</span><br><span class="line">                buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Something is *really* wrong. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Do something. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="弹出磁盘"><a href="#弹出磁盘" class="headerlink" title="弹出磁盘"></a>弹出磁盘</h2><p>在弹出磁盘之前，您必须卸载磁盘上的所有卷。首先调用 <code>DADiskUnmount</code>，将整个磁盘分区作为磁盘参数传递，并<code>kDADiskUnmountOptionWhole</code> 在卸载选项中设置标志。然后调用 <code>DADiskEject</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eject_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Unmount all volumes */</span></span><br><span class="line">DADiskRef wholedisk = DADiskCopyWholeDisk(partition);</span><br><span class="line">DADiskUnmount(wholedisk, kDADiskUnmountOptionWhole,</span><br><span class="line">    unmount_done, <span class="literal">NULL</span>);</span><br><span class="line">CFRelease(wholedisk);</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* In the unmount callback, eject the volume. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DADiskEject(disk, kDADiskEjectOptionDefault,</span><br><span class="line">            eject_done, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Eject callback. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eject_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/DriversKernelHardware/Conceptual/DiskArbitrationProgGuide/">Disk Arbitration Programming Guide</a></li>
</ul>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Disk</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O 相关记录</title>
    <url>/2023/03/10/macos/mach-o/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1>]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS平台上符号化崩溃报告</title>
    <url>/2022/07/26/macos/%E5%9C%A8MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="dSYM"><a href="#dSYM" class="headerlink" title=".dSYM"></a><code>.dSYM</code></h1><p><code>.dSYM</code> (<code>debugging SYMbols</code>) 又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的 <code>DWARF</code>（<code>Debugging With Attributed Record Formats</code>），其在.xcarchive目录中的层次结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.xcarchive</span><br><span class="line">--dSYMs</span><br><span class="line">  |--Your.app.dSYM</span><br><span class="line">    |--Contents</span><br><span class="line">      |--Resources</span><br><span class="line">        |--DWARF</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果在XCode中设置了带有 <code>dSYM</code> 文件的 <code>DWARF</code> 选项，则编译器会生成 <code>dSYM</code> 文件，并将其存储在您的构建中。<br><img src="/images/dsym.png"></p>
<h1 id="确定符号表和崩溃日志的一致性"><a href="#确定符号表和崩溃日志的一致性" class="headerlink" title="确定符号表和崩溃日志的一致性"></a>确定符号表和崩溃日志的一致性</h1><h2 id="崩溃日志中获取UUID"><a href="#崩溃日志中获取UUID" class="headerlink" title="崩溃日志中获取UUID"></a>崩溃日志中获取UUID</h2><p>崩溃日志比较靠下的位置有个 <code>Binary Images</code> 模块，其第一行内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x109724000 - 0x109cf7fff Your &lt;19a667b1-8910-3890-a0b0-03befee8876e&gt; /Library/Application Support/YourApp/*/YourApp.app/Contents/MacOS/YourApp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>代码段的起终地址: <code>0x109724000 - 0x109cf7fff</code></li>
<li>应用的UUID：<code>19a667b1-8910-3890-a0b0-03befee8876e</code>（不区分大小写）</li>
</ul>
<h2 id="从符号表中获取UUID"><a href="#从符号表中获取UUID" class="headerlink" title="从符号表中获取UUID"></a>从符号表中获取UUID</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --uuid Your.app.dSYM</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --uuid Your.app.dSYM/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure>

<p><strong>崩溃日志中和符号表中的UUID一致，才能正确解析</strong></p>
<h1 id="计算崩溃符号表地址"><a href="#计算崩溃符号表地址" class="headerlink" title="计算崩溃符号表地址"></a>计算崩溃符号表地址</h1><h2 id="符号表堆栈地址计算方式"><a href="#符号表堆栈地址计算方式" class="headerlink" title="符号表堆栈地址计算方式"></a>符号表堆栈地址计算方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 0::  Dispatch queue: com.apple.main-thread</span><br><span class="line">0   libsystem_kernel.dylib        	    0x7ff8159e775e write + 10</span><br><span class="line">1   libapr-1.0.dylib              	    0x10a6c1cee apr_file_write + 286</span><br><span class="line">2   liblog4cxx.10.0.0.dylib       	    0x10a369531 log4cxx::helpers::FileOutputStream::write(log4cxx::helpers::ByteBuffer&amp;, log4cxx::helpers::Pool&amp;) + 81</span><br><span class="line">3   Your      	                        0x10a3ae877❶  0x10a340000❷ + 452727❸</span><br></pre></td></tr></table></figure>

<ul>
<li>❶ 运行时堆栈地址 </li>
<li>❷ 运行时起始地址</li>
<li>❸ 偏移量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时堆栈地址 = 运行时起始地址 + 偏移量</span><br></pre></td></tr></table></figure>

<p>崩溃堆栈中的起始地址和崩溃地址均为运行时地址，根据虚拟内存偏移量不变原理，只要提供了符号表TEXT段的起始地址，再加上偏移量就能得到符号表中的堆栈地址，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">符号表堆栈地址 = 符号表起始地址 + 偏移量</span><br></pre></td></tr></table></figure>

<h2 id="符号表中TEXT段的起始地址可以通过以下命令获得："><a href="#符号表中TEXT段的起始地址可以通过以下命令获得：" class="headerlink" title="符号表中TEXT段的起始地址可以通过以下命令获得："></a>符号表中TEXT段的起始地址可以通过以下命令获得：</h2><p>使用 <code>otool</code> 查找 <code>LC_SEGMENT_64</code> 段和 <code>vmaddr</code> 条目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ otool -l Your.app.dSYM/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load command 4</span><br><span class="line">      cmd LC_SEGMENT_64</span><br><span class="line">  cmdsize 232</span><br><span class="line">  segname __TEXT</span><br><span class="line">   vmaddr 0x0000000100000000·</span><br><span class="line">   vmsize 0x0000000000004000</span><br><span class="line">  fileoff 0</span><br><span class="line"> filesize 0</span><br><span class="line">  maxprot 0x00000005</span><br><span class="line"> initprot 0x00000005</span><br><span class="line">   nsects 2</span><br><span class="line">    flags 0x0</span><br></pre></td></tr></table></figure>
<p>其中的<code>vmaddr 0x0000000100000000</code>字段即为TEXT段的起始地址。</p>
<h1 id="使用-LLDB-进行符号化"><a href="#使用-LLDB-进行符号化" class="headerlink" title="使用 LLDB 进行符号化"></a>使用 <code>LLDB</code> 进行符号化</h1><h2 id="crashlog"><a href="#crashlog" class="headerlink" title="crashlog"></a>crashlog</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xcrun lldb</span><br><span class="line"></span><br><span class="line">(lldb) command script import lldb.macosx.crashlog</span><br><span class="line"></span><br><span class="line">(lldb) crashlog &lt;path/to/crashlog.crash&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(lldb) target create --no-dependents --arch &lt;architecture&gt; &lt;path/to/dSYMs/App.app.dSYM/Contents/Resources/DWARF/App&gt;</span><br><span class="line"></span><br><span class="line">(lldb) image lookup --address &lt;symboladdress&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-ATOS-符号化"><a href="#使用-ATOS-符号化" class="headerlink" title="使用 ATOS 符号化"></a>使用 <code>ATOS</code> 符号化</h1><h2 id="符号表崩溃地址的解析方式"><a href="#符号表崩溃地址的解析方式" class="headerlink" title="符号表崩溃地址的解析方式"></a>符号表崩溃地址的解析方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; -l &lt;load address&gt; &lt;stack address 1&gt; &lt;stack address 2&gt; ...</span><br></pre></td></tr></table></figure>

<h2 id="无需符号表崩溃地址的解析方式"><a href="#无需符号表崩溃地址的解析方式" class="headerlink" title="无需符号表崩溃地址的解析方式"></a>无需符号表崩溃地址的解析方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; &lt;symboladdress&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-Dwarfdump-符号化"><a href="#使用-Dwarfdump-符号化" class="headerlink" title="使用 Dwarfdump 符号化"></a>使用 <code>Dwarfdump</code> 符号化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --arch x86_64 Your.app.dSYM --lookup symboladdress</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title>存储和加载指令</title>
    <url>/2023/03/18/macos/%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="存储和加载指令"><a href="#存储和加载指令" class="headerlink" title="存储和加载指令"></a>存储和加载指令</h3><h4 id="ldr-指令寻址之1：-地址偏移模式-unsigned-offset"><a href="#ldr-指令寻址之1：-地址偏移模式-unsigned-offset" class="headerlink" title="ldr 指令寻址之1： 地址偏移模式 (unsigned offset)"></a><code>ldr</code> 指令寻址之1： 地址偏移模式 (<code>unsigned offset</code>)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR Xd, [Xn, $offset]</span><br></pre></td></tr></table></figure>
<p>首先在 <code>Xn</code> 寄存器的内容上加上一个 <code>offset</code> 偏移量后作为内存地址，加载此地址的内容到 <code>Xd</code> 寄存器。</p>
<h4 id="ldr-指令寻址之2：-变基模式"><a href="#ldr-指令寻址之2：-变基模式" class="headerlink" title="ldr 指令寻址之2： 变基模式"></a><code>ldr</code> 指令寻址之2： 变基模式</h4><ul>
<li>前变基模式（<code>pre-index</code> 模式）： 先更新偏移地址然后再访问内存。</li>
<li>后变基模式（<code>post-index</code> 模式）：先访问内存地址然后再更新偏移地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X1, #8]! // 前变基模式。先更新X1 的值为 X1+8，然后义新的X1值为地址，加载内存的值到X0</span><br><span class="line"></span><br><span class="line">LDR X0, [X1], #8  // 后变基模式。以x1的值为地址，加载该内存地址的值到X0，然后在更新X1寄存器为X1+8</span><br></pre></td></tr></table></figure>

<h4 id="ldr-指令寻址之3：-标签（literal）"><a href="#ldr-指令寻址之3：-标签（literal）" class="headerlink" title="ldr 指令寻址之3： 标签（literal）"></a><code>ldr</code> 指令寻址之3： 标签（<code>literal</code>）</h4><p>PC + label offset</p>
<h4 id="ldr-伪指令"><a href="#ldr-伪指令" class="headerlink" title="ldr 伪指令"></a>ldr 伪指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR x7, =MY_LABEL</span><br></pre></td></tr></table></figure>

<h4 id="move-指令"><a href="#move-指令" class="headerlink" title="move 指令"></a>move 指令</h4><ul>
<li>16位立即数</li>
<li>16立即数左移16，32，48位</li>
</ul>
<h4 id="多字节加载和存储指令-ldp-和stp"><a href="#多字节加载和存储指令-ldp-和stp" class="headerlink" title="多字节加载和存储指令 ldp 和stp"></a>多字节加载和存储指令 ldp 和stp</h4>]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O 多路复用</title>
    <url>/2023/08/17/network/I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p><code>select</code> 实现多路复用的方式是，将已连接的 <code>socket</code> 都放到一个文件描述符集合，然后调用 <code>select</code>函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 <code>socket</code> 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 <code>Socket</code>，然后再对其处理。</p>
<p>所以，对于 <code>select</code> 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<h2 id="select-函数原型"><a href="#select-函数原型" class="headerlink" title="select 函数原型"></a>select 函数原型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> errorfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值 <ul>
<li>若有就绪描述符则为其数目，若超时则为 <code>0</code>，若出错则为 <code>-1</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>maxfd</code>: 待测试的描述符基数，它的值是待测试的最大描述符加 <code>1</code></li>
<li><code>readfds</code>：读描述符集合</li>
<li><code>writefds</code>：写描述符集合</li>
<li><code>errorfds</code>：异常描述符集合</li>
<li><code>timeout</code>: 超时设置</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="操作描述集合"><a href="#操作描述集合" class="headerlink" title="操作描述集合"></a>操作描述集合</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;　　　　　　</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;　　</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;　　　</span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FD_ZERO</code> 清空描述符集合；</li>
<li><code>FD_SET</code> 向描述符集合增加 <code>fd</code>；</li>
<li><code>FD_CLR</code> 向描述符集合删除 <code>fd</code>；</li>
<li><code>FD_ISSET</code> 判断描述符集合中的 <code>fd</code> 是否有响应；</li>
</ul>
<h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><p><code>timeval</code> 结构体时间: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="type">long</span>   tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="type">long</span>   tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后一个参数,可以设置 <code>3</code> 种值:</p>
<ul>
<li>设置成空 <code>(NULL)</code>，表示如果没有 <code>I/O</code> 事件发生，则 <code>select</code> 一直等待下去</li>
<li>设置一个非零的值，等待超时时间阻塞返回</li>
<li><code>tv_sec</code> 和 <code>tv_usec</code> 都设置成 <code>0</code>，表示不等待，检测完毕立即返回</li>
</ul>
<h2 id="使用-🌰"><a href="#使用-🌰" class="headerlink" title="使用 🌰"></a>使用 🌰</h2><p>在使用 <code>select</code> 时, 两个注意点:</p>
<ul>
<li><strong>描述符基数是当前最大描述符 +1；</strong></li>
<li><strong>每次 <code>select</code> 调用完成之后，要重置待测试集合。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> socket_fd = ...;</span><br><span class="line">fd_set ready_fds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   FD_ZERO(&amp;read_fds);</span><br><span class="line">   FD_SET(socket_fd, &amp;read_fds);</span><br><span class="line">   <span class="type">int</span> rc = select(socket_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(socket_fd, &amp;read_fds)) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**<code>select</code> 有一个缺点，那就是所支持的文件描述符的个数是有限的。在 <code>Linux</code> 系统中，<code>select</code> 的默认最大值为 <code>1024</code>**。</p>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h1><p><code>poll</code> 可以突破 <code>select</code> 文件描述符的个数限制， 函数原型如下: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值<ul>
<li>若有就绪描述符则为其数目，若超时则为 <code>0</code>，若出错则为 <code>-1</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>fds</code>: <code>pollfd</code>数组</li>
<li><code>nfds</code>: 描述 <code>fds</code>数组的大小</li>
<li><code>timeout</code>: 超时设置, 单位 <code>ms</code></li>
</ul>
</li>
</ul>
<h2 id="pollfd数组"><a href="#pollfd数组" class="headerlink" title="pollfd数组"></a><code>pollfd</code>数组</h2><p><code>pollfd</code> 结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    fd;       <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span>  events;   <span class="comment">/* events to look for */</span></span><br><span class="line">    <span class="type">short</span>  revents;  <span class="comment">/* events returned */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fd</code>: 文件描述</li>
<li><code>events</code>: 待检测的事件类型</li>
<li><code>revents</code>:  响应的事件类型</li>
</ul>
<p><code>events</code> 类型的事件可以分为三大类。</p>
<p>第一类是可读事件，有以下几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN          0x0001          <span class="comment">/* any readable data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI         0x0002          <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM      0x0040          <span class="comment">/* non-OOB/URG data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND      0x0080          <span class="comment">/* OOB/Urgent readable data */</span></span></span><br></pre></td></tr></table></figure>
<p>我们一般使用 <code>POLLOUT</code>, 系统内核通知套接字缓冲区已准备好，通过 <code>read</code> 函数执行读操作不会被阻塞。</p>
<p>第二类是可写事件，有以下几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT         0x0004          <span class="comment">/* file descriptor is writeable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM      POLLOUT         <span class="comment">/* no write type differentiation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND      0x0100          <span class="comment">/* OOB/Urgent data can be written */</span></span></span><br></pre></td></tr></table></figure>
<p>我们一般使用 <code>POLLOUT</code>, 系统内核通知套接字缓冲区已准备好，通过 <code>write</code> 函数执行写操作不会被阻塞。</p>
<p>还有另一大类是错误事件，没有办法通过 <code>poll</code> 向系统内核递交检测请求，只能通过 <code>returned events</code>来加以检测:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR    0x0008    <span class="comment">/* 一些错误发送 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP    0x0010    <span class="comment">/* 描述符挂起 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL   0x0020    <span class="comment">/* 请求的事件无效 */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>不想对某个 <code>pollfd</code> 结构进行事件检测</strong>，可以把它对应的 <code>pollfd</code> 结构的 <code>fd</code> 成员设置成一个<strong>负值</strong>。这样，<code>poll</code> 函数将忽略这样的 <code>events</code> 事件，检测完成以后，所对应的<code>returned events</code>的成员值也将设置为 <code>0</code>。</p>
<h2 id="超时设置-1"><a href="#超时设置-1" class="headerlink" title="超时设置"></a>超时设置</h2><ul>
<li><code>&lt; 0</code>，表示如果没有 <code>I/O</code> 事件发生，则 <code>poll</code> 一直等待下去</li>
<li><code>&gt; 0</code>，等待超时时间阻塞返回</li>
<li><code>= 0</code>，表示不等待，检测完毕立即返回</li>
</ul>
<h2 id="使用-🌰-1"><a href="#使用-🌰-1" class="headerlink" title="使用 🌰"></a>使用 🌰</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SIZE 128</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, connected_fd;</span><br><span class="line">    <span class="type">int</span> ready_number;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"> </span><br><span class="line">    listen_fd = tcp_server_listen(SERV_PORT);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化 pollfd 数组，这个数组的第一个元素是 listen_fd，其余的用来记录将要连接的 connect_fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">event_set</span>[<span class="title">INIT_SIZE</span>];</span></span><br><span class="line">    event_set[<span class="number">0</span>].fd = listen_fd;</span><br><span class="line">    event_set[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用 -1 表示这个数组位置还没有被占用</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; INIT_SIZE; i++) &#123;</span><br><span class="line">        event_set[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ready_number = poll(event_set, INIT_SIZE, <span class="number">-1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;poll failed &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (event_set[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">            <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">            connected_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *) &amp;client_addr, &amp;client_len);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 找到一个可以记录该连接套接字的位置</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; INIT_SIZE; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event_set[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    event_set[i].fd = connected_fd;</span><br><span class="line">                    event_set[i].events = POLLRDNORM;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i == INIT_SIZE) &#123;</span><br><span class="line">                error(<span class="number">1</span>, errno, <span class="string">&quot;can not hold so many clients&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (--ready_number &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; INIT_SIZE; i++) &#123;</span><br><span class="line">            <span class="type">int</span> socket_fd;</span><br><span class="line">            <span class="keyword">if</span> ((socket_fd = event_set[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (event_set[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = read(socket_fd, buf, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (write(socket_fd, buf, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        error(<span class="number">1</span>, errno, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span> || errno == ECONNRESET) &#123;</span><br><span class="line">                    close(socket_fd);</span><br><span class="line">                    event_set[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (--ready_number &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 协议</title>
    <url>/2023/07/25/network/TCP-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a><code>TCP</code> 基本认识</h1><p><code>TCP</code> 是 <strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3 </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p><code>TCP</code> 连接状态图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             +---------+ ---------\      active OPEN  </span><br><span class="line">                             |  CLOSED |            \    -----------  </span><br><span class="line">                             +---------+&lt;---------\   \   create TCB  </span><br><span class="line">                               |     ^              \   \  snd SYN    </span><br><span class="line">                  passive OPEN |     |   CLOSE        \   \           </span><br><span class="line">                  ------------ |     | ----------       \   \         </span><br><span class="line">                   create TCB  |     | delete TCB         \   \       </span><br><span class="line">                               V     |                      \   \     </span><br><span class="line">                             +---------+            CLOSE    |    \   </span><br><span class="line">                             |  LISTEN |          ---------- |     |  </span><br><span class="line">                             +---------+          delete TCB |     |  </span><br><span class="line">                  rcv SYN      |     |     SEND              |     |  </span><br><span class="line">                 -----------   |     |    -------            |     V  </span><br><span class="line">+---------+      snd SYN,ACK  /       \   snd SYN          +---------+</span><br><span class="line">|         |&lt;-----------------           ------------------&gt;|         |</span><br><span class="line">|   SYN   |                    rcv SYN                     |   SYN   |</span><br><span class="line">|   RCVD  |&lt;-----------------------------------------------|   SENT  |</span><br><span class="line">|         |                    snd ACK                     |         |</span><br><span class="line">|         |------------------           -------------------|         |</span><br><span class="line">+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+</span><br><span class="line">  |           --------------   |     |   -----------                  </span><br><span class="line">  |                  x         |     |     snd ACK                    </span><br><span class="line">  |                            V     V                                </span><br><span class="line">  |  CLOSE                   +---------+                              </span><br><span class="line">  | -------                  |  ESTAB  |                              </span><br><span class="line">  | snd FIN                  +---------+                              </span><br><span class="line">  |                   CLOSE    |     |    rcv FIN                     </span><br><span class="line">  V                  -------   |     |    -------                     </span><br><span class="line">+---------+          snd FIN  /       \   snd ACK          +---------+</span><br><span class="line">|  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |</span><br><span class="line">| WAIT-1  |------------------                              |   WAIT  |</span><br><span class="line">+---------+          rcv FIN  \                            +---------+</span><br><span class="line">  | rcv ACK of FIN   -------   |                            CLOSE  |  </span><br><span class="line">  | --------------   snd ACK   |                           ------- |  </span><br><span class="line">  V        x                   V                           snd FIN V  </span><br><span class="line">+---------+                  +---------+                   +---------+</span><br><span class="line">|FINWAIT-2|                  | CLOSING |                   | LAST-ACK|</span><br><span class="line">+---------+                  +---------+                   +---------+</span><br><span class="line">  |                rcv ACK of FIN |                 rcv ACK of FIN |  </span><br><span class="line">  |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  </span><br><span class="line">  |  -------              x       V    ------------        x       V  </span><br><span class="line">   \ snd ACK                 +---------+delete TCB         +---------+</span><br><span class="line">    ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |</span><br><span class="line">                             +---------+                   +---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何唯一确定一个-TCP-连接"><a href="#如何唯一确定一个-TCP-连接" class="headerlink" title="如何唯一确定一个 TCP 连接?"></a>如何唯一确定一个 <code>TCP</code> 连接?</h2><p><strong><code>TCP</code> 四元组</strong>可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<h1 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a><code>TCP</code> 连接建立</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul>
<li>防止历史连接</li>
<li>避免资源浪费</li>
<li>同步双方初始序列号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    TCP A                                                TCP B</span><br><span class="line"></span><br><span class="line">1.  CLOSED                                               LISTEN</span><br><span class="line"></span><br><span class="line">2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</span><br></pre></td></tr></table></figure>

<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p><code>TCP</code> 针对数据包丢失的情况，会用重传机制解决。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><code>RTT</code>（<code>Round-Trip Time</code> 往返时延）指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。</p>
<p>超时重传时间是以 <code>RTO</code> （<code>Retransmission Timeout</code>）表示。</p>
<p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p>
<ul>
<li>当超时时间 <code>RTO</code> 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <code>RTO</code> 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>根据上述的两种情况，我们可以得知，超时重传时间 <code>RTO</code> 的值应该略大于报文往返 <code>RTT</code> 的值。因为网络也是时常变化的，所以 <code>RTO</code> 是一个动态变化的值。</p>
<p>每当遇到一次超时重传的时候，都会将下一次 <code>RTO</code> 设为<strong>先前值的两倍</strong>。两次超时，就说明网络环境差，不宜频繁反复发送。</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>当收到三个相同的 <code>ACK</code> 报文时，会在定时器过期之前，重传丢失的报文段。快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。为了解决不知道该重传哪些 <code>TCP</code> 报文，于是就有 <code>SACK</code> 方法。</p>
<h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p><code>SACK</code>（<code>Selective Acknowledgment</code>），选择性确认。在 <code>TCP</code> 头部「选项」字段里加一个 <code>SACK</code> ，它可以将已收到的数据的信息发送给 <strong>「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以 <strong>只重传丢失的数据</strong>。</p>
<blockquote>
<p>在 <code>Linux</code> 下可以通过 <code>net.ipv4.tcp_sack</code> 参数开启&#x2F;关闭这个功能（<code>Linux 2.4</code> 后默认打开）。</p>
</blockquote>
<h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p><code>D-SACK</code> (<code>Duplicate SACK</code>) ，其主要使用了 <code>SACK</code> 来告诉 <strong>「发送方」</strong>有哪些数据被重复接收了。</p>
<p><code>D-SACK</code> 有这么几个好处：</p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ul>
<blockquote>
<p>在 <code>Linux</code> 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（<code>Linux 2.4</code> 后默认打开）。</p>
</blockquote>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h2><h2 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h2><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，**<code>TCP</code> 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**</p>
<h2 id="操作系统缓冲区和滑动窗口的关系"><a href="#操作系统缓冲区和滑动窗口的关系" class="headerlink" title="操作系统缓冲区和滑动窗口的关系"></a>操作系统缓冲区和滑动窗口的关系</h2><h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>如果窗口大小为 <code>0</code> 时，就会阻止发送方给接收方传递数据，直到窗口变为非 <code>0</code> 为止，这就是窗口关闭。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>慢启动就是一点一点的提高发送数据包的数量, <strong>当发送方每收到一个 <code>ACK</code>，拥塞窗口 <code>cwnd</code> 的大小就会加 <code>1</code></strong>, 发包的个数是<strong>指数性的增长</strong></p>
<ul>
<li>慢启动门限 <code>ssthresh</code> （<code>slow start threshold</code>）状态变量，默认 <code>65535</code> 大小。<ul>
<li><code>cwnd</code> &lt; <code>ssthresh</code> 时，使用<strong>慢启动算法</strong>。</li>
<li><code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用<strong>拥塞避免算法</strong>。</li>
</ul>
</li>
</ul>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p><strong>每当收到一个 <code>ACK</code> 时，<code>cwnd</code> 增加 <code>1/cwnd</code></strong>, 发包的个数是<strong>线性的增长</strong></p>
<h2 id="拥塞发送"><a href="#拥塞发送" class="headerlink" title="拥塞发送"></a>拥塞发送</h2><h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2023/07/17/network/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h1><p><code>HTTP</code> 是超文本传输协议，也就是 <code>HyperText Transfer Protocol</code>。</p>
<h1 id="URI-的完整图解"><a href="#URI-的完整图解" class="headerlink" title="URI 的完整图解"></a>URI 的完整图解</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  foo://example.com:8042/over/there?name=ferret#nose</span><br><span class="line">  \_/   \______________/\_________/ \_________/ \__/</span><br><span class="line">   |           |            |            |        |</span><br><span class="line">scheme     authority       path        query   fragment</span><br><span class="line">   |   _____________________|__</span><br><span class="line">  / \ /                        \</span><br><span class="line">  urn:example:animal:ferret:nose</span><br></pre></td></tr></table></figure>

<h1 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-line</span><br><span class="line">*( header-field CRLF )</span><br><span class="line">CRLF</span><br><span class="line">[ message-body ]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="start-line"><a href="#start-line" class="headerlink" title="start-line"></a>start-line</h2><ul>
<li>request line<ul>
<li>method SP request-target SP HTTP-version CRLF</li>
</ul>
</li>
<li>status line<ul>
<li>HTTP-version SP status-code SP reason-phrase CRLF</li>
</ul>
</li>
</ul>
<h2 id="Header-Fields"><a href="#Header-Fields" class="headerlink" title="Header Fields"></a>Header Fields</h2><ul>
<li>field-name “:” OWS field-value OWS</li>
</ul>
<h2 id="Message-Body"><a href="#Message-Body" class="headerlink" title="Message Body"></a>Message Body</h2><p>在一个请求中是否会出现消息体，以消息头中是否带有 <code>Content-Length</code> 或者 <code>Transfer-Encoding</code> 头字段作为信号</p>
<h1 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h1><h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-2.3">RFC 7230 - HTTP&#x2F;1.1: Message Syntax and Routing</a> 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 <code>HTTP</code> 报文。</p>
<h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6">RFC 7231 - HTTP&#x2F;1.1: Semantics and Content</a> <code>HTTP</code> 客户端通过 <code>CONNECT</code> 方法请求隧道代理创建一条到达任意目的服务器和端口的 <code>TCP</code> 连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONNECT server.example.com:80 HTTP/1.1</span><br></pre></td></tr></table></figure>


<h1 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3 演变"></a><code>HTTP/1.1、HTTP/2、HTTP/3</code> 演变</h1><h2 id="HTTP-1-1-的优化"><a href="#HTTP-1-1-的优化" class="headerlink" title="HTTP/1.1 的优化"></a><code>HTTP/1.1</code> 的优化</h2><ul>
<li>长连接</li>
<li>支持管道 （<code>pipeline</code>）网络传输</li>
</ul>
<p>但 <code>HTTP/1.1</code> 还是有性能瓶颈：</p>
<ul>
<li>请求 &#x2F; 响应头部（<code>Header</code>）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h2 id="HTTP-2-的优化"><a href="#HTTP-2-的优化" class="headerlink" title="HTTP/2 的优化"></a><code>HTTP/2</code> 的优化</h2><ul>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ul>
<h2 id="HTTP-3-的优化"><a href="#HTTP-3-的优化" class="headerlink" title="HTTP/3 的优化"></a><code>HTTP/3</code> 的优化</h2><p><code>HTTP/3</code> 基于 <code>UDP</code> 的 <code>QUIC</code> 协议 可以实现类似 <code>TCP</code> 的可靠性传输, 有以下 <code>3</code> 个特点。</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>socket 编程</title>
    <url>/2023/07/24/network/socket-%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-socket地址结构"><a href="#1-socket地址结构" class="headerlink" title="1. socket地址结构"></a>1. socket地址结构</h1><h2 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a><code>sockaddr_in</code></h2><p><code>ipv4</code> 协议的地址结构是 <code>sockaddr_in</code>，<code>ipv6</code> 的地址结构是<code>sockaddr_in6</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;netinet/in.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>     sin_family;</span><br><span class="line">    <span class="type">in_port_t</span>       sin_port;	    <span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>		<span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">            __SOCKADDR_COMMON_SIZE -</span><br><span class="line">            <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) -</span><br><span class="line">            <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sin_family</code>：表示地址簇，<code>ipv4: AF_INET, ipv6: AF_INET6</code>，</li>
<li><code>sin_port</code>：16位的端口号</li>
<li><code>sin_addr</code>：点分十进制。</li>
</ul>
<h2 id="通用地址结构"><a href="#通用地址结构" class="headerlink" title="通用地址结构"></a>通用地址结构</h2><p>结构体是 <code>sockaddr</code>，方便可以接受 <code>ipv4/ipv6</code> 的地址结构。之所以采用 <code>sockaddr</code>，而不采用 <code>void*</code>  是因为 <code>BSD</code> 设计套接字的时候大约是 <code>1982</code> 年，那个时候的 <code>C</code> 语言还没有<code>void *</code> 的支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>  sa_family;</span><br><span class="line">    <span class="type">char</span>         ss_data[<span class="number">14</span>];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>将 <code>sockaddr_in/sockaddr_in6</code> 强制转换为 <code>sockaddr</code> ，通过 <code>sockaddr</code> 的 <code>sa_family</code> 来分别使用的是 <code>ipv4/ipv6</code>。</p>
<h2 id="网络字节序列和主机字节序列转换"><a href="#网络字节序列和主机字节序列转换" class="headerlink" title="网络字节序列和主机字节序列转换"></a>网络字节序列和主机字节序列转换</h2><p><code>TCP/IP</code> 协议规定，网络传输字节按照<strong>大端字节序列</strong>方式      </p>
<ul>
<li>大端：低地址存储在高位。</li>
<li>小端：低地址存低位。</li>
</ul>
<h3 id="sin-port-转换"><a href="#sin-port-转换" class="headerlink" title="sin_port 转换"></a><code>sin_port</code> 转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;  <span class="comment">// host to net long(32位置)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net short(16位置)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;   <span class="comment">// net to host long</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sin-addr-转换"><a href="#sin-addr-转换" class="headerlink" title="sin_addr 转换"></a><code>sin_addr</code> 转换</h3><p>与协议无关的的转换函数，即 <code>ipv4/ipv6</code>都可以。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p><code>ipv4</code> 专用的转换函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> </span><br><span class="line">*<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> </span><br><span class="line"><span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>; <span class="comment">// 有风险，不建议使用</span></span><br></pre></td></tr></table></figure>
<h1 id="2-socket-函数"><a href="#2-socket-函数" class="headerlink" title="2. socket 函数"></a>2. socket 函数</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a><code>socket</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值 <ul>
<li>失败时返回 <code>-1</code>，成功是返回一个<strong>非零整数值</strong>，表示套接字描述符，<code>sockfd</code>。</li>
</ul>
</li>
<li>参数<ul>
<li><code>family</code>：<ul>
<li><code>PF_INET</code></li>
<li><code>PF_INET6</code></li>
<li><code>PF_LOCAL</code></li>
</ul>
</li>
<li><code>type</code>：<ul>
<li><code>SOCK_STREAM</code> : 表示的是字节流，对应 <code>TCP</code>；</li>
<li><code>SOCK_DGRAM</code> : 表示的是数据报，对应 <code>UDP</code>；</li>
<li><code>SOCK_RAW</code> : 表示的是原始套接字。</li>
<li>还可和 <code>SOCK_NOBLOCK</code> 和<code>SOCK_CLOEXEC</code> 进行组合使用。</li>
</ul>
</li>
<li><code>protocol</code>：<ul>
<li><code>0</code>，原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。目前一般写成 <code>0</code> 即可。</li>
</ul>
</li>
</ul>
</li>
<li>状态：  <ul>
<li>创建 <code>sockfd</code> 以后，处于 <code>CLOSED</code> 状态。</li>
</ul>
</li>
</ul>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>客户端调用函数。  </p>
<ul>
<li>返回值<ul>
<li>成功返回 <code>0</code>，失败返回 <code>-1</code>。</li>
<li>客户端调用 <code>connect</code> 函数，<strong>会激发<code>TCP</code>的三次握手过程</strong>，而且仅仅在连接成功或者失败才返回。<strong>客户端是在第二个分节返回，服务端是第三个分节返回</strong>。  </li>
<li>*<code>ETIMEOUT</code>*：若客户端没有收到 <code>SYN</code> 分节响应，就会返回这个错误。</li>
<li>*<code>ECONNREFUSED</code>*：若对客户端的 <code>SYN</code> 分节响应的是 <code>RST</code>，表示服务器主机在指定的端口上没有进程与之连接，客户端一接受到 <code>RST</code> 就返回 <code>ECONNREFUSED</code> 错误。</li>
<li>不可达错误。</li>
</ul>
</li>
<li>参数<ul>
<li><code>sockfd</code>：是<code>socket</code>函数返回值。</li>
<li><code>sockaddr</code>：是套接字的地址结构，<code>sockaddr_int/sockaddr_in6</code> 强制转换而来。</li>
<li><code>addrlen</code>：传入的地址结构大小。</li>
</ul>
</li>
<li>状态：<br>  <code>connect</code> 会使得当前套接字从 <code>closed</code> 状态转移到 <code>SYN_SENT</code> 状态，如成功再转移到<code>ESTABLISHED</code> 状态，若失败则该套接字不可用，<strong>必须关闭</strong>。</li>
</ul>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><code>bind</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>服务器端调用函数。</p>
<ul>
<li>参数<ul>
<li><code>addr</code><ul>
<li>可以使用<code>通配地址</code> 对于 <code>IPv4</code> 的地址来说，使用 <code>INADDR_ANY</code> 来完成通配地址的设置；对于 <code>IPv6</code> 的地址来说，使用 <code>IN6ADDR_ANY</code> 来完成通配地址的设置</li>
<li><code>0</code>, 系统随机分配</li>
</ul>
</li>
<li><code>port</code><ul>
<li>绑定端口，一般选择大于 <code>1024</code> 的端口。</li>
<li><code>0</code>, 系统随机分配</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line">name.sin_addr.s_addr = htonl (INADDR_ANY); <span class="comment">/* IPV4 通配地址 */</span></span><br></pre></td></tr></table></figure>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a><code>listen</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p><code>listen</code> 函数由<strong>服务器端</strong>调用。</p>
<p>初始化创建的套接字，可以认为是一个”主动”套接字，其目的是之后主动发起请求（通过调用 <code>connect</code> 函数）。通过 <code>listen</code> 函数，可以将原来的”主动”套接字转换为”被动”套接字，告诉操作系统内核：”我这个套接字是用来等待用户请求的。”, 操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。</p>
<ul>
<li><p>返回值 </p>
<ul>
<li>失败时返回 <code>-1</code>，成功返回 <code>0</code>。</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>sockfd</code><ul>
<li>初始化套接字</li>
</ul>
</li>
<li><code>backlog</code><ul>
<li><p>内核为相应套接字排队的最大连接个数，这个参数的大小决定了可以接收的并发数目。</p>
</li>
<li><p>内核为每个<strong>监听</strong>套接字维护两个队列：<br>  (1) 半连接队列（ <code>SYN</code> 队列）：接收到一个 <code>SYN</code> 建立连接请求，处于 <code>SYN_RCVD</code> 状态；<br><br>  (2) 全连接队列（ <code>Accept</code> 队列）：已完成 <code>TCP</code> 三次握手过程，处于 <code>ESTABLISHED</code> 状态； </p>
<p>  在早期 <code>Linux</code> 内核 <code>backlog</code> 是 <code>SYN</code> 队列大小，也就是未完成的队列大小。在 <code>Linux</code> 内核 <code>2.2</code> 之后，<code>SYN</code> 队列由 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>指定； <code>backlog</code> 变成 <code>Accept</code> 队列，也就是已完成连接建立的队列长度，所以现在通常认为 <code>backlog</code> 是 <code>accept</code> 队列。但是上限值是内核参数 <code>somaxconn</code> 的大小，也就说 ** <code>Accept</code> 队列长度 &#x3D; <code>min(backlog, somaxconn)</code>**。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>状态转移</p>
<ul>
<li>当来自客户的 <code>SYN</code> 分节到达时，<code>TCP</code> 在未连接队列创建一个新项，然后响应以三次握手的第二个分节，这一项一直保留在未完成连接队列中，直到三次握手的第三个分节到达或者超时。如果到达，该项就从未完成连接队列中移到已完成连接队列的队尾。当调用 <code>accept</code> 时，已完成连接队列的队首将作为 <code>accept</code> 的返回值，如果已完成连接队列是空，那么调用 <code>accept</code> 函数的进程会进入睡眠状态。</li>
</ul>
</li>
</ul>
<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a><code>accept</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>调用 <code>accept</code> 时，已完成连接队列的队首将作为 <code>accept</code> 的返回值，如果已完成连接队列是空，那么调用进程进入睡眠状态。成功返回客户端的已连接套接字<code>connfd</code>，失败返回 <code>-1</code>。</p>
<p><code>accpet</code> 函数返回时，表示已连接套接字 <code>connfd</code> 和服务器端的监听套接字 <code>listenfd</code> 完成了三次握手。</p>
<ul>
<li><p><em><code>EMFILE</code></em><br>  如果函数<code>accept</code>返回<code>EMFILE</code>，即文件描述符过多，怎么处理？</p>
<blockquote>
<p>先实现准备一个空闲的文件描述符 *<code>/dev/null</code>*。遇到这种情况，先关闭这个空闲的文件描述符，就可以获得一个文件描述名额，然后再<code>accept</code>就可以拿到这个连接的<code>socket</code>文件描述符，随后立即<code>close</code>，就优雅的断开了与客户端的连接，最后重新打开空闲文件，以备这种情况再次出现。</p>
</blockquote>
</li>
</ul>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a><code>close</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数表示的把该套接字标记为已关闭，然后立即返回到调用进程，该套接字描述符不能再被调用进程使用。  </p>
<ul>
<li>注意事项<ul>
<li>由于描述符是引用计数，<code>close</code> 只是减少该引用计数，只有当该引用计数为 <code>0</code> 时才会引用终止序列。</li>
<li>tcp会先将已经排队等待发送到对端的任何数据发送过去，然后再发送终止序列<code>FIN</code>。因此，调用 <code>close</code> 不是立即发送终止序列。</li>
</ul>
</li>
</ul>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shutdown</code> 解决的是 <code>close</code> 的两个限制：</p>
<ul>
<li><p><code>close</code> 把描述符计数减一，仅仅在计数变为 <code>0</code> 时才关闭套接字。<code>shutdown</code> 可以不管描述符计数就激发 <code>TCP</code> 的正常连接终止序列。</p>
</li>
<li><p><code>close</code> 终止<strong>读和写</strong>两个方向的数据传递，<code>shutdown</code> 是半关闭，可以只是关闭一个方向数据流。</p>
</li>
<li><p>参数</p>
<ul>
<li><code>how</code>:<ul>
<li><code>SHUT_RD</code>：关闭读</li>
<li><code>SHUT_WR</code>：关闭写</li>
<li><code>SHUT_RDWR</code>：关闭读写</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 抓包</title>
    <url>/2023/07/19/network/tcpdump-%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p><code>tcpdump</code> 命令行抓包工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ]</span><br><span class="line">        [ -c count ] [ --count ] [ -C file_size ]</span><br><span class="line">        [ -E spi@ipaddr algo:secret,...  ]</span><br><span class="line">        [ -F file ] [ -G rotate_seconds ] [ -i interface ]</span><br><span class="line">        [ --immediate-mode ] [ -j tstamp_type ] [ -k (metadata_arg) ]</span><br><span class="line">        [ -m module ]</span><br><span class="line">        [ -M secret ] [ --number ] [ --print ]</span><br><span class="line">        [ -Q packet-metadata-filter ] [ -Q in|out|inout ]</span><br><span class="line">        [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]</span><br><span class="line">        [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]</span><br><span class="line">        [ -z postrotate-command ] [ -Z user ]</span><br><span class="line">        [ --time-stamp-precision=tstamp_precision ]</span><br><span class="line">        [ --micro ] [ --nano ]</span><br><span class="line">        [ expression ]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确使用TCP</title>
    <url>/2023/07/24/network/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8TCP/</url>
    <content><![CDATA[<h1 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h1><ul>
<li><code>TCP</code> 服务器能够在杀掉或崩溃后快速重启</li>
<li>也适用 <code>fork-per-connection</code> 服务器模型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="built_in">sizeof</span>(optval));</span><br></pre></td></tr></table></figure>
<h1 id="忽略-SIGPIPE"><a href="#忽略-SIGPIPE" class="headerlink" title="忽略 SIGPIPE"></a>忽略 SIGPIPE</h1><p>程序向对方已经关闭的管道，写数据，会收到 <code>SIGPIPE</code> 信号。<code>write</code> 系统调用返回 <code>-1</code>收到 <code>errono EPIPE</code>。 <code>SIGPIPE</code> 信号默认行为终止进程。我们应该忽略 <code>SIGPIPE</code> 信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">signal</span>(SIGPIPE, SIG_IGN) == SIG_ERR) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h1 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h1><p><code>Nagle</code> 算法避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个 <code>TCP</code> 连接而言，只允许一个未被 <code>ACK</code>的包存在于网络。</p>
<p><code>Nagle</code> 算法规则: </p>
<ul>
<li>如果包长度达到 <code>MSS</code>，则允许发送</li>
<li>如果包含 <code>FIN</code>，则允许发送</li>
<li>如果设置了 <code>TCP_NODELAY</code>，则允许发送</li>
<li>未设置 <code>TCP_CORK</code> 选项时，若所有发出去的小数据包（包长度小于<code>MSS</code>）均被确认，则允许发送</li>
<li>上述条件都未满足，但发生了超时（一般为<code>200ms</code>），则立即发送。</li>
</ul>
<p>通过设置 <code>TCP_NODELAY</code> 禁用 <code>nagle</code> 算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, IPPROTO_TCP, TCP_NODELAY, (<span class="type">char</span>*)&amp;flag, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<h1 id="正确关闭-TCP-连接"><a href="#正确关闭-TCP-连接" class="headerlink" title="正确关闭 TCP 连接"></a>正确关闭 <code>TCP</code> 连接</h1><p>如果协议栈接受缓存区中有数据，程序还没有读，直接调用 <code>close</code> 函数，<code>TCP</code> 协议栈会发送 <code>RST</code> 包，强行断开连接，如果协议栈发送缓存区还有有数据，则对方没能收到，造成数据丢失。 对于无格式的协议正确的做法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送方: send() + shutdown(WR) + read()-&gt;0 + close()</span><br><span class="line">接收方: read()-&gt;0 + 没有数据发送 + close()</span><br></pre></td></tr></table></figure>

<p>如果遇到恶意或者是有 <code>bug</code> 的 <code>client</code>，一直不 <code>close</code>，发送方一直阻塞在 <code>read</code> , 建议加一个超时机制退出程序，这是为了程序安全 <code>security</code>，不是为了数据安全 <code>safety</code> 完整性 <code>Integrity</code>。</p>
<p>依赖 <code>shutdown write</code> 会发送 <code>FIN</code>，<code>end of file</code>，更好的办法是设计协议，把数据长度包含进来，接收方可以主动判断数据是否收全。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 之 焦点处理</title>
    <url>/2023/02/15/qt/Qt-%E4%B9%8B-%E7%84%A6%E7%82%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h1><p>当焦点从一个 <code>widget</code> 移动到另一个 <code>widget</code> 时，会触发 <code>QFocusEvent</code> 事件，这个事件会被发送给原焦点窗口和当前焦点窗口，原焦点窗口执行 <code>focusOutEvent()</code> ，新焦点窗口执行 <code>focusInEvent()</code>。 相关函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusInEvent</span><span class="params">(QFocusEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusOutEvent</span><span class="params">(QFocusEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="焦点策略"><a href="#焦点策略" class="headerlink" title="焦点策略"></a>焦点策略</h1><p>只有<strong>可获取焦点</strong>的窗口，才有机会成为焦点窗口。比如<code>QWidget</code> 默认策略是 <code>Qt::NoFocus</code> 所以 QWidget 默认不获取焦点。Qt提供了如下接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocusPolicy</span><span class="params">(Qt::FocusPolicy policy)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="enum-Qt-FocusPolicy"><a href="#enum-Qt-FocusPolicy" class="headerlink" title="enum Qt::FocusPolicy"></a>enum Qt::FocusPolicy</h2><table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt::TabFocus</td>
<td align="left">0x1</td>
<td align="left">the widget accepts focus by tabbing.</td>
</tr>
<tr>
<td align="left">Qt::ClickFocus</td>
<td align="left">0x2</td>
<td align="left">the widget accepts focus by clicking.</td>
</tr>
<tr>
<td align="left">Qt::StrongFocus</td>
<td align="left">TabFocus &#124; ClickFocus &#124; 0x8</td>
<td align="left">the widget accepts focus by both tabbing and clicking. On macOS this will also be indicate that the widget accepts tab focus when in ‘Text&#x2F;List focus mode’.</td>
</tr>
<tr>
<td align="left">Qt::WheelFocus</td>
<td align="left">StrongFocus &#124; 0x4</td>
<td align="left">like Qt::StrongFocus plus the widget accepts focus by using the mouse wheel.</td>
</tr>
<tr>
<td align="left">Qt::NoFocus</td>
<td align="left">0</td>
<td align="left">the widget does not accept focus.</td>
</tr>
</tbody></table>
<h1 id="焦点原因"><a href="#焦点原因" class="headerlink" title="焦点原因"></a>焦点原因</h1><h3 id="Qt-FocusReason"><a href="#Qt-FocusReason" class="headerlink" title="Qt::FocusReason"></a>Qt::FocusReason</h3><table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt::MouseFocusReason</td>
<td align="left">0</td>
<td align="left">A mouse action occurred.</td>
</tr>
<tr>
<td align="left">Qt::TabFocusReason</td>
<td align="left">1</td>
<td align="left">The Tab key was pressed.</td>
</tr>
<tr>
<td align="left">Qt::BacktabFocusReason</td>
<td align="left">2</td>
<td align="left">A Backtab occurred. The input for this may include the Shift or Control keys; e.g. Shift+Tab.</td>
</tr>
<tr>
<td align="left">Qt::ActiveWindowFocusReason</td>
<td align="left">3</td>
<td align="left">The window system made this window either active or inactive.</td>
</tr>
<tr>
<td align="left">Qt::PopupFocusReason</td>
<td align="left">4</td>
<td align="left">The application opened&#x2F;closed a pop-up that grabbed&#x2F;released the keyboard focus.</td>
</tr>
<tr>
<td align="left">Qt::ShortcutFocusReason</td>
<td align="left">5</td>
<td align="left">The user typed a label’s buddy shortcut</td>
</tr>
<tr>
<td align="left">Qt::MenuBarFocusReason</td>
<td align="left">6</td>
<td align="left">The menu bar took focus.</td>
</tr>
<tr>
<td align="left">Qt::OtherFocusReason</td>
<td align="left">7</td>
<td align="left">Another reason, usually application-specific.</td>
</tr>
</tbody></table>
<h1 id="焦点信号"><a href="#焦点信号" class="headerlink" title="焦点信号"></a>焦点信号</h1><p><code>QApplication</code> 的信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusChanged</span><span class="params">(QWidget *old, QWidget *now)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="焦点次序"><a href="#焦点次序" class="headerlink" title="焦点次序"></a>焦点次序</h1><p>相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回此部件焦点链中的下一个部件</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::nextInFocusChain</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 返回此部件焦点链中的前一个部件</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::previousInFocusChain</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将焦点顺序中的部件 second 放置在部件 first 之后</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setTabOrder</span><span class="params">(QWidget *, QWidget *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过按 <code>Tab</code> 或者 <code>Shift+Tab</code>，可以实现焦点在各个窗口之间循环移动。</p>
<ul>
<li><p>点击 <code>Tab</code> 键，焦点向后查找，直至找到第一个 <code>FocusPolicy</code> 大于等于 <code>TabFocus</code> 的窗口，并设置该窗口为焦点窗口;</p>
</li>
<li><p>点击 <code>Shift+Tab</code> ，焦点向前查找，直至找到第一个 <code>FocusPolicy</code>  大于等于 <code>TabFocus</code> 的窗口，并设置该窗口为焦点窗口;</p>
</li>
</ul>
<p>默认情况下, 先加入的 <code>QWidget</code> 焦点顺序越靠前。可以通过 <code>setTabOrder</code> 调整顺序.</p>
<p>比如，若默认的焦点链顺序为 <code>a-b-c-d</code> ，则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTabOrder(d,c); //改变后焦点链的顺序为 a-b-d-c</span><br><span class="line">setTabOrder(b,a); //改变后焦点链的顺序为 b-a-d-c</span><br></pre></td></tr></table></figure>

<h1 id="焦点切换"><a href="#焦点切换" class="headerlink" title="焦点切换"></a>焦点切换</h1><p>相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于focusNextPrevChild(true)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusNextChild</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 等同于focusNextPrevChild(false)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusPreviousChild</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// next==true：设置焦点链中下个`FocusPolicy`为`TabFocus`的窗口为焦点窗口</span></span><br><span class="line"><span class="comment">// next==false：设置焦点链中前一个`FocusPolicy`为`TabFocus`的窗口为焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusNextPrevChild</span><span class="params">(<span class="type">bool</span> next)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口为焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocus</span><span class="params">(Qt::FocusReason reason)</span></span>;</span><br><span class="line"><span class="comment">// 取消焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::clearFocus</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="焦点代理"><a href="#焦点代理" class="headerlink" title="焦点代理"></a>焦点代理</h1><p>代为接收焦点事件。比如，<code>Widget A</code> 是 <code>Widget B</code> 的焦点代理，则当 <code>B</code> 获得焦点时，实际获得并处理焦点的是 <code>A</code>。相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回该窗口的焦点代理</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::focusProxy</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">//设置该窗口的焦点代理为w</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocusProxy</span><span class="params">(QWidget* w)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>焦点</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
