<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 中 malloc 和 new 的区别</title>
    <url>/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">new</th>
<th align="center">malloc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">关键字</td>
<td align="center">标准库函数</td>
</tr>
<tr>
<td align="center">支持语言</td>
<td align="center"><code>C/C++</code></td>
<td align="center">只在 <code>C++</code></td>
</tr>
<tr>
<td align="center">申请内存的位置</td>
<td align="center">自由存储区 <code>free store</code></td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">分配内存的大小</td>
<td align="center">编译器根据类型信息自行计算</td>
<td align="center">显示指定字节数</td>
</tr>
<tr>
<td align="center">内存分配失败</td>
<td align="center">抛出 <code>bac_alloc</code> 异常, 不会返回 <code>NULL</code></td>
<td align="center">返回 <code>NULL</code></td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">返回对象类型的指针</td>
<td align="center">返回<code>void</code> 指针，需要转换</td>
</tr>
<tr>
<td align="center">是否调用构造函数/析构函数</td>
<td align="center">调用</td>
<td align="center">不调用</td>
</tr>
<tr>
<td align="center">处理数组</td>
<td align="center"><code>new[]</code></td>
<td align="center">手动指定数组的大小</td>
</tr>
<tr>
<td align="center">是否支持重载</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">是否支持内存扩充</td>
<td align="center">不支持</td>
<td align="center"><code>realloc</code></td>
</tr>
<tr>
<td align="center">内存释放方式</td>
<td align="center"><code>new/delete</code>, <code>new[]/delete[]</code></td>
<td align="center"><code>malloc/free</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 1：将C++视作一系列的语言</title>
    <url>/2020/12/07/effecitve-cpp/effective-cpp-1/</url>
    <content><![CDATA[<blockquote>
<p>Item 1: View C++ as a federation of languages</p>
</blockquote>
<p>一开始，<code>Ｃ++</code> 只是 <code>Ｃ</code> 加上一些面向对象特性，<code>Ｃ++</code> 最初的名称 <code>Ｃ with Classes</code> 也反映了这个血缘关系。现在这个语言逐渐成熟，已经是一个<strong>多重泛型编程语言</strong>(<code>multiparadigm programming language</code>)。同时支持过程形式(<code>procedural</code>)、面向对象形式(<code>object-oriented</code>)、函数形式(<code>functional</code>)、泛型形式(<code>generic</code>)、元编程形式(<code>metaprogramming</code>)</p>
<p>将 <code>C++</code> 视为一个由相关语言组成的联邦而非单一的语言。</p>
<p><code>C++</code> 主要４个子语言：</p>
<ul>
<li><code>C</code>。说到底Ｃ++仍是以Ｃ为基础。许多时候Ｃ++对问题的解法其实不过就是较高级的Ｃ的解法如<code>item2</code>、<code>item13</code>。当只使用<code>C++</code>中<code>C</code>的那部分语法，　会发现<code>C</code>语言的缺陷：没有模板、没有异常、没有重载。</li>
<li><code>Object-Oriented</code>。面向对象程序设计也是<code>C++</code>的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。</li>
<li><code>Template C++</code>。这是C++的泛型编程部分，大多数程序员经验最少的部分。<strong>TMP模板元编程</strong>（<code>template metaprogramming</code>）也是一个新兴的程序设计范式。</li>
<li><code>STL</code>。<code>STL</code>是一个特殊的模板库，它将容器、迭代器和算法优雅地结合在一起。</li>
</ul>
<p><code>C++</code> 程序设计的惯例并非一成不变，而是取决于你使用 <code>C++</code> 语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触 <code>Object-Oriented C++</code> 时会发现，传常量指针是更好的选择。运用<code>Template C++</code>时尤其如此，因为彼时你甚至不知道所处理的对象的类型。 但是你如果又碰到了<code>STL</code>，其中的迭代器和函数对象都是基于<code>C</code>语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 10：赋值运算符要返回自己的引用</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-10/</url>
    <content><![CDATA[<blockquote>
<p>Item 10：Have assignment operators return a reference to *this.</p>
</blockquote>
<p>赋值运算符要返回自己的引用只是个协议，并无强制性。这份协议被所有内置类型和标准程序库提供的类型如<code>string</code>, <code>vector</code>, <code>complex</code> <code>std::shared_ptr</code>等共同遵守。可以用来支持链式的赋值语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>; <span class="comment">//赋值连锁形式</span></span><br></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = ( y = ( z = <span class="number">15</span> ) );</span><br></pre></td></tr></table></figure>

<p>我们自定义的对象最好也能支持链式的赋值，这需要重载=运算符时返回当前对象的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;   </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算 +=, -=, *=, etc.</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs)&#123;  </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 11：赋值运算符需要考虑自我赋值问题</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-11/</url>
    <content><![CDATA[<blockquote>
<p>Item 11: Handle assignment to self in operator=</p>
</blockquote>
<p>我们在重载一个类的赋值运算符时要考虑自我赋值的问题。有了指针和引用自我赋值不总是第一时间能够识别出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line">*px = *py;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> Base&amp; rb, Derived* pd)</span></span>;<span class="comment">// rb和女pd 有可能其实是同一对象</span></span><br><span class="line">rb = pd;</span><br></pre></td></tr></table></figure>

<p>自我赋值主要考虑到 <strong>自我赋值安全性</strong> 和 <strong>异常安全性</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">//指针，指向一个从heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既不自我赋值安全性也不异常安全性, 当 rhs == *this时，delete pb使得rhs.pb成为空值，接下来 new 的数据便是空的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断两个地址是否相同，如果是自我赋值，就不做任何事。但开始就delete pb， 但 new 出现异常， pb就会置空出现风险。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 证同测试</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中<strong>仔细地排列语句顺序</strong>通常可以达到异常安全， 比如我们可以先申请空间，最后再delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap *pOrig = pb;  </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更加通用的技术便是复制和交换（copy and swap）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this rhs 的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget temp(rhs); <span class="comment">//rhs 数据制作一份复件(副本)</span></span><br><span class="line">    swap (temp); <span class="comment">//*this 数据和上述复件的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 12：复制对象时勿忘其每一个成分</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-12/</url>
    <content><![CDATA[<blockquote>
<p>Item 12: Copy all parts of an object</p>
</blockquote>
<p>正确拷贝函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Customer(<span class="keyword">const</span> Customer&amp; rhs): name(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="情形一：-新添加了一个数据成员，忘记了更新拷贝函数"><a href="#情形一：-新添加了一个数据成员，忘记了更新拷贝函数" class="headerlink" title="情形一： 新添加了一个数据成员，忘记了更新拷贝函数"></a>情形一： 新添加了一个数据成员，忘记了更新拷贝函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  Date lastTransaction;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Customer(<span class="keyword">const</span> Customer&amp; rhs): name(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时 <code>lastTransaction</code> 便被你忽略了，编译器也不会给出任何警告（即使在最高警告级别）</p>
<h3 id="情形二：-继承父类忘记了拷贝父类的部分"><a href="#情形二：-继承父类忘记了拷贝父类的部分" class="headerlink" title="情形二： 继承父类忘记了拷贝父类的部分"></a>情形二： 继承父类忘记了拷贝父类的部分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : priority(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确写法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : Customer(rhs), priority(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 13：以对象管理资源</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-13/</url>
    <content><![CDATA[<blockquote>
<p>Item 13: Use objects to manage resources.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 14：在资源管理类中小心 copying 行为</title>
    <url>/2021/11/04/effecitve-cpp/effective-cpp-14/</url>
    <content><![CDATA[<blockquote>
<p>Item 14: Think carefully about copying behavior in resource-managing classes.</p>
</blockquote>
<p>设计一个 <strong><code>RAII</code></strong> 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>:<span class="title">mutexPtr</span><span class="params">(pm)</span></span>&#123;</span><br><span class="line">        lock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Lock()&#123; unlock(mutexPtr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户对<code>Lock</code>的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <strong><code>RAII</code></strong> 对象被复制，会发生什么事？ 不确定？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(&amp;ml1)</span></span></span><br></pre></td></tr></table></figure>

<p>记住<strong>资源管理对象的拷贝行为取决于资源本身的拷贝行为，同时资源管理对象也可以根据业务需要来决定自己的拷贝行为</strong>。一般有如下四种方式：</p>
<ul>
<li><p><strong>禁止复制</strong>。参考<a href="#">Post not found: effective-cpp-6 若不想使用编译器自动生成的函数，就该明确拒绝</a>。对Lock而言看起来是这样：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> :</span> <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>引用计数</strong>，采用 <code>shared_ptr</code> 的逻辑。<code>shared_ptr</code> 构造函数提供了第二个参数 <code>deleter</code>，当引用计数到 <code>0</code> 时被调用。 所以 <code>Lock</code> 可以通过聚合一个 <code>shared_ptr</code> 成员来实现引用计数：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: <span class="title">mutexPtr</span><span class="params">(pm, unlock)</span></span>&#123;</span><br><span class="line">        lock(mutexPtr.get());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr; <span class="comment">//shared_ptr替换 raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>   <code>Lock</code> 的析构会引起 <code>mutexPtr</code> 的析构，而 <code>mutexPtr</code> 计数到0时<code>unlock(mutexPtr.get())</code> 会被调用。</p>
</li>
<li><p><strong>拷贝底部资源</strong>。复制资源管理对象时，进行的是<strong>深拷贝</strong>。比如 <code>string</code> 的行为：内存存有指向对空间的指针，当它被复制时会复制那片空间。</p>
</li>
<li><p><strong>转移底部资源的拥有权</strong>。<code>auto_ptr</code> 就是这样做的，把资源移交给另一个资源管理对象，自己的资源置空。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 15：在资源管理类中提供对原始资源的访问</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-15/</url>
    <content><![CDATA[<blockquote>
<p>Item 15: Provide access to raw resources in resource-managing classes.</p>
</blockquote>
<p><code>APIs</code> 往往要求访问原始资源(<code>raw resources</code>)，所以每一个RAII class 应该<strong>提供提供对原始资源访问的方法。获取资源的方式有两类：隐式地获取和显式地获取。</strong> 显式的资源获取会更安全，它最小化了无意中进行类型转换的机会。</p>
<ul>
<li><strong>显示获取</strong></li>
</ul>
<p><code>shared_ptr</code> 提供了 <code>get</code> 方法来得到资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Investment&gt; pInv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daysHeld</span><span class="params">(Investment *pi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = daysHeld(pInv.get());</span><br></pre></td></tr></table></figure>

<p>为了让 <code>pInv</code> 表现地更像一个指针，<code>shared_ptr</code>还重载了解引用运算符（<code>dereferencing operator</code>） <code>operator-&gt;</code>和 <code>operator*</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> taxable1 = !(pi1-&gt;isTaxFree());</span><br><span class="line"><span class="keyword">bool</span> texable2 = !((*pi1).isTaxFree());</span><br></pre></td></tr></table></figure>

<p>我们封装了Font来管理资源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line">FontHandle f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span>: <span class="title">f</span><span class="params">(fh)</span></span>&#123;&#125;</span><br><span class="line">    ~Font()&#123; releaseFont(f); &#125;;</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过get方法来访问FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">changeFontSize(f.get(), newFontSize);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>隐式地获取</strong></li>
</ul>
<p>可以隐式类型转换运算符将 <code>Font</code> 转换为 <code>FontHandle</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> f;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">changeFontSize(f, newFontSize);</span><br></pre></td></tr></table></figure>

<p>然而问题也随之出现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FontHandle h2 = f1;</span><br></pre></td></tr></table></figure>
<p>无意间 <code>h2</code> 并没有被资源管理起来，这将会引发意外的资源泄漏。所以隐式转换在提供便利的同时， 也引起了资源泄漏的风险。 </p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 16：使用同样的形式来new和delete</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-16/</url>
    <content><![CDATA[<blockquote>
<p>Item 16: Use the same form in corresponding uses of new and delete.</p>
</blockquote>
<p><strong>如果你用 <code>new</code> 申请了动态内存，请用 <code>delete</code> 来销毁；如果你用 <code>new xx[]</code> 申请了动态内存，请用 <code>delete[]</code> 来销毁</strong>: </p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtrl = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[lOO];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringptrl;      <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;  <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure>

<p>上面很容易理解但需要注意<code>typedef</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> AddressLines[<span class="number">4</span>];    <span class="comment">//每个人的地址有四行，</span></span><br><span class="line">                                        <span class="comment">//每行是一个string</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>AddressLines</code> 是个数组，如果这样使用 <code>new</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> *pal = <span class="keyword">new</span> AddressLines;     <span class="comment">//注意. &quot;new AddressLines&quot; 返回</span></span><br><span class="line">                                         <span class="comment">//一个 string*，就像 &quot;new string[4]&quot; 一样</span></span><br></pre></td></tr></table></figure>
<p>那就必须匹配 “<strong>数组形式</strong>“的 <code>delete</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pal;         <span class="comment">//行为未有定义!</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;     <span class="comment">//很好。</span></span><br></pre></td></tr></table></figure>

<p>为避免诸如此类的错误，最好尽量不要对数组形式做 <code>typedefs</code> 动作。可以使用更加面向对象的<code>vector</code>、<code>string</code>等对象。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 17：在单独的语句中将 new 的对象放入智能指针</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-17/</url>
    <content><![CDATA[<blockquote>
<p>Item 17: Store newed objects in smart pointers in standalone statements.</p>
</blockquote>
<p><strong>以单独的语句将 <code>new</code> 的对象放入智能指针内。这是为了防止由于其他表达式抛出异常而导致的资源泄漏</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>

<p>上述代码中，在 <code>processWidget</code> 函数被调用之前参数会首先得到计算。可以认为包括三部分的过程：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
<li>调用 <code>priority()</code></li>
</ol>
<p><strong>因为C++不同于其他语言，函数参数的计算顺序很大程度上决定于编译器</strong>，编译器认为顺序应当是1, 3, 2，即：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>调用 <code>priority()</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
</ol>
<p>那么如果 <code>priority</code>抛出了异常，新的 <code>Widget</code> 便永远地找不回来了。虽然我们使用了智能指针，但资源还是泄漏了！</p>
<p>于是更加健壮的实现中，应当将创建资源和初始化智能指针的语句独立出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Widget&gt; pw = <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 18：让接口容易被正确使用，不易被误用</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-18/</url>
    <content><![CDATA[<blockquote>
<p>Item 18: Make interfaces easy to use correctly and hard to use incorrectly.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 2：尽量以const, enum, inline 替换 &amp;#35;define</title>
    <url>/2020/12/14/effecitve-cpp/effective-cpp-2/</url>
    <content><![CDATA[<blockquote>
<p>Item 2: Prefer consts, enums, and inlines to #defines</p>
</blockquote>
<p>我们先看看<code>#deifne</code> 有哪些的问题:</p>
<h1 id="不利于调试"><a href="#不利于调试" class="headerlink" title="不利于调试"></a>不利于调试</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ASPECT_RATION 1.653</span><br></pre></td></tr></table></figure>
<p>在预处理时候 <code>ASPECT_RATION</code> 可能就被移走了,<code>ASPECT_RATION</code> 没有进入 符号表, 运行此常量获得编译错误信息时, 可能会疑惑。因为这个错误信息总是提到 <code>1.653</code>，而不是<code>ASPECT_RATION</code> ， 如果 <code>ASPECT_RATION</code> 定义不是自己写的头文件中，可能对 <code>1.653</code> 的来源毫无概念，将因追踪它浪费时间，解决之道是以一个常量替换上述宏 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏</span></span><br><span class="line">                                 <span class="comment">//因此这里改变名称写法</span></span><br></pre></td></tr></table></figure>
<p>作为一个语言常量，<code>ASPECT_RATION</code> 肯定会被编译器看到，当然会进入记号表内。此外对于浮点常量(<code>floating point constant</code>)而言，使用常量可能比使用<code>#define</code> 导致较少量的码。</p>
<h1 id="不重视scope"><a href="#不重视scope" class="headerlink" title="不重视scope"></a>不重视scope</h1><p>无法利用 <code>#define</code> 创建<code>class</code>专属常量。一旦宏定义，它就在其后的编译过程中有效（除非在某处 <code>#undef</code> ）。而 <code>const</code> 可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns; <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];      <span class="comment">//使用该常量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum-比-const-更好用"><a href="#enum-比-const-更好用" class="headerlink" title="enum 比 const 更好用"></a>enum 比 const 更好用</h2><p>旧式编译器也许不支持上述语法，　它们不允许static在声明式上获得初值，此外所谓的“<code>in-classs　初值设定</code>”也只运行对<strong>整数常量</strong>进行，　如果编译器不支持上述语法，可以将初值放在定义式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;  <span class="comment">//staitc class　常量声明位于头文件内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>; <span class="comment">//staitc class　常量定义位于实现文件内</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>emnu</code>就很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];　<span class="comment">//the enum hack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　</p>
<h1 id="不易理解"><a href="#不易理解" class="headerlink" title="不易理解"></a>不易理解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b)  f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);     　<span class="comment">//ａ被累加二次</span></span><br><span class="line">CALL_WITH_MAX(++a, b + <span class="number">10</span>);　<span class="comment">//ａ被累加一次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须记住为宏的所有实参加上小括号</li>
<li>在这里调用ｆ之前，ａ的递增次取决与“它被拿来与谁比较”</li>
</ul>
<p>更好的做法是使用　<code>template inline</code>　函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 3：尽可能使用 const</title>
    <url>/2021/01/05/effecitve-cpp/effective-cpp-3/</url>
    <content><![CDATA[<blockquote>
<p>Item3: Use const whenever possible.</p>
</blockquote>
<h1 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h1><p>指针的常量声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* p = greeting;                 <span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;           <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;           <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;     <span class="comment">//const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>const</code> 出现在<code>*</code>左边，表示被指物为常量;　如果出现在<code>*</code>右边，表示指针自身为常量；如果出现在<code>*</code>两边，表示被指物和指针两者都是常量。</p>
<p>如果被指物是常量，<code>const</code> 放在类型之前和放在类型之后<code>*</code>之前表示的意义一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* p)</span></span>;　<span class="comment">//f1　获得一个指针，指向一个常量Ｗidget对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(widget <span class="keyword">const</span> *p)</span></span>;　<span class="comment">//f2 也是</span></span><br></pre></td></tr></table></figure>


<p>STL的<code>iterator</code> 系以指针塑模出来，所以<code>iterator</code>的作用像个<code>T*</code>指针。如果希望指针是常量，可以声明为 <code>const iterator</code>，如果希望被指物为常量，需使用 <code>const_iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();    <span class="comment">//iter的作用像个Ｔ* const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                             <span class="comment">//没问题，改变iter所指物  </span></span><br><span class="line">++iter;　　　　　　　　　　　　　　　　　　　　　　 　　　　     <span class="comment">//错误，iter是const</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin();   <span class="comment">//cIter的作用像个const Ｔ*</span></span><br><span class="line">*cIter = <span class="number">10</span>;                                            <span class="comment">//错误，*cIter是const</span></span><br><span class="line">++cIter;                                                <span class="comment">//没问题，　改变cIter</span></span><br></pre></td></tr></table></figure>
<p>返回值声明为常量，可以降低代码被错误使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>　&#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*&#123;<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们本来想做个比较，错误地输入<code>=</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) ...</span><br></pre></td></tr></table></figure>
<p>编译器就会报错误：不可给常量赋值。</p>
<h1 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h1><p>声明const 成员函数，是为了确认该成员函数可以作用与const对象，也使class接口比较容易理解，可以得知哪些函数可以改动对象内容，哪些不可以。</p>
<p>成员函数只是常量性不同是可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span>   <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// const objects</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)               <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// non-const objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;             <span class="comment">// fine — writing a non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;            <span class="comment">// error! — writing a const TextBlock</span></span><br></pre></td></tr></table></figure>

<h1 id="bitsise-constness-和-logical-constness"><a href="#bitsise-constness-和-logical-constness" class="headerlink" title="bitsise constness 和　logical constness"></a>bitsise constness 和　logical constness</h1><p><code>bitsise constness</code>: 成员函数只有在不改变对象的任何非静态成员变量时才可以被称为常量函数。也是C++对常量性的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pText[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TextBlock tb;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;tb[<span class="number">1</span>];</span><br><span class="line">*p = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>函数调用<code>const</code>函数可以避免代码重复。不可以反着来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">            [position]</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>*this</code> 的类型是 <code>TextBlock</code>，先把它强制隐式转换为 <code>const TextBlock</code>，这样我们才能调用那个常量方法。</li>
<li>调用 <code>operator[](std::size_t) const</code>，得到的返回值类型为 <code>const char&amp;</code>。</li>
<li>把返回值去掉 <code>const</code> 属性，得到类型为 <code>char&amp;</code> 的返回值。</li>
</ol>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 4：确定对象被使用前已先被初始化</title>
    <url>/2021/01/13/effecitve-cpp/effective-cpp-4/</url>
    <content><![CDATA[<blockquote>
<p>Item 4: Make sure that objects are initialized before they’re used.</p>
</blockquote>
<h1 id="手工初始化内置对象"><a href="#手工初始化内置对象" class="headerlink" title="手工初始化内置对象"></a>手工初始化内置对象</h1><p>为内置对象进行手工初始化，因为<code>C++</code>不保证初始化他们。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;                                  <span class="comment">//对 int 进行手工初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *text = <span class="string">&quot;A C-style string&quot;</span>;      <span class="comment">//对指针进行手工初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d;                              <span class="comment">//以读取 input stream 的方式完成初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="构造函数最好使用成员初值列"><a href="#构造函数最好使用成员初值列" class="headerlink" title="构造函数最好使用成员初值列"></a>构造函数最好使用成员初值列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="keyword">int</span> numTimesConsulted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones) &#123;</span><br><span class="line">    theName = name;             <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address;       <span class="comment">//而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在<code>class</code>中的声明次序相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones) : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="local-static-对象替换-non-local-static-对象。"><a href="#local-static-对象替换-non-local-static-对象。" class="headerlink" title="local static 对象替换 non-local static 对象。"></a><code>local static</code> 对象替换 <code>non-local static</code> 对象。</h1><p>为免除”跨单元之初始化次序“问题，请以 <code>local static</code> 对象替换 <code>non-local static</code> 对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;     </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory( params );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory::Directory( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户使用使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params )</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在初始化次序的重要性体现出来了，除非 <code>tfs</code> 在 <code>tempDir</code> 之前先被初始化，否则<code>tempDir</code>的构造函数会用到尚未初始化的<code>tfs</code>。但<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源文件建立起来的，它们是定义于不同编译单元内的 <code>non-local static</code> 对象。它们初始化相对次序并无明确定义。但我们可以将 <code>local static</code> 对象替换<code>non-local static</code> 对象来解决。这也是<strong>Singleton</strong>模式的常见实现手法。</p>
<p>这个手法的基础在于：C++保证，函数内的 <code>local static</code> 对象会在调用该函数时首次遇上该对象的定义式时被初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line">Directory::Directory( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 5：了解c++默默编写并调用哪些函数</title>
    <url>/2021/10/24/effecitve-cpp/effective-cpp-5/</url>
    <content><![CDATA[<blockquote>
<p>Item 5: Know what functions C++ silently writes and calls</p>
</blockquote>
<h1 id="默认函数"><a href="#默认函数" class="headerlink" title="默认函数"></a>默认函数</h1><p>在 <code>C++</code> 中，一个类有八个默认函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line">    Empty () &#123;&#125; <span class="comment">//默认构造函数    </span></span><br><span class="line">    Empty (<span class="keyword">const</span> Empty &amp;) &#123;&#125; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    Empty (<span class="keyword">const</span> Empty &amp;&amp;) &#123;&#125; <span class="comment">// 默认移动构造函数(`C++11`)</span></span><br><span class="line">    ~Empty() &#123;&#125; <span class="comment">// 默认析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp;) &#123;&#125; <span class="comment">// 默认重载赋值运算符函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp;&amp;)&#123;&#125; <span class="comment">// 默认重载移动赋值操作符函数函数</span></span><br><span class="line">    Empty* <span class="keyword">operator</span> &amp;() &#123;&#125; <span class="comment">// 默认重载取址运算符函数</span></span><br><span class="line">    <span class="keyword">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="keyword">const</span> &#123;&#125; <span class="comment">// 默认重载取址运算符 `const` 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h1><p>只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。</p>
<h1 id="引用成员"><a href="#引用成员" class="headerlink" title="引用成员"></a>引用成员</h1><p>如果你打算在一个“内含引用成员”或者“内含<code>const</code>成员”的类内支持赋值操作，就必须定义自己的默认拷贝赋值操作符。因为 <code>C++</code> 本身不允许引用改指不同的对象，也不允许更改 <code>const</code> 成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> &amp; name;</span><br><span class="line">    Person(<span class="built_in">string</span> &amp;str):name(str) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">Person p1(s1), p2(s2);</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: object of type &#39;Person&#39; cannot be assigned because its copy assignment operator is implicitly deleted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-6/</url>
    <content><![CDATA[<blockquote>
<p>Item 6: Explicitly disallow the use of compiler-generated functions you do not want.</p>
</blockquote>
<p>在C++中，编译器会自动生成一些你没有显式定义的函数。可以参考:<a href="/2021/10/24/effecitve-cpp/effective-cpp-5/" title="了解c++默默编写并调用哪些函数">了解c++默默编写并调用哪些函数</a><br>然而有时候我们希望禁用掉这些函数，可以通过把自动生成的函数设为 <code>private</code> 来禁用它或者在 <code>c++11</code> 中使用 <code>delete</code> 关键字。</p>
<p>比如我们禁用拷贝的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HomeForSale(<span class="keyword">const</span> HomeForSale &amp;);  <span class="comment">// 只有声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp;) = <span class="keyword">delete</span>； <span class="comment">// c++11</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以专门设计一个阻止<code>copying</code> 的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> noncopyable_ &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> &#123;</span></span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            noncopyable() &#123;&#125;</span><br><span class="line">            ~noncopyable()&#123;&#125;</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable() = default;</span></span><br><span class="line"><span class="comment">            ~noncopyable() = default;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            noncopyable(<span class="keyword">const</span> noncopyable&amp;);</span><br><span class="line">            noncopyable&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            noncopyable&amp; operator=( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> :</span> <span class="keyword">private</span> noncopyable_::noncopyable</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HomeForSale p1, p2;</span><br><span class="line">p1 = p2;</span><br><span class="line"></span><br><span class="line">error: object of type &#x27;HomeForSale&#x27; cannot be assigned because its copy assignment operator is implicitly deleted</span><br><span class="line">    p1 = p2;</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 7：为多态基类声明 virtual 析构函数</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-7/</url>
    <content><![CDATA[<blockquote>
<p>Item 7: Declare destructors virtual in polymorphic base classes.</p>
</blockquote>
<p>析构函数声明为虚函数目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。 否则子类部分的内存将会泄漏，正确的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper *ptk = getTimeKeeper():  <span class="comment">// 可能返回任何一种子类</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>

<ul>
<li>polymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果<br>class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。</li>
<li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性<br>(polymorphically) ，就不该声明 virtual 析构函数。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 8：析构函数不要抛出异常</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-8/</url>
    <content><![CDATA[<blockquote>
<p>Item 8: Prevent exceptions from leaving destructors.</p>
</blockquote>
<p><code>C++</code> 本身不阻止在析构函数抛出异常，但在析构函数中抛出的异常往往会难以捕获，引发程序非正常退出或未定义行为。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~Widget() &#123; ... &#125; <span class="comment">//假设这里可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;  <span class="comment">// v 这里被自动析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。</p>
<p>不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在 <code>C++</code> 中，不要让析构函数抛出异常！</p>
<p>但是如果析构函数所使用的代码可能无法避免抛出异常呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span>&#123;</span>                   <span class="comment">//某用来建立数据库连接的类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;     <span class="comment">//建立一个连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;                     <span class="comment">//关闭一个连接，假设可以抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span>                         <span class="comment">//创建一个资源管理类来提供更好的用户接口</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    ~DBConn&#123; db.close(); &#125;            <span class="comment">//终止时自动调用关闭连接的方法</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...&#123;                                 </span><br><span class="line">  <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>; <span class="comment">//创建一个DBConn类的对象</span></span><br><span class="line">  ...                                 <span class="comment">//使用这个对象</span></span><br><span class="line">&#125;                                     <span class="comment">//对象dbc被释放资源</span></span><br><span class="line">          </span><br></pre></td></tr></table></figure>

<p>析构函数所调用的 <code>close()</code> 方法可能会抛出异常，那么有什么方法来解决呢？</p>
<p><strong>吞掉异常</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.close();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>主动关闭程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.close();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把可能抛出异常的代码移出析构函数</strong></p>
<p>客户在需要关闭的时候主动调用 <code>close()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~DBConn();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;        <span class="comment">//当要关闭连接时，手动调用此函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    closed = <span class="literal">false</span>;      <span class="comment">//显示连接是否被手动关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBConn::close</span><span class="params">()</span></span>&#123;    <span class="comment">//当需要关闭连接，手动调用此函数</span></span><br><span class="line">  db.close();</span><br><span class="line">  closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DBConn::~DBcon()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!closed)            <span class="comment">//析构函数还是要留有备用，但不用每次都承担风险了</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      db.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line">      <span class="comment">//记录访问历史</span></span><br><span class="line">      <span class="comment">//消化异常或者主动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析<br>构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 <code>class</code> 应该提<br>供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 9：绝不在构造和析构过程中调用 virtual 函数</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-9/</url>
    <content><![CDATA[<blockquote>
<p>Item 9: Never call virtual functions during construction or destruction.</p>
</blockquote>
<p>在构造和析构期间不要调用 <code>virtual</code> 函数，因为这类调用不会下降至 <code>derived class</code><br>(比起当前执行构造函数和析构函数的那层)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span>                               <span class="comment">// base class for all</span></span><br><span class="line"><span class="keyword">public</span>:                                           <span class="comment">// transactions</span></span><br><span class="line">    Transaction()&#123;                                <span class="comment">// base class ctor           </span></span><br><span class="line">        logTransaction();                         <span class="comment">// as final action, log this               </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;      <span class="comment">// make type-dependent</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;        <span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;          <span class="comment">// how to log trans-</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p><code>b</code> 在构造时，调用到父类Transaction的构造函数，其中对 <code>logTransaction</code> 的调用会被解析到 <code>Transaction</code> 类。 那是一个纯虚函数，因此程序会非正常退出。</p>
<p>在<code>derived class</code> 对象的 <code>base class</code> 构造期间，对象的类型是 <code>base class</code> 而不是 <code>derived classo</code> 不只 <code>virtual</code> 函数会被编译器解析至(resolve to) <code>base class</code> ，若使用运行期类型信息 <code>RTTI</code>(runtime type information, 例如 <code>dynamic_cast</code>  <code>typeid</code>) ，也会把对象视为 <code>base class</code> 类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">this</span>).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">this</span>).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P11Transaction</span><br><span class="line">P14BuyTransaction</span><br></pre></td></tr></table></figure>

<p><strong>相同道理也适用于析构函数.</strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 19：设计 class 犹如设计 type</title>
    <url>/2021/11/11/effecitve-cpp/effective-cpp-19/</url>
    <content><![CDATA[<blockquote>
<p>Item 19: Teat class design as type design.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之tr</title>
    <url>/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/</url>
    <content><![CDATA[<p><code>Linux</code> 中 <code>tr</code> 命令用于转换或删除文件中的字符。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tr [OPTION] SET1 [SET2]</span></span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c, --complerment：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换;</span><br><span class="line">-d, --delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s, --squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t, --truncate-set1：先删除第一字符集较第二字符集多出的字符;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>字符集1(<code>SET1</code>)：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数 “字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</li>
<li>字符集2(<code>SET2</code>)：指定要转换成的目标字符集。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol>
<li><p>小写字母转换为大写字母:</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;HELLO WORLD&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -d &#x27;0-9&#x27;</span><br><span class="line">hello  world</span><br><span class="line"></span><br><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -cd &#x27;0-9&#x27;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></li>
<li><p>压缩字符</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello          world&quot; | tr -s &#x27;[:space:]&#x27;</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">➜  share echo &quot;hellooooo worldddddddddddd&quot; | tr -s &#x27;od&#x27; </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用的字符类"><a href="#常用的字符类" class="headerlink" title="常用的字符类"></a>常用的字符类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:print:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件MIME类型</title>
    <url>/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="什么是-MIME-类型？"><a href="#什么是-MIME-类型？" class="headerlink" title="什么是 MIME 类型？"></a>什么是 MIME 类型？</h1><p><code>MIME</code>（多用途 <code>Internet</code> 邮件扩展）的类型来识别文件格式。 <code>MIME</code> 类型构成了 <code>Internet</code> 上对文件类型进行分类的标准方法。</p>
<ul>
<li><code>MIME Type</code>是用于描述文件的类型的一种表述方法，其将文件划分为多种类型，方便对其进行统一的管理。</li>
<li><code>MIME Type</code>指定了文件的类型名称、描述、图标信息，同时通过与.desktop应用程序描述文件整合，指定了文件的打开方式。</li>
</ul>
<a id="more"></a>
<p><code>MIME</code> 类型名字遵循指定的格式：</p>
<p>类型和子类型， 在 MIME 类型中，类型和子类型不区分大小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">media-type&#x2F;subtype-identifier</span><br></pre></td></tr></table></figure>

<p>目前，有十种注册类型：<code>application</code>，<code>audio</code>，<code>example</code>，<code>font</code>，<code>image</code>，<code>message</code>，<code>model</code>，<code>multipart</code>，<code>text</code>和<code>video</code>。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipart&#x2F;form-data</span><br><span class="line">text&#x2F;xml</span><br><span class="line">text&#x2F;csv</span><br><span class="line">text&#x2F;plain</span><br><span class="line">application&#x2F;xml</span><br><span class="line">application&#x2F;zip</span><br><span class="line">application&#x2F;pdf</span><br></pre></td></tr></table></figure>

<p>完整MIME 类型示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application&#x2F;vnd.api+json</span><br></pre></td></tr></table></figure>

<p><code>application</code>作为类型，<code>api</code>作为子类型，<code>vnd</code>是厂商前缀，<code>+json</code>是后缀，表示可以解析为<code>JSON</code>。</p>
<h1 id="获取文件的-MIME-类型"><a href="#获取文件的-MIME-类型" class="headerlink" title="获取文件的 MIME 类型"></a>获取文件的 MIME 类型</h1><h2 id="xdg-mime命令"><a href="#xdg-mime命令" class="headerlink" title="xdg-mime命令"></a>xdg-mime命令</h2><ul>
<li><p>显示文件的<code>MIME</code>类型：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query filetype &#123;file&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query filetype one.jpg </span><br><span class="line">image/jpeg</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示<code>MIME</code> 类型的默认应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &#123;mimetype&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query default image/jpeg</span><br><span class="line">/usr/share/applications/deepin-image-viewer.desktop</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>显示文件默认应用程序的语法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &quot;$(xdg-mime query filetype &#123;file&#125;)&quot;</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default \</span><br><span class="line">    `xdg-mime query filetype &quot;$(find ~ / -iname &#x27;*.png&#x27; -print -quit)&quot;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>MIME</code> 类型的默认打开应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dekstop filetype</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dde-file-manager.desktop inode/directtory</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a>file 命令</h2><ul>
<li><p>查询文件类型：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file --mime-type INPUT_FILE</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ file --mime-type one.jpg </span><br><span class="line">one.jpg: inode&#x2F;symlink</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="自定义的-MIME-类型"><a href="#自定义的-MIME-类型" class="headerlink" title="自定义的 MIME 类型"></a>自定义的 MIME 类型</h1><p>如需为系统上的所有用户添加一个自定义的 <code>MIME</code> 类型，并为该 <code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>/usr/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，在 <code>/usr/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<p>比如我们创建一个<code>application/x-newtype</code>类型：</p>
<ol>
<li><p>创建 /usr/share/mime/packages/application-x-newtype.xml 文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;mime-info xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.freedesktop.org&#x2F;standards&#x2F;shared-mime-info&quot;&gt;</span><br><span class="line">&lt;mime-type type&#x3D;&quot;application&#x2F;x-newtype&quot;&gt;</span><br><span class="line">    &lt;comment&gt;new mime type&lt;&#x2F;comment&gt;</span><br><span class="line">    &lt;glob pattern&#x3D;&quot;*.xyz&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mime-type&gt;</span><br><span class="line">&lt;&#x2F;mime-info&gt;</span><br></pre></td></tr></table></figure>
<p> 上述 <code>application-x-newtype.xml</code> 文件定义了一种新的 <code>MIME</code> 类型<code>application/x-newtype</code>，并指定拓展名是 <code>.xyz</code> 的文件为该 <code>MIME</code> 类型。</p>
</li>
<li><p>创建一个名为例如 <code>myapplication1.desktop</code> 的新的 <code>.desktop</code> 文件，并将它放置在 <code>/usr/share/applications/</code> 目录下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">MimeType&#x3D;application&#x2F;x-newtype</span><br><span class="line">Name&#x3D;My Application 1</span><br><span class="line">Exec&#x3D;myapplication1</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新 <code>MIME</code> 数据库以使您的更改生效：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-mime-database /usr/share/mime</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新应用程序数据库：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-desktop-database /usr/share/applications</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如需为个别用户添加自定义的 <code>MIME</code> 类型，并为该<code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>~/.local/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，并在 <code>~/.local/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/desktop_migration_and_administration_guide/file_formats">配置文件关联</a></p>
</li>
<li><p><a href="https://www.baeldung.com/linux/file-mime-types">file-mime-types</a></p>
</li>
<li><p><a href="https://specifications.freedesktop.org/mime-apps-spec/mime-apps-spec-latest.html">mime-apps-spec</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mime</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 20：传常量引用比传值更好</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-20/</url>
    <content><![CDATA[<blockquote>
<p>Item 20: Prefer pass-by-reference-to-const to pass-by-value.</p>
</blockquote>
<p>缺省情况下<code>C++</code> 用传值得方式(一个继承自<code>C</code>的方式)传递对象至(或来自)函数。除非你另外指定，否则函数参数都是以实际实参的复件(副本)为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件(副本)系由对象的<code>copy</code>构造函数产出。</p>
<p><strong>尽量以传常量引用替换传值前者通常比较高效，并可避免切割问题 (<code>slicing problem</code>)，但是内置类型和 <code>STL</code> 迭代器，还是传值更加合适。</strong>。</p>
<a id="more"></a>

<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题:"></a>性能问题:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person ();</span><br><span class="line">    <span class="keyword">virtual</span> -Person();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student();</span><br><span class="line">    -Student();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑以下代码，其中调用函数 <code>validateStudent</code> ，后者需要一个 <code>Student</code><br>(<code>by value</code>) 并返回它是否有效:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;           <span class="comment">// function taking a Student by value</span></span><br><span class="line"></span><br><span class="line">Student plato;                             <span class="comment">// Plato studied under Socrates</span></span><br><span class="line"><span class="keyword">bool</span> platoIsOK = validateStudent(plato);   <span class="comment">// call the functio</span></span><br></pre></td></tr></table></figure>

<p>在调用 <code>validateStudent(</code>) 时进行了 <strong>6</strong> 个函数调用：</p>
<ol>
<li><code>Person</code> 的拷贝构造函数，为什么 <code>Student</code> 的拷贝构造一定要调用 <code>Person</code> 的拷贝构造请参见：<a href="/2021/11/02/effecitve-cpp/effective-cpp-12/" title="Item:12 复制对象时勿忘其每一个成分">Item:12 复制对象时勿忘其每一个成分</a></li>
<li><code>Student</code> 的拷贝构造函数</li>
<li><code>name</code>, <code>address</code>, <code>schoolName</code>, <code>schoolAddress</code> 的拷贝构造函数</li>
</ol>
<p>解决办法便是传递常量引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先以引用的方式传递，不会构造新的对象，避免了上述例子中 <strong>6</strong> 个构造函数的调用。 同时 const 也是必须的：传值的方式保证了该函数调用不会改变原来的 <code>Student</code>， 而传递引用后为了达到同样的效果，需要使用 <code>const</code> 声明来声明这一点，让编译器去进行检查!</p>
<h2 id="截断问题"><a href="#截断问题" class="headerlink" title="截断问题"></a>截断问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">// return name of window</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// draw window and contents</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowWithScrollBars</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在假设你希望写个函数打印窗口名称，然后显示该窗口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span></span></span><br><span class="line">    std::cout &lt;&lt; w.name();</span><br><span class="line">    w.display() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line">printNameAndDisplay(wwsb);</span><br></pre></td></tr></table></figure>

<p>当调用 <code>printNameAndDisplay</code> 时参数类型从 <code>WindowWithScrollBars</code> 被隐式转换为 <code>Window</code>。 该转换过程通过调用 <code>Window</code> 的拷贝构造函数来进行。 导致的结果便是函数中的 <code>w</code> 事实上是一个 <code>Window</code> 对象， 并不会调用多态子类 <code>WindowWithScrollBars</code> 的 <code>display()</code>。</p>
<p>正确做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fine, parameter won&#x27;t be sliced</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="keyword">const</span> Window&amp; w)</span></span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name();</span><br><span class="line">    w.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>一般情况下相比于传递值，传递常量引用是更好的选择。但也有例外情况，比如 <strong>内置类型</strong> 和 <strong>STL 迭代器</strong>和<strong>函数对象</strong>。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 21：需要返回对象时，不要返回引用</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-21/</url>
    <content><![CDATA[<blockquote>
<p>Don’t to return a reference when you must return an object.</p>
</blockquote>
<p>Item 20 中提到，多数情况下传引用比传值更好。但不要无脑追求这一点，一定不要返回空引用或指针。</p>
<a id="more"></a>

<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> n, d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Raitonal(<span class="keyword">int</span> numerator=<span class="number">0</span>, <span class="keyword">int</span> denominator=<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为什么是const请参考Item 3</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a, b;</span><br><span class="line">Rational c = a*b;</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>operator*</code> 返回的是一个实例，<code>a*b</code>时便会调用<code>operator*()</code>， 返回值被拷贝后用来初始化<code>c</code>。</p>
<p>不考虑编译器优化和 <code>C11</code> 的 <code>move</code> ,这个过程涉及到多个构造和析构过程：</p>
<ol>
<li><code>operator*</code>调用结束前，返回值被拷贝，调用拷贝构造函数</li>
<li><code>operator*</code>调用结束后，返回值被析构</li>
<li><code>c</code> 被初始化，调用拷贝构造函数</li>
</ol>
<p>我们能否通过传递引用的方式来避免这些函数调用？这要求在函数中创建那个要被返回给调用者的对象，而函数只有两种办法来创建对象：在栈空间中创建、或者在堆中创建。</p>
<p>在栈空间中创建显然是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n*rhs.n, lhs.d*rhs.d)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目标是要避免调用构造函数，而 <code>result</code> 却必须像任何对象一样地由构造函数构造起, 而且得到的 <code>result</code> 永远是空。因为 <code>result</code> 是一个 <code>local</code> 对象，当函数调用结束后 <code>result</code>即被销毁。</p>
<p>在堆中创建也会问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  Rational *result  = <span class="keyword">new</span> Rational(lhs.n*rhs.n, lhs.d*rhs.d);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是得必须付出一个”构造函数调用”代价， 并且谁去 <code>delete</code>?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x*y*z;</span><br></pre></td></tr></table></figure>

<p>上面这样合理的代码都会导致内存泄露。</p>
<p>使用静态变量的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">static</span> Rational result; <span class="comment">// static 对象，此函数将返回</span></span><br><span class="line">    result = ... ; <span class="comment">// lhs 乘以 rhs. 并将结果置于 result 内。</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量首先便面临着线程安全问题，除此之外当我们需要不止一个的返回值同时存在时也会产生问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a*b) == (c*d))&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果operator*的返回值是静态变量，那么上述条件判断恒成立，因为等号两边是同一个对象。所以我们还是老老实实返回对象实例就好，并且考虑到编译器优化和<code>move</code>语意，拷贝构造返回值带来的代价没那么高。</p>
<p><strong>永远不要返回局部对象的引用或指针或堆空间的指针，如果需要多个返回对象时也不能是局部静态对象的指针或引用</strong>。<a href="/2021/01/13/effecitve-cpp/effective-cpp-4/" title="Item:4 确定对象被使用前已先被初始化">Item:4 确定对象被使用前已先被初始化</a>， 对于单例模式，返回局部静态对象的引用也是合理的。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 22：将成员变量声明为private</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-22/</url>
    <content><![CDATA[<blockquote>
<p>Declare data members private.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>在UOS中文件管理器匿名访问共享修改文件导致文件变成只读根因分析报告</title>
    <url>/2022/03/23/linux/%E5%9C%A8UOS%E4%B8%AD%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%9B%B4%E6%94%B9%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="在UOS中文件管理器匿名访问共享修改文件导致文件变成只读根因分析报告"><a href="#在UOS中文件管理器匿名访问共享修改文件导致文件变成只读根因分析报告" class="headerlink" title="在UOS中文件管理器匿名访问共享修改文件导致文件变成只读根因分析报告"></a>在UOS中文件管理器匿名访问共享修改文件导致文件变成只读根因分析报告</h1><h2 id="一、相关术语"><a href="#一、相关术语" class="headerlink" title="一、相关术语"></a>一、相关术语</h2><table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">全称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Samba</code></td>
<td align="center"><code>Samba</code></td>
<td align="center">Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务</td>
</tr>
<tr>
<td align="center"><code>GVFS</code></td>
<td align="center"><code>GNOME Virtual file system</code></td>
<td align="center"><code>GVFS</code> 是 <code>GNOME</code> 桌面系统的虚拟文件系统，通过 <code>GVFS</code> ，用户可以很容易的通过 <code>SFTP</code>、<code>FTP</code>、<code>WebDAV</code>、<code>SMB</code>等访问远程数据，通过 <code>HAL integration</code>、<code>OBEX</code> 等访问本地数据</td>
</tr>
<tr>
<td align="center"><code>GIO</code></td>
<td align="center"><code>GIO</code></td>
<td align="center">作为 <code>GLIB</code> 的一部分的新共享库，提供了针对 <code>GVFS</code> 的 <code>API</code></td>
</tr>
</tbody></table>
<h2 id="二、问题概述"><a href="#二、问题概述" class="headerlink" title="二、问题概述"></a>二、问题概述</h2><p>【复现步骤】</p>
<p>1、<code>用户A</code> 在uos系统中准备一个包含文件的文件夹，并且<code>用户A</code> 对文件和文件夹具有可读可写权限。</p>
<p>2、<code>用户A</code> 通过文件管理器共享准备好的文件夹，并设置允许匿名访问。</p>
<p>3、<code>用户B</code> 通过文件管理器匿名访问这个共享文件夹并且修改共享目录中的文件。</p>
<p>4、修改的共享文件变为了只读，<code>用户 A</code> 无法再修改。</p>
<a id="more"></a>
<p>【期望】</p>
<p>共享文件，<code>用户A</code> 和 <code>用户B</code> 都可以修改，可读写。</p>
<p>【环境】</p>
<p>硬件：该问题与硬件无关，在多个平台都能复现</p>
<p>系统：<code>uos 1021</code></p>
<p>文管：跟文件管理器版本无关</p>
<p><code>GVFS</code> : 1.38.1-5</p>
<p><code>samba</code> : 2:4.9.5.4-1+deepin4</p>
<h2 id="三、问题分析"><a href="#三、问题分析" class="headerlink" title="三、问题分析"></a>三、问题分析</h2><p>【分析】</p>
<p><code>用户A</code> 准备好共享文件夹，在终端查看文件权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总用量 8</span><br><span class="line">drwxr-xr-x  2 yngty yngty 4096 11月 20 20:42 .</span><br><span class="line">drwxr-xr-x 37 yngty yngty 4096 11月 20 20:41 ..</span><br><span class="line">-rw-r--r--  1 yngty yngty    0 11月 20 20:42 1.txt</span><br><span class="line">-rw-r--r--  1 yngty yngty    0 11月 20 20:42 2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>用户A</code> 对 <code>1.txt</code> 和 <code>2.txt</code> 是具有可读可写权限。<code>用户B</code> 通过文件管理器访问共享并修改 <code>1.txt</code> 后， <code>用户A</code>再次在终端查看文件权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总用量 12</span><br><span class="line">drwxrwxrwx  2 yngty  yngty   4096 11月 20 20:48 .</span><br><span class="line">drwxr-xr-x 37 yngty  yngty   4096 11月 20 20:47 ..</span><br><span class="line">-rwxr--r--  1 nobody nogroup    1 11月 20 20:48 1.txt</span><br><span class="line">-rw-r--r--  1 yngty  yngty      0 11月 20 20:42 2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>1.txt</code>的文件权限发生了更改，文件属主具有读、写和执行权限，属组和其他用户只具有读权限。并且文件属主更改为 <code>nobody</code>，文件属组更改为 <code>nogroup</code>。</p>
<p>现在 <code>1.txt</code> 是属于 <code>nobody</code> 了， 我们查看下 <code>nobody</code> 和 <code>用户A</code> 的信息，在 <code>/etc/passwd</code> 下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yngty@yngty-PC:~&#x2F;test_samba$ cat &#x2F;etc&#x2F;passwd| grep -E &quot;nobody|yngty&quot;</span><br><span class="line">nobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin</span><br><span class="line">yngty:x:1000:1000::&#x2F;home&#x2F;yngty:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p><code>yngty</code> 是 <code>用户A</code> 相对于 <code>nobody</code> 属于其他用户， 所以对 <code>1.txt</code> 只有可读权限。</p>
<p>在修改共享文件后，<code>用户A</code> 不能修改说明共享的文件，权限发生了改变。那么造成该现象有三种可能：</p>
<ul>
<li>第一：文件管理器的共享功能有问题，导致用户访问通过文件管理器共享出来的文件后修改文件会导致权限不正确。</li>
<li>第二：文件管理器访问共享有问题，导致用户访问后修改后权限不正确。</li>
<li>第三：<code>smb</code>协议实现的问题，<code>smb</code>读写会修改文件权限。</li>
</ul>
<p>首先对第一种情况进行测试，<code>用户A</code> 不通过文件管理器共享文件夹， 直接修改<code>smb</code>配置，配置个<code>test</code> 共享文件夹并支持匿名访问：</p>
<p>在 <code>/etc/samba/smb.cnf</code> 文件最后面增加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[test]</span><br><span class="line">   comment &#x3D; test smb</span><br><span class="line">   path &#x3D; &#x2F;home&#x2F;yngty&#x2F;test_smb</span><br><span class="line">   browseable &#x3D; yes</span><br><span class="line">   usershare allow guests &#x3D; yes</span><br><span class="line">   guest ok &#x3D; yes</span><br><span class="line">   read only &#x3D; no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>用户B</code> 通过文件管理器访问 <code>test</code>共享文件夹，修改文件后，文件的权限还是改变了和复现步骤结果一模一样，排除了文件管理器共享功能出的问题。继续往下排查。</p>
<p><code>uos</code> 中的文件管理器使用 <code>samba</code> 功能， 是采用 <code>GVFS</code> 提供的服务。</p>
<ul>
<li><p>什么是<code>GVFS</code></p>
<blockquote>
<p><code>GVFS</code>是GNOME桌面系统的虚拟文件系统，通过<code>GVFS</code>，用户可以很容易的通过<code>SFTP</code>、<code>FTP</code>、<code>WebDAV</code>、<code>SMB</code>等访问远程数据，通过<code>HAL integration</code>、<code>OBEX</code>等访问本地数据。(<code>GVFS</code> 是 <code>GNOME-VFS</code> 的替代品， 可以理解为<code>GNOME-VFS</code>已被废弃)</p>
</blockquote>
<blockquote>
<p><code>GVFS</code> 包含两个部分：<br><code>GIO</code>，作为 <code>GLib</code>的一部分的新共享库，提供了针对 <code>GVFS</code> 的 <code>API</code>；<br><code>GVFS</code> 本身是一个包含多种文件系统和协议（如<code>SFTP</code>， <code>FTP</code>， <code>DAV</code>， <code>SMB</code> 和 <code>ObexFTP</code>）支持的后台软件包。<br><code>GVFS</code>致力于提供一个现代的，易用的 VFS 系统。它的目标是提供一些列 API 给开发者，以是他们不再使用原始的 POSIX IO 访问。它提供了一个更高级的以文件为中心的接口，而不仅仅是 POSIX IO 的复制品。除了文件的读写支持外，GIO 还提供了文件监视工具，异步 IO，和文件名完成功能。</p>
</blockquote>
<blockquote>
<p><code>GVFS</code> 通过运行一个单独的主守护进程 (<code>GVFSD</code>) 来工作，它保证了对当前的 <code>GVFS</code> 挂载的跟踪。每一个挂载都有独立的守护进程。(一些挂载也会同时共享一个进程，但多数情况下不会这样。) 客户端通过一个联合 <code>D-Bus</code> 会话来与这些挂载通信(在会话总线上，但是使用点对点 <code>D-Bus</code>)，同时用一个用户协议来进操作文件内容。通过进程进行后台传递大大简化了程序的依赖关系，使整个系统更加健壮。</p>
</blockquote>
<blockquote>
<p><code>GVFS</code> 也提供了在 <code>/run/user/1000/GVFS</code>提供了一个 <code>FUSE</code> 挂载点，这样可以使得 <code>GVFS</code> 挂载可以被传统的使用标准 <code>POSIX IO</code>的应用程序使用。 </p>
</blockquote>
</li>
</ul>
<p><img src="/images/gvfs.png" alt="GVFS架构设计图"></p>
<!-- <br>
<center>
    <img src="../../images/gvfs.png">
    <center>GVFS架构设计图</center>
</center> 

<br> -->

<p><code>GVFS</code> 框架比较庞大，可以在<code>/usr/lib/gvfs/</code>目录下看到很多<code>gvfs</code>开头的应用程序。我们只需要关注跟 <code>samba</code> 相关的部分。</p>
<ul>
<li><code>gvfsd-*</code> 为每个对应协议<code>protocol</code>的后端<code>daemon</code>程序。 </li>
<li> 通过 <code>gvfsd-smb</code> 实现了对 <code>samba</code> 共享的访问、读写、挂载等。</li>
<li> 通过 <code>gvfsd-smb-browse</code> 实现了在网络上查找并安装 <code>samba</code> 共享文件夹。</li>
<li> <code>gvfsd-smb</code> 和 <code>gvfsd-smb-browse</code> 底层都是依赖 <code>libsmbclient</code> 实现 <code>smaba</code> 相关的操作。</li>
<li> 通过 <code>gvfsd-fuse</code> 为<code>fuse</code>提供支持，保证传统使用标准 <code>POSIX IO</code> 的程序无须改动代码即可访问远。</li>
</ul>
<p><code>GVFS</code> 支持 <code>samba</code> 功能调用的是<code>gvfs-smb</code>，底层调用的<code>libsmbclient</code>， 我们可以写一个 <code>demo</code> 来验证直接匿名调用<code>libsmbclient</code>读写接口文件权限是否会改变：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc， <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SMBCCTX *context;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> debug = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line">    smbc_stat_fn smbc_stat;</span><br><span class="line">    <span class="comment">/* Allocate a new context */</span></span><br><span class="line">    context = smbc_new_context();</span><br><span class="line">    <span class="keyword">if</span> (!context)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not allocate new smbc context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tell the compatibility layer to use this context */</span></span><br><span class="line">    smbc_setWorkgroup(context， <span class="string">&quot;WORKGROUP&quot;</span>);</span><br><span class="line">    smbc_setFunctionAuthDataWithContext(context， auth_callback);</span><br><span class="line">    smbc_setOptionUseKerberos(context， <span class="number">1</span>);</span><br><span class="line">    smbc_setOptionFallbackAfterKerberos (context， <span class="number">1</span>);</span><br><span class="line">    smbc_setOptionNoAutoAnonymousLogin(context， <span class="number">0</span>); <span class="comment">// 匿名访问</span></span><br><span class="line">    smbc_set_context(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the context using the previously specified options */</span></span><br><span class="line">    <span class="keyword">if</span> (!smbc_init_context(context))</span><br><span class="line">    &#123;</span><br><span class="line">        smbc_free_context(context， <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not initialize smbc context\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = smbc_open(<span class="string">&quot;smb://localhost/test_samba/1.txt&quot;</span>， O_WRONLY， <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;smbc_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buffer， <span class="keyword">sizeof</span>(buffer)， <span class="string">&quot;%s&quot;</span>， <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = smbc_write(fd， buffer， <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    smbc_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">auth_callback(SMBCCTX *context，</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span> *server_name， <span class="keyword">const</span> <span class="keyword">char</span> *share_name，</span><br><span class="line">              <span class="keyword">char</span> *domain_out， <span class="keyword">int</span> domainmaxlen，</span><br><span class="line">              <span class="keyword">char</span> *username_out， <span class="keyword">int</span> unmaxlen，</span><br><span class="line">              <span class="keyword">char</span> *password_out， <span class="keyword">int</span> pwmaxlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;auth_callback\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 用户和密码传空</span></span><br><span class="line">    <span class="built_in">strncpy</span>(username_out， <span class="string">&quot;&quot;</span>， <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(password_out， <span class="string">&quot;&quot;</span>， <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写前后 <code>1.txt</code> 文件权限并没有没有发生更改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用前:</span><br><span class="line">yngty@smile:~&#x2F;test_samba$ ls -al</span><br><span class="line">总用量 8</span><br><span class="line">drwxrwxrwx  2 yngty yngty 4096 11月 23 13:40 .</span><br><span class="line">drwxr-xr-x 39 yngty yngty 4096 11月 23 11:44 ..</span><br><span class="line">-rwxrw-rw-  1 yngty yngty    0 11月 23 13:40 1.txt</span><br><span class="line">调用后:</span><br><span class="line">yngty@smile:~&#x2F;test_samba$ ls -al</span><br><span class="line">总用量 12</span><br><span class="line">drwxrwxrwx  2 yngty yngty 4096 11月 23 13:40 .</span><br><span class="line">drwxr-xr-x 39 yngty yngty 4096 11月 23 11:44 ..</span><br><span class="line">-rwxrw-rw-  1 yngty yngty   12 11月 23 13:41 1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>排除了第三种，<code>smb</code>协议实现的问题。<code>libsmbclient</code> 的读写不会修改文件权限。</p>
<ul>
<li>缩小问题范围</li>
</ul>
<p>我们监听原用户<code>用户A</code>共享目录，查看文件权限发生了什么变化。 <code>gio monitor</code> 提供了此功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yngty@yngty-PC:~&#x2F;test_samba$ gio monitor .&#x2F;</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: created</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: changes done</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: attributes changed</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: changed</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: changes done</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: attributes changed</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;1.txt: deleted</span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;~gvfwUIj.tmp: renamed to &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;1.txt</span><br><span class="line"></span><br><span class="line">.&#x2F;: &#x2F;home&#x2F;yngty&#x2F;test_samba&#x2F;1.txt: attributes changed</span><br></pre></td></tr></table></figure>

<p>我们发现文件保存时是先临时创建了<code>tmp</code>文件，然后进行文件操作后将原文件删除，最后将临时文件修改为原文件名。<br>查看 <code>GVFS</code> 源码，在<code>gvfsbackendsmb.c</code>，发现 <code>do_replace</code>函数， 这个函数功能是</p>
<ul>
<li>1）保存到tmp文件</li>
<li>2）将orig文件重命名为备份文件，如果没有备份，则将其删除</li>
<li>3）将tmp文件重命名为orig文件</li>
</ul>
<p>我们在函数加入打印日志，证明调用了此函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_replace (GVfsBackend *backend，</span><br><span class="line">	    GVfsJobOpenForWrite *job，</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *filename，</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *etag，</span><br><span class="line">	    gboolean make_backup，</span><br><span class="line">	    GFileCreateFlags flags)</span><br><span class="line">&#123;</span><br><span class="line">    g_debug(<span class="string">&quot;come here: do_replace...filename = %s\n&quot;</span>);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行gvfs， <code>用户B</code> 按照实验步骤操作，查看输出日志，的确输出了我们的打印日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open_for_write_new_handle_common.............</span><br><span class="line">smb: backend_dbus_handler org.gtk.vfs.Mount:OpenForWriteFlags (pid&#x3D;29846)</span><br><span class="line">smb: Queued new job 0x7f6ebc014270 (GVfsJobOpenForWrite)</span><br><span class="line">smb: send_reply(0x558cb0)， failed&#x3D;0 ()</span><br><span class="line">come here: do_replace...filename &#x3D; &#x2F;3.txt</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>【思考】</p>
<p>那么现在问题的轮廓应该是：权限改变的原因是 <code>GVFS</code> 先创建临时文件。那么 <code>GVFS</code> 在 <code>samba</code>创建的文件的权限依据是什么？</p>
<p>查阅<code>samba</code>文档可知:</p>
<ul>
<li><p><code>guest account</code></p>
<p>  指定匿名访问的用户名，默认值为 <code>nobody</code></p>
</li>
<li><p><code>create mask</code> </p>
<p>  创建文件的掩码，默认值是 <code>0744</code>。 在<code>samba</code>中创建的文件将从该参数创建的<code>UNIX</code>模式与默认情况下设置为<code>000</code>的<code>force create mode</code>参数值进行位“或”运算 。</p>
</li>
<li><p><code>force create mode</code></p>
<p>  默认值是 <code>0000</code>，见上面的描述。相当于此参数中所设置的权限位一定会出现在文件的属性中。</p>
</li>
<li><p><code>directory mode</code></p>
<p>  创建目录的掩码，默认值是 <code>0755</code>，在<code>samba</code>中创建的文件还需要与默认情况下设置为 <code>000</code> 的 <code>force directory mode</code> 参数值进行位“或”运算 。</p>
</li>
<li><p><code>force directory mode</code><br>  默认值是 <code>0000</code>，见上面的描述。相当于此参数中所设置的权限位一定会出现在目录的属性中。</p>
</li>
</ul>
<p>查看 <code>libsmbclient</code> 源码中也发现了默认<code>guest account</code> 是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef GUEST_ACCOUNT</span><br><span class="line">#define GUEST_ACCOUNT &quot;nobody&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这与我们实验步骤创建的文件的属主名一致。</p>
<p>创建的文件和目录的权限是根据 <code>samba</code>服务器中的<code>smb.conf</code>配置创建文件和创建目录的权限，<br><code>create mask</code> 、<code>force create mode</code> 、 <code>directory mode</code> 、 <code>force directory mode</code>。默认情况下文件属组权限和其他用户权限没有写和执行权限。对<code>nobody</code> 来讲原用户属于其他用户所以只有读没有了写权限。接下来用实验进行验证。</p>
<h2 id="四、实验验证"><a href="#四、实验验证" class="headerlink" title="四、实验验证"></a>四、实验验证</h2><p>【实验环境】</p>
<p>系统：<code>uos 1021</code></p>
<p>文管：跟文件管理器版本无关</p>
<p><code>GVFS</code> : 1.38.1-5</p>
<p>【实验设计】</p>
<p><strong>实验一、修改 samba配置 <code>guest</code> 用户</strong></p>
<p>修改共享目录服务器 <code>smb.conf</code> 配置， 修改 <code>guest account</code>为共享文件夹用户的用户名。</p>
<p>在 /etc/samba/smb.cnf 文件中 <code>global</code> 项下面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security &#x3D; user</span><br><span class="line">guest account &#x3D; yngty #yngty 是用户A的当前用户名</span><br></pre></td></tr></table></figure>

<p>然后重启 <code>SMB</code> 服务 <code>sudo systemctl restart smbd.service</code></p>
<p>【实验验证】</p>
<p><code>用户B</code> 按照实验步骤去访问共享并修改文件，原用户终端下查看共享目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总用量 8</span><br><span class="line">drwxr-xr-x  2 yngty yngty 4096 11月 20 20:42 .</span><br><span class="line">drwxr-xr-x 37 yngty yngty 4096 11月 20 20:41 ..</span><br><span class="line">-rwxr--r--  1 yngty yngty    0 11月 20 20:42 1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然还是匿名访问修改文件，但 <code>1.txt</code> 的属主和属组是<code>yngty</code>不再是默认<code>nobody</code> 和 <code>nogroup</code>，确定修改配置是生效的。所以原用户还是具有可写权限，原用户去读写修改文件也是可以正确操作。</p>
<p><strong>实验二、修改<code>samba</code>配置中文件和目录的创建权限</strong></p>
<p><code>用户A</code> 修改共享目录服务器 <code>smb.conf</code> 配置，增加文件和目录的组权限和其他权限都支持可读可写。</p>
<p>在 <code>/etc/samba/smb.cnf</code> 文件中 <code>global</code> 项下面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create mask &#x3D; 0766</span><br><span class="line">force create mode &#x3D; 0766</span><br><span class="line">directory mode &#x3D; 0766</span><br><span class="line">force directory mode &#x3D; 0766</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后重启 <code>SMB</code> 服务<code>sudo systemctl restart smbd.service</code></p>
<p>【实验验证】</p>
<p><code>用户B</code> 按照实验步骤去访问共享并修改文件，原用户终端下查看共享目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总用量 8</span><br><span class="line">drwxrwxrwx  2 yngty  yngty   4096 11月 20 20:48 .</span><br><span class="line">drwxr-xr-x 37 yngty  yngty   4096 11月 20 20:47 ..</span><br><span class="line">-rwxrw-rw-  1 nobody nogroup    1 11月 20 20:48 1.txt</span><br></pre></td></tr></table></figure>
<p>发现文件 <code>1.txt</code> 的属主和属组还是<code>nobody</code>和 <code>nogroup</code>，但文件的组权限其他用户权限具有了可写权限，确定修改配置是生效的。对于原用户 <code>用户A</code> 也是可写。</p>
<h2 id="五、解决方案"><a href="#五、解决方案" class="headerlink" title="五、解决方案"></a>五、解决方案</h2><p>根据上述实验可知，我们可以修改匿名访问用户名，为共享文件夹用户的用户名和 <code>smaba</code> 中创建文件和目录的权限来解决问题。</p>
<p><strong>方案一：修改<code>samba</code> 配置 <code>guest</code> 用户</strong></p>
<p>文件管理器在匿名访问的时候没有指定用户，默认使用<code>nobody</code>， 我们可以将<code>guest</code> 用户修改为当前用户，这样匿名访问的就是使用的当前用户，就不存在当前用户没有权限的问题。</p>
<p>此方法为有效的解决方式，但可行性低。在<code>uos</code>系统中可以多用户运行，不同用户要使用此功能都需要修改对应的<code>samba</code>配置为当前的用户，而且用户之间还会互相影响。</p>
<p><strong>方案二：修改<code>samba</code>配置中文件和目录的创建权限</strong></p>
<p>修改<code>samba</code>配置的默认文件和目录的创建权限如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create mask &#x3D; 0766</span><br><span class="line">force create mode &#x3D; 0766</span><br><span class="line">directory mode &#x3D; 0766</span><br><span class="line">force directory mode &#x3D; 0766</span><br></pre></td></tr></table></figure>

<p>虽然文件是<code>nobody</code>创建的但文件的属组和其他用户都有可读可写权限， 原用户和匿名访问用户都能够读写。不足的地方就是所有用户都具有读写权限，不是绝对的安全。享受了便利性就失去了绝对的安全。</p>
<p><strong>方案三：修改 <code>GVFS</code> 的源码，修改共享文件后，不改变文件权限</strong></p>
<p>这个问题可以算是 <code>GVFS</code> 的 <code>bug</code>，可以修改 <code>GVFS</code> 的源码，修改共享文件后，不改变文件权限。</p>
<p><strong>方案比较</strong></p>
<table>
<thead>
<tr>
<th align="center">方案</th>
<th align="center">性能</th>
<th align="center">稳定</th>
<th align="center">安全</th>
<th align="center">易用</th>
<th align="center">兼容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">修改<code>samba</code> 配置 <code>guest</code> 用户</td>
<td align="center">对性能都影响极小</td>
<td align="center">不稳定，多用户之间会互相影响</td>
<td align="center">安全性不高，可以伪装为当前共享用户</td>
<td align="center">开发复杂，需要对每个用户定制修改，需要其他项目组协助</td>
<td align="center">不需要改动文件管理器代码</td>
</tr>
<tr>
<td align="center">修改<code>samba</code>配置中文件和目录的创建权限</td>
<td align="center">对性能都影响极小</td>
<td align="center">稳定</td>
<td align="center">不是绝对安全，所有用户都具有可写权限</td>
<td align="center">修改简单，多用户支持，不需要重新修改</td>
<td align="center">不需要改动文件管理器代码</td>
</tr>
<tr>
<td align="center">修改 <code>GVFS</code> 的源码，修改共享文件后，不改变文件权限</td>
<td align="center">对性能都影响极小</td>
<td align="center">稳定</td>
<td align="center">安全</td>
<td align="center">修改较复杂，多用户支持，不需要重新修改</td>
<td align="center">不需要改动文件管理器代码</td>
</tr>
</tbody></table>
<p>方案一改动复杂，不同用户还会互相影响，方案二能够解决该问题，且改动对其它代码影响较小，方案三最有可能从根本上解决掉该问题，但需要花费较多时间、改动较复杂，可以作为改进的方向。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>【方案敲定】</p>
<p>根据上述对方案分析，方案一从可行性方面被否决，考虑到时间成本，方案二可以作为现阶段的最优解，将方案三作为改进的方向，所以现阶段最终采用方案二。</p>
<p>【问题总结】</p>
<p>问题根因：<code>GVFS</code> 中的<code>SMB</code>访问是将<code>SMB</code>挂载到本地一个文件系统，文件的修改是先创建一个临时文件，修改数据，删掉原文件，最后将文件重命名为原文件名。创建临时文件的用户是当前访问共享的用户，匿名访问就是<code>nobody</code>，创建文件的权限根据 <code>samba</code>服务器中的<code>smb.conf</code>配置文件设置的权限，默认情况文件属组和其他组没有可写可执行权限。文件属主的改变导致原用户没有了可写权限。</p>
<p>解决方案：修改<code>samba</code>配置中文件和目录的创建权限为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create mask &#x3D; 0766</span><br><span class="line">force create mode &#x3D; 0766</span><br><span class="line">directory mode &#x3D; 0766</span><br><span class="line">force directory mode &#x3D; 0766</span><br></pre></td></tr></table></figure>
<p>根因查找步骤：现象-&gt;分析-&gt;思考-&gt;实验-&gt;验证-&gt;结论。</p>
<p>关键步骤：监听目录文件改变，查看 <code>GVFS</code> 源码， 找到权限改变的根因。</p>
<p>改进/优化：修改 <code>GVFS</code> 的源码，修改共享文件后，不改变文件权限。</p>
<h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><ul>
<li><a href="https://gitlab.gnome.org/GNOME/GVFS">GVFS源码</a></li>
<li><a href="https://wiki.gnome.org/Projects/GVFS/backends">Backends for GVFS 1.30.0</a></li>
<li><a href="https://git.samba.org/samba.git">samba源码</a></li>
<li><a href="http://cn.linux.vbird.org/linux_basic/0210filepermission.php">linux的文件权限与目录配置</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Samba">维基百科samba介绍</a> </li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>UOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 23：用非成员函数、非友元函数替换成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-23/</url>
    <content><![CDATA[<blockquote>
<p>Prefer non-member non-friend functions to member functions</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 24：若所有参数皆需类型转换，请采用非成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-24/</url>
    <content><![CDATA[<blockquote>
<p>Declare non-member functions when type conversions should apply all parameters.</p>
</blockquote>
<p>令 <code>classes</code> 支持隐式转换通常是糟糕的设计，但也有例外，最常见的是在建立数值类型时。 比如设计一个有理数 <code>class</code> 允许整数隐式转换。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>); <span class="comment">//构造函数刻意不使用 explicit; 允许 int-to-Rational 隐式转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时我们想设计一个乘法，该使用 <code>member</code> 函数，还是 <code>non-member</code> 函数， 还是 <code>non-member-friend</code> 函数？</p>
<p>我们先采用 <code>member</code> 函数看有什么问题？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用如下没有什么问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational result = oneEighth * oneHalf; <span class="comment">//ok</span></span><br><span class="line">result = result * oneEighth;  <span class="comment">// ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但当我们想支持混合运算，那 <code>Rational</code> 和 <code>ints</code> 相乘, 就只有一半行的通。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">//ok  隐式转换</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">// no</span></span><br></pre></td></tr></table></figure>

<p>当我们设计成 <code>non-member</code> 函数就都支持：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(), lhs.denominator(), rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;  <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth;  <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>

<p><strong>如果需要为某个函数的所有参数进行类型转换，那这个函数必须是 <code>non-member</code></strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 25：设计一个不抛异常的 swap 函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-25/</url>
    <content><![CDATA[<blockquote>
<p>Consider support for a non-throwing swap.</p>
</blockquote>
<p><code>swap</code> 函数能置换两对象值，功能很重要!</p>
<ul>
<li>异常安全性编程</li>
<li>处理自我赋值可能性：<a href="/2021/11/01/effecitve-cpp/effective-cpp-11/" title="赋值运算符需要考虑自我赋值问题">赋值运算符需要考虑自我赋值问题</a></li>
</ul>
<p><code>std</code> 的缺省基本实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="类的-swap"><a href="#类的-swap" class="headerlink" title="类的 swap"></a>类的 swap</h2><p>只要类型 <code>T</code> 支持 <code>copying</code>运算(拷贝构造和拷贝赋值运算)就能使用。 但缺省实现会有多次拷贝，在某些情况下不是性能最好的实现。比如针对 <code>pimpl</code> 手法实现的 <code>class</code>, 不仅要复制三次 <code>Widget</code> 还需要复制三次 <code>WdigetImpl</code>, 非常缺乏效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp;);</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实我们发现这种情况只需要将 <code>pImpl</code> 指针交换就好， 我们可以将 <code>std::swap</code> 对 <code>Widget</code> 的特化来实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        swap(a.pImpl, b.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上述代码不能通过编译， 因为 <code>pImpl</code> 是私有变量， 所以，<code>Widget</code> 应当提供一个 <code>swap</code> 成员函数或友元函数。 惯例上会提供一个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 为何要这样？请看下文</span></span><br><span class="line">        swap(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;</span><br><span class="line">      a.swap(b);              <span class="comment">// 调用成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现与 STL 容器是一致的：<strong>提供公有 <code>swap</code> 成员函数， 并特化 <code>std::swap</code> 来调用那个成员函数</strong>。</p>
<h2 id="类模板的-swap"><a href="#类模板的-swap" class="headerlink" title="类模板的 swap"></a>类模板的 swap</h2><p>如果 <code>Widget</code> 和 <code>WidgetImpl</code> 是 <code>class templates</code> 而非 <code>classes</code>, 按照上面的 <code>swap</code> 实现方式，你可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>  ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但上述代码不能通过编译， <code>c++</code> 允许偏特化类模版，却不允许偏特化函数模版(虽然有的编译器中可以编译)。那我们继续尝试重载 <code>std::swap</code>  函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重载了 <code>std::swap</code>，相当于在 <code>std</code> 命名空间添加了一个函数模板。但这在 <code>C++</code> 标准中是不允许的！ <code>C++</code> 标准中，客户只能特化 <code>std</code> 中的模板，但不允许在 <code>std</code> 命名空间中添加任何新的模板。 上述代码虽然在有些编译器中可以编译，但会引发未定义的行为，所以不要这么做。所以我们最终可以把 <code>swap</code> 定义在 <code>Widget</code> 所在的命名空间中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何地方在两个 <code>Widget</code> 上调用 <code>swap</code> 时，<code>C++</code> 根据其 <code>argument-dependent lookup</code>（又称 <code>Koenig lookup</code>） 会找到 <code>WidgetStuff</code> 命名空间下的具有 <code>Widget</code> 参数的 <code>swap</code>。</p>
<p>其实类的 <code>swap</code> 也可以在同一命名空间下定义 <code>swap</code> 函数，而不必特化 <code>std::swap</code>。 但有人可能直接写 <code>std::swap(w1, w2)</code>，特化 <code>std::swap</code> 可以让你的类更加健壮。</p>
<p><strong>在成员函数中不要直接调用 <code>swap(pImpl, other.pImpl);</code> 因为指定了调用 <code>std::swap</code>，<code>argument-dependent lookup</code> 便失效了，<code>WidgetStuff::swap</code> 不会得到调用</strong>。</p>
<p>如果希望优先调用 <code>WidgetStuff::swap</code>，如果未定义则取调用 <code>std::swap</code>，那么应该如何写呢？ 看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;           <span class="comment">// 使得 std::swap 在该作用域内可见</span></span><br><span class="line">  swap(obj1, obj2);          <span class="comment">// 现在，编译器会帮你选最好的 swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>C++</code> 编译器还是会优先调用指定了 <code>T</code> 的 <code>std::swap</code>，其次是 <code>obj1</code> 的类型 <code>T</code> 所在命名空间下的对应 <code>swap</code> 函数， 最后才会匹配 <code>std::swap</code> 的默认实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何实现 <code>swap</code> 呢？</p>
<ul>
<li>提供一个更加高效的，不抛异常的公有成员函数（比如 <code>Widget::swap</code>）。</li>
<li>在你类（或类模板）的同一命名空间下提供非成员函数 <code>swap</code>，调用你的成员函数。</li>
<li>如果你写的是类而不是类模板，也可以特化 <code>std::swap</code>，同样地在里面调用你的成员函数。</li>
<li>调用时，请首先用 <code>using</code> 使 <code>std::swap</code> 可见，然后直接调用 <code>swap</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 26：尽可能推迟变量的定义</title>
    <url>/2022/04/15/effecitve-cpp/effective-cpp-26/</url>
    <content><![CDATA[<blockquote>
<p>Item 26:Postpone variable definitions as long as possible.</p>
</blockquote>
<p>推迟变量的定义有两个好处：</p>
<ul>
<li>改善程序效率，减少无用的构造和析构。</li>
<li>增加程序流程清晰度。</li>
</ul>
<p>这条规则看似简单，但存在流程控制语句的时候容易疏忽。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted = password;</span><br><span class="line">    encrypt(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="推迟到需要构造时执行"><a href="#推迟到需要构造时执行" class="headerlink" title="推迟到需要构造时执行"></a>推迟到需要构造时执行</h2><p>当 <code>encryptPassword</code> 抛出异常时，<code>encrypted</code> 是无用的, 根本不需要构造它。所以更好的写法是推迟 <code>encrypted</code> 的构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> encrypted;       <span class="comment">// 默认构造函数</span></span><br><span class="line">    encrypted = password;   <span class="comment">// 赋值运算符</span></span><br><span class="line">    encrypt(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推迟到有构造参数时"><a href="#推迟到有构造参数时" class="headerlink" title="推迟到有构造参数时"></a>推迟到有构造参数时</h2><p> <strong>“尽可能延后”</strong> 的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至<strong>应该尝试延后这份定义直到能够给它初值实参为止</strong>。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的 <code>default</code> 构造行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">       <span class="keyword">throw</span> logic_error(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encrypted</span><span class="params">(password)</span></span>;     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    encrypt(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环中的变量"><a href="#循环中的变量" class="headerlink" title="循环中的变量"></a>循环中的变量</h2><p>循环中的变量定义也是一个常见的争论点。常有两种写法：</p>
<p>写法 <code>A</code>，在循环外定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; </span><br><span class="line">  w = some value dependent on i;</span><br><span class="line">  ...                           </span><br><span class="line">&#125;                  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写法 <code>B</code> ，在循环内定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>A</code>：<code>1</code> 个构造函数，<code>1</code> 个析构函数，<code>n</code> 个赋值运算符</li>
<li><code>B</code>：<code>n</code> 个构造函数，<code>n</code> 个析构函数</li>
</ul>
<p>但 <code>A</code> 使得循环内才使用的变量进入外部的作用域，不利于程序的理解和维护。软件工程中倾向于认为人的效率比机器的效率更加难得， 所以推荐采用 <code>B</code> 来实现。除非：</p>
<ul>
<li>这段代码是性能的关键.</li>
<li>赋值比一对构造/析构更加廉价。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY</title>
    <url>/2022/04/19/linux/NO_PUBKEY/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt update </span><br><span class="line">命中:1 https://pro-driver-packages.uniontech.com eagle InRelease</span><br><span class="line">获取:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease [269 kB]                                 </span><br><span class="line">命中:3 http://packages.microsoft.com/repos/code stable InRelease                                             </span><br><span class="line">命中:4 https://home-packages.chinauos.com/home plum InRelease                                                </span><br><span class="line">命中:5 https://home-packages.chinauos.com/home plum/beta InRelease   </span><br><span class="line">命中:6 https://home-packages.chinauos.com/printer eagle InRelease</span><br><span class="line">错误:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease</span><br><span class="line">  由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">命中:7 https://home-store-img.uniontech.com/appstore eagle InRelease</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">W: GPG 错误：http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">E: 仓库 “http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease” 没有数字签名。</span><br><span class="line">N: 无法安全地用该源进行更新，所以默认禁用该源。</span><br><span class="line">N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 871920D1991BC93C</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>apt</tag>
      </tags>
  </entry>
</search>
