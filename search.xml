<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Class layout</title>
    <url>/2024/01/22/c++/C-Class-layout/</url>
    <content><![CDATA[<h1 id="C-Class"><a href="#C-Class" class="headerlink" title="C++ Class"></a>C++ Class</h1><p>在类定义中，只有非静态数据声明会增加类对象的大小</p>
<h1 id="Empty-Class"><a href="#Empty-Class" class="headerlink" title="Empty Class"></a>Empty Class</h1><p>一个空类在C++中没有非静态数据成员、没有虚函数，也没有虚基类。这样的类通常被称为“无状态”，因为它们不封装任何状态或数据。然而，即使一个空类没有显式的数据成员，它仍然需要占用一些内存空间。</p>
<p>C++标准规定，不同类型的对象必须具有不同的地址。因此，一个空类对象必须在内存中具有唯一的地址。这确保了即使一个空类对象没有任何可见的数据成员或行为，它也必须占用至少一个字节的内存，以区分它与具有不同类型的其他对象。</p>
<span id="more"></span>
<h2 id="C-20-no-unique-address"><a href="#C-20-no-unique-address" class="headerlink" title="C++20 no_unique_address"></a>C++20 no_unique_address</h2><h2 id="Empty-Base-Class"><a href="#Empty-Base-Class" class="headerlink" title="Empty Base Class"></a>Empty Base Class</h2><p>空基类优化（<code>Empty Base Class Optimization</code>，<code>EBCO</code>）</p>
<ul>
<li>对于多重继承，重新排列基类的顺序以便空基类首先出现在基类列表上通常是有意义的。</li>
<li><code>C++</code> 标准并没有规定编译器必须对空基类进行存储优化</li>
</ul>
<h1 id="标准布局类"><a href="#标准布局类" class="headerlink" title="标准布局类"></a>标准布局类</h1><ul>
<li><code>C++</code> 只为标准布局类型提供布局保证</li>
<li>标准布局类型本质上是一种C类型:<ul>
<li>标量类型(算术、枚举或指针类型)</li>
<li>具有标准布局类型元素的数组</li>
<li>一个标准布局类(可能声明为结构或联合)</li>
</ul>
</li>
</ul>
<p>标准布局类可以具有:</p>
<ul>
<li>无虚函数或虚基类</li>
<li>标准布局类类型的零个或多个基类。</li>
<li>没有两个相同类型的基类</li>
<li>标准布局类型的零个或多个非静态数据成员，例如:所有成员具有相同的访问控制，并且</li>
<li>所有成员都声明在最派生的类中或在同一个基类中标准布局类- 可以具有非虚和静态成员函数、静态数据成员和嵌套类型</li>
</ul>
<h2 id="布局保证"><a href="#布局保证" class="headerlink" title="布局保证"></a>布局保证</h2><p>关于标准布局类的布局，<code>C++</code> 只保证:</p>
<ul>
<li>第一个非静态数据成员位于偏移量为零</li>
<li>这意味着将指向标准布局类对象的指针 <code>reinterpret_cast</code> 转换为指向其第一个非静态数据成员的指针是合理的</li>
<li>每一个后续的非静态数据成员的偏移量都大于在它之前声明的非静态数据会员的偏移量</li>
<li>类的对象存储在连续内存中</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ aggregate</title>
    <url>/2024/01/08/c++/C-aggregates/</url>
    <content><![CDATA[<h1 id="什么是聚合类型-aggregate"><a href="#什么是聚合类型-aggregate" class="headerlink" title="什么是聚合类型(aggregate)"></a>什么是聚合类型(aggregate)</h1><h2 id="在-C-03-中的定义"><a href="#在-C-03-中的定义" class="headerlink" title="在 C++03 中的定义"></a>在 C++03 中的定义</h2><ul>
<li>不能有用户声明的构造函数</li>
<li>没有私有或受保护的非静态数据成员，可以拥有任意数量的私有和受保护的成员函数（但不能是构造函数）以及任意数量的私有或受保护的静态数据成员和静态成员函数</li>
<li>可以具有用户声明或用户定义的复制赋值运算符和或析构函数</li>
<li>没有基类</li>
<li>没有虚函数</li>
<li>数组是聚合，即使它是非聚合类类型的数组</li>
</ul>
<span id="more"></span>
<h2 id="聚合的作用"><a href="#聚合的作用" class="headerlink" title="聚合的作用"></a>聚合的作用</h2><h3 id="可以使用-初始化"><a href="#可以使用-初始化" class="headerlink" title="可以使用 {} 初始化"></a>可以使用 <code>&#123;&#125;</code> 初始化</h3><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type array_name[n] = &#123;a1, a2, …, am&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>m &#x3D;&#x3D; n<ul>
<li>数组的第 <code>i</code> 个 元素用 <code>ai</code> 初始化</li>
</ul>
</li>
<li>m &lt; n <ul>
<li>数组的前 <code>m</code> 个元素用 <code>a1</code>、 <code>a2</code>…<code>am</code> 初始化</li>
<li>剩下的 <code>n - m</code> 个元素使用值初始化<ul>
<li>标量类型对象用 <code>0</code>初始化</li>
<li>具有用户声明的默认构造函数的类类型的对象被值初始化时，将调用其默认构造函数</li>
<li>隐式定义默认构造函数，则所有非静态成员都会递归地进行值初始化，(成员是引用的会初始化失败)</li>
</ul>
</li>
</ul>
</li>
<li>m &gt; n<ul>
<li>编译报错</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span>) &#123;&#125; <span class="comment">//no default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123;&#125; <span class="comment">//default constructor available</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A a1[<span class="number">3</span>] = &#123;<span class="built_in">A</span>(<span class="number">2</span>), <span class="built_in">A</span>(<span class="number">1</span>), <span class="built_in">A</span>(<span class="number">14</span>)&#125;; <span class="comment">//OK n == m</span></span><br><span class="line">  A a2[<span class="number">3</span>] = &#123;<span class="built_in">A</span>(<span class="number">2</span>)&#125;; <span class="comment">//ERROR A has no default constructor. Unable to value-initialize a2[1] and a2[2]</span></span><br><span class="line">  B b1[<span class="number">3</span>] = &#123;<span class="built_in">B</span>()&#125;; <span class="comment">//OK b1[1] and b1[2] are value initialized, in this case with the default-ctor</span></span><br><span class="line">  <span class="type">int</span> Array1[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//All elements are initialized with 0;</span></span><br><span class="line">  <span class="type">int</span> Array2[<span class="number">1000</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">//Attention: only the first element is 1, the rest are 0;</span></span><br><span class="line">  <span class="type">bool</span> Array3[<span class="number">1000</span>] = &#123;&#125;; <span class="comment">//the braces can be empty too. All elements initialized with false</span></span><br><span class="line">  <span class="type">int</span> Array4[<span class="number">1000</span>]; <span class="comment">//no initializer. This is different from an empty &#123;&#125; initializer in that</span></span><br><span class="line">  <span class="comment">//the elements in this case are not value-initialized, but have indeterminate values </span></span><br><span class="line">  <span class="comment">//(unless, of course, Array4 is a global array)</span></span><br><span class="line">  <span class="type">int</span> array[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">//ERROR, too many initializers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><ul>
<li><p>按照非静态数据成员在类定义中出现的顺序（根据定义它们都是公共的）来初始化非静态数据成员</p>
</li>
<li><p>如果初始化器的数量少于成员，则其余的将进行值初始化</p>
</li>
<li><p>如果无法对未显式初始化的成员之一进行值初始化(例如成员是引用)，则会出现编译时错误</p>
</li>
<li><p>如果初始化程序多于必要的数量，我们也会收到编译时错误</p>
</li>
<li><p>对于聚合联合只能用大括号初始化它们的第一个成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  X x;</span><br><span class="line">  <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> f; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">double</span> d;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Y y = &#123;<span class="string">&#x27;a&#x27;</span>, &#123;<span class="number">10</span>, <span class="number">20</span>&#125;, &#123;<span class="number">20</span>, <span class="number">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-11-的变化"><a href="#C-11-的变化" class="headerlink" title="C++11 的变化"></a>C++11 的变化</h2><h3 id="不能有用户提供的构造函数"><a href="#不能有用户提供的构造函数" class="headerlink" title="不能有用户提供的构造函数"></a>不能有用户提供的构造函数</h3><p>以前聚合不能有用户声明的构造函数，但现在它不能有用户提供的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">  <span class="built_in">Aggregate</span>() = <span class="keyword">default</span>; <span class="comment">// 在 C++11 仍然是聚合类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="不能为非静态数据成员提供任何大括号或等号初始化程序"><a href="#不能为非静态数据成员提供任何大括号或等号初始化程序" class="headerlink" title="不能为非静态数据成员提供任何大括号或等号初始化程序"></a>不能为非静态数据成员提供任何大括号或等号初始化程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NotAggregate</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// valid in C++11</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// also valid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-14-的变化"><a href="#C-14-的变化" class="headerlink" title="C++14 的变化"></a>C++14 的变化</h2><h3 id="允许类内成员初始值"><a href="#允许类内成员初始值" class="headerlink" title="允许类内成员初始值"></a>允许类内成员初始值</h3><p> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html">N3605: Member initializers and aggregates</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在C++11 不是聚合，在C++14 是聚合</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-17-的变化"><a href="#C-17-的变化" class="headerlink" title="C++17 的变化"></a>C++17 的变化</h2><p><code>C++17</code> 扩展并增强了聚合和聚合初始化。标准库现在还包含一个 <code>std::is_aggregate</code> 类型特征</p>
<h3 id="聚合类现可以具有公共的非虚拟基类。"><a href="#聚合类现可以具有公共的非虚拟基类。" class="headerlink" title="聚合类现可以具有公共的非虚拟基类。"></a>聚合类现可以具有公共的非虚拟基类。</h3><p>在新的扩展中，如果类存在继承关系，则额外满足以下条件：</p>
<ul>
<li>必须是公开的基类，不能是私有或者受保护的基类</li>
<li>必须是非虚继承</li>
</ul>
<p>此外，<strong>不要求基类是聚合的</strong>。如果它们不是聚合，则它们是列表初始化的。</p>
<p>聚合类的初始化顺序是按基类的声明顺序，然后按不是匿名联合成员的直接非静态数据成员声明顺序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span> <span class="comment">// 不是聚合类，有用户提供的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="built_in">B1</span>(<span class="type">int</span> a) : <span class="built_in">i1</span>(a) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="built_in">B2</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">M</span> <span class="comment">// 不是聚合类，有用户提供的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">M</span>(<span class="type">int</span> a) : <span class="built_in">m</span>(a) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B1, B2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    M m;</span><br><span class="line">    <span class="built_in">C</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">C c &#123; &#123; <span class="number">1</span> &#125;, &#123; <span class="number">2</span> &#125;, <span class="number">3</span>, &#123; <span class="number">4</span> &#125; &#125;;</span><br><span class="line">cout</span><br><span class="line">    &lt;&lt; <span class="string">&quot;is C aggregate?: &quot;</span> &lt;&lt; (std::is_aggregate&lt;C&gt;::value ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">    &lt;&lt; <span class="string">&quot; i1: &quot;</span> &lt;&lt; c.i1 &lt;&lt; <span class="string">&quot; i2: &quot;</span> &lt;&lt; c.i2</span><br><span class="line">    &lt;&lt; <span class="string">&quot; j: &quot;</span> &lt;&lt; c.j &lt;&lt; <span class="string">&quot; m.m: &quot;</span> &lt;&lt; c.m.m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出: is C aggregate?: Y, i1=1 i2=2 j=3 m.m=4</span></span><br></pre></td></tr></table></figure>

<h3 id="没有用户提供的、显式的或继承的构造函数"><a href="#没有用户提供的、显式的或继承的构造函数" class="headerlink" title="没有用户提供的、显式的或继承的构造函数"></a>没有用户提供的、显式的或继承的构造函数</h3><ul>
<li><p>不允许显式构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> <span class="comment">// not an aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">D</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">D</span><span class="params">(D <span class="type">const</span>&amp;)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>不允许继承构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="built_in">B1</span>() : <span class="built_in">i1</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B1 <span class="comment">// not an aggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> B1::B1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="扩展聚合类型的兼容问题"><a href="#扩展聚合类型的兼容问题" class="headerlink" title="扩展聚合类型的兼容问题"></a>扩展聚合类型的兼容问题</h3><p>例如以下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseData</span> &#123;</span><br><span class="line">  <span class="type">int</span> data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">BaseData</span>() : <span class="built_in">data_</span>(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedData</span> : <span class="keyword">public</span> BaseData &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DerivedData d&#123;&#125;;</span><br><span class="line">  std::cout &lt;&lt; d.<span class="built_in">Get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>c++17</code> 之前 <code>DerivedData</code> 不是聚合类型，所以会调用 <code>DerivedData</code> 的默认构造函数然后，调用 <code>BaseData</code> 的默认构造函数，虽然这里 <code>BaseData</code> 声明的是受保护的构造函数，但派生类是可以调用的，但在 <code>C++17</code> 之后发送了变化，<code>DerivedData</code> 是一个聚合类型，基类 <code>BaseData</code> 中的构造函数是受保护的关系，它<strong>不允许</strong>在聚合类型初始化中被调用导致编译失败，我可以可以通过添加一个默认构造函数使其不是聚合类型解决该问题。</p>
<h2 id="C-20-的变化"><a href="#C-20-的变化" class="headerlink" title="C++20 的变化"></a>C++20 的变化</h2><h2 id="没有用户声明或继承的构造函数"><a href="#没有用户声明或继承的构造函数" class="headerlink" title="没有用户声明或继承的构造函数"></a>没有用户声明或继承的构造函数</h2><p>又改回<strong>没有用户声明</strong>的构造函数了。因为没有用户定义的构造函数有时候会导致一些误会，例如下面的情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">  <span class="built_in">Y</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; std::boolalpha </span><br><span class="line">      &lt;&lt; <span class="string">&quot;std::is_aggregate_v&lt;X&gt; : &quot;</span> &lt;&lt; std::is_aggregate_v&lt;X&gt; &lt;&lt; std::endl</span><br><span class="line">      &lt;&lt; <span class="string">&quot;std::is_aggregate_v&lt;Y&gt; : &quot;</span> &lt;&lt; std::is_aggregate_v&lt;Y&gt; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: std::is_aggregate_v&lt;X&gt; : true</span></span><br><span class="line"><span class="comment">//      std::is_aggregate_v&lt;Y&gt; : true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Y y1;   <span class="comment">// 编译失败</span></span><br><span class="line">Y y1&#123;&#125;; <span class="comment">// 编译成功</span></span><br></pre></td></tr></table></figure>
<p>除了删除默认构造函数，将其列入私有访问中也会有同样的问题，所以 <code>C++17</code> 增加了 <code>explicit</code> 修饰的构造函数，该类不是聚合类，但没有解决相同类型不同实例化方式表现不一致的尴尬问题。最后在 <code>C++20</code> 标准中禁止聚合类型使用用户声明的构造函数。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>聚合类型对象的初始化可以用小括号列表来完成，其最终结果与大括号列表相同</li>
<li>另外带大括号的列表初始化是<strong>不支持缩窄转换</strong>的，但是带小括号的列表初始化却是支持缩窄转换的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">short</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x2&#123;<span class="number">1</span>, <span class="number">7.0</span>&#125;; <span class="comment">// 编译失败，7.0 从 double 转换到 short 是缩窄转换</span></span><br><span class="line">    <span class="function">X <span class="title">x2</span><span class="params">(<span class="number">1</span>, <span class="number">7.0</span>)</span></span>; <span class="comment">// 编译成功， c++20 之前，编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这个规则的修改会改变一些旧代码的意义，比如我们经常用到的禁止复制构造的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  <span class="built_in">X</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">const</span> X&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">X</span>(X&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>C++20 </code>中 <code>X</code> 不是聚合类，一个可行的解决方案是不要直接使用 <code>delete</code> 来删除复制构造函数，而是通过<strong>加入或者继承</strong>一个不可复制构造的类型来实现类型的不可复制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  [[no_unique_address]] NonCopyable nc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> : NonCopyable &#123;</span><br><span class="line">  std::string s;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/4178175/what-are-aggregates-and-trivial-types-pods-and-how-why-are-they-special">What are aggregates and trivial types&#x2F;PODs, and how&#x2F;why are they special?</a></li>
<li><a href="https://book.douban.com/subject/35602582">现代 C++ 语言核心特性解析</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 中 malloc 和 new 的区别</title>
    <url>/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">new</th>
<th align="center">malloc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">关键字</td>
<td align="center">标准库函数</td>
</tr>
<tr>
<td align="center">支持语言</td>
<td align="center"><code>C/C++</code></td>
<td align="center">只在 <code>C++</code></td>
</tr>
<tr>
<td align="center">申请内存的位置</td>
<td align="center">自由存储区 <code>free store</code></td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">分配内存的大小</td>
<td align="center">编译器根据类型信息自行计算</td>
<td align="center">显示指定字节数</td>
</tr>
<tr>
<td align="center">内存分配失败</td>
<td align="center">抛出 <code>bac_alloc</code> 异常, 不会返回 <code>NULL</code></td>
<td align="center">返回 <code>NULL</code></td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">返回对象类型的指针</td>
<td align="center">返回<code>void</code> 指针，需要转换</td>
</tr>
<tr>
<td align="center">是否调用构造函数&#x2F;析构函数</td>
<td align="center">调用</td>
<td align="center">不调用</td>
</tr>
<tr>
<td align="center">处理数组</td>
<td align="center"><code>new[]</code></td>
<td align="center">手动指定数组的大小</td>
</tr>
<tr>
<td align="center">是否支持重载</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">是否支持内存扩充</td>
<td align="center">不支持</td>
<td align="center"><code>realloc</code></td>
</tr>
<tr>
<td align="center">内存释放方式</td>
<td align="center"><code>new/delete</code>, <code>new[]/delete[]</code></td>
<td align="center"><code>malloc/free</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ Memory Order</title>
    <url>/2023/11/07/c++/c-Memory-Order/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>高级语言经过编译器将源码转为机器指令运行，其中的运行顺序和代码中的顺序有很大差异，主要是下面三个原因: </p>
<ul>
<li>编译器重排</li>
<li><code>CPU</code> 乱序执行</li>
<li>存储器硬件设计，不同线程看到的顺序不一致。</li>
</ul>
<p>在 <code>c++</code> 中线程同步只有两种方式：</p>
<ul>
<li>原子变量进行同步</li>
<li>锁(<code>Mutex</code>)</li>
</ul>
<p>这里我们主要讨论原子变量的操作。</p>
<h1 id="Memory-Order"><a href="#Memory-Order" class="headerlink" title="Memory Order"></a>Memory Order</h1><p><code>C++11</code> 规定了六种不同的 <code>memory order</code>:</p>
<ul>
<li><code>Relaxed</code></li>
<li><code>Consume</code></li>
<li><code>Acquire</code></li>
<li><code>Release</code></li>
<li><code>Acquire-Release</code></li>
<li><code>Sequential Consistent</code><span id="more"></span>
对应着 <code>std::memory_order</code> 枚举值:</li>
<li><code>std::memory_order_relaxed</code></li>
<li><code>std::memory_order_consume</code></li>
<li><code>std::memory_order_acquire</code></li>
<li><code>std::memory_order_release</code></li>
<li><code>std::memory_order_acq_rel</code></li>
<li><code>std::memory_order_seq_cst</code></li>
</ul>
<p>对一个原子变量操作时可以传入一个  <code>std::memory_order</code> 枚举，指明这个原子操作需要满足的 <code>memory order</code>。没有传入默认为 <code>std::memory_order_seq_cst</code>。</p>
<h2 id="Relaxed"><a href="#Relaxed" class="headerlink" title="Relaxed"></a><code>Relaxed</code></h2><p>最弱内存序，单纯的原子操作，没有线程间同步节点的作用。即：</p>
<ul>
<li>在一个 <code>relaxed</code> 写操作之前的写操作, 将不保证能被其他也对同一个原子变量的 <code>relaxed</code> 读操作看到。</li>
<li>在一个 <code>relaxed</code> 读操作之后的读操作, 也不保证能看到被其他也对同一个原子变量的 <code>relaxed</code> 写操作之前的写操作。</li>
</ul>
<h2 id="Consume"><a href="#Consume" class="headerlink" title="Consume"></a><code>Consume</code></h2><p><code>Consume</code> 仅对原子<strong>读</strong>操作有效。</p>
<p>我们首先理解什么是操作数之间的<strong>数据依赖</strong>: </p>
<p>对于操作 <code>A</code> 和操作 <code>B</code>，如果操作 <code>A</code> 先于操作 <code>B</code> 发生，则有三种情况会使得操作 <code>B</code> 数据依赖于 操作 <code>A</code>：</p>
<ul>
<li><code>A</code> 的值被用作 <code>B</code> 的运算数，<strong>除了</strong><ul>
<li><code>B</code> 是对 std::kill_dependency 的调用</li>
<li><code>A</code> 是内建 <code>&amp;&amp;</code>、<code>||</code>、<code>?:</code> 或 <code>,</code> 运算符的左运算数。</li>
</ul>
</li>
<li><code>A</code> 写入标量对象 <code>M</code>，<code>B</code> 从 <code>M</code> 读取</li>
<li>存在第三个操作 <code>X</code> 数据依赖于操作 <code>A</code>，操作 <code>B</code> 又数据依赖于操作 <code>X</code></li>
</ul>
<p><code>acquire</code> 要求线程 <code>B</code> 能够看到线程 <code>A</code> 中在 <code>release</code> 操作之前的<strong>具有数据依赖关系的写操作</strong></p>
<h2 id="Acquire"><a href="#Acquire" class="headerlink" title="Acquire"></a><code>Acquire</code></h2><p><code>Acquire</code> 仅对原子<strong>读</strong>操作有效。<code>acquire</code> 与 <code>consume</code> 唯一的区别是 <code>acquire</code> 要求线程 <code>B</code> 能够看到线程 <code>A</code> 中在 <code>release</code> 操作之前的<strong>所有写操作</strong>，而不仅仅是与写原子变量具有数据依赖关系的写操作。</p>
<h2 id="Release"><a href="#Release" class="headerlink" title="Release"></a><code>Release</code></h2><p><code>Release</code> 仅对原子<strong>写</strong>操作有效。<code>Release</code> 操作通常是与 <code>consume</code> 或 <code>acquire</code> 操作配对的。</p>
<h2 id="Acquire-Release"><a href="#Acquire-Release" class="headerlink" title="Acquire-Release"></a><code>Acquire-Release</code></h2><ul>
<li>对于一个原子读操作，该操作都是 <code>acquire</code> 操作</li>
<li>对于一个原子写操作，该操作是 <code>release</code> 操作</li>
<li>对于一个既有读又有写的原子操作，该操作既是 <code>acquire</code> 操作也是 <code>release</code> 操作, 例如 <code>compare-and-swap </code>操作、read-modify-write&#96; 操作</li>
</ul>
<h2 id="Sequential-Consistent"><a href="#Sequential-Consistent" class="headerlink" title="Sequential Consistent"></a><code>Sequential Consistent</code></h2><ul>
<li>对于一个原子读操作，该操作都是 <code>acquire</code> 操作</li>
<li>对于一个原子写操作，该操作是 <code>release</code> 操作</li>
<li>对于一个既有读又有写的原子操作，该操作既是 <code>acquire</code> 操作也是 <code>release</code> 操作</li>
<li>程序内所有线程在使用 <code>sequential consistent</code> 操作原子变量时，必须以<strong>一致的顺序</strong>看到程序内的所有 <code>sequential consistent</code> 操作</li>
</ul>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>在 <code>x86_64</code>平台主流实现方式：</p>
<ul>
<li>限制线程同步节点前后的代码重排<ul>
<li>Consume<ul>
<li>所有的在 <code>release</code> 操作之前的、与 <code>release</code> 操作具有数据依赖关系的写操作不能被移动到 <code>release</code> 操作之后</li>
<li>所有的在 <code>consume</code> 操作之后的、与 <code>consume</code> 操作具有数据依赖关系的读操作不能被移动到 <code>consume</code> 操作之后</li>
</ul>
</li>
<li>Acquire<ul>
<li>所有的在 <code>release</code> 操作附近之前的写操作不能被移动到 <code>release</code> 操作之后</li>
<li>所有的在 <code>acquire</code> 操作附近之后的读操作不能被移动到 <code>acquire</code> 操作之前</li>
</ul>
</li>
<li>Release<ul>
<li>所有在 <code>release</code> 操作附近之前的写操作均不能被移动到 <code>release</code> 操作之后</li>
</ul>
</li>
<li>Acquire-Release<ul>
<li>所有的在 <code>acquire-release</code> 操作附近之前的写操作不能被移动到 <code>acquire-release</code> 操作之后</li>
<li>所有的在<code> acquire-release</code> 操作附近之后的读操作不能被移动到 <code>acquire-release</code> 操作之前</li>
</ul>
</li>
</ul>
</li>
<li>利用硬件特性，生成带 <code>lock</code> 前缀的操作指令<ul>
<li>Sequential Consistent</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Memory Order</tag>
      </tags>
  </entry>
  <entry>
    <title>enable_shared_from_this的注意事项</title>
    <url>/2023/03/11/c++/enable-shared-from-this%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>当我们在对象函数中需要返回或者使用自己的 <code>shared_ptr</code> 指针时，该怎么办呢？常见的错误写法如下：用不安全的表达式试图获得 <code>this</code> 的 <code>shared_ptr</code> 对象, 但可能会导致 <code>this</code> 被多个互不知晓的所有者析构.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1 = std::<span class="built_in">make_shared</span>&lt;Bad&gt;();</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;<span class="built_in">getptr</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp2.use_count() = &quot;</span> &lt;&lt; bp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; <span class="comment">// UB: Bad 对象将会被删除两次</span></span><br></pre></td></tr></table></figure>
<p>正确写法是将定义对象公开继承 <code>enable_shared_from_this</code>: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Good&gt; <span class="comment">// 注意：继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>std::enable_shared_from_this</code> 能让其一个对象（假设其名为 <code>t</code> ，且已被一个 <code>std::shared_ptr</code> 对象 <code>pt</code> 管理）安全地生成其他额外的 <code>std::shared_ptr</code> 实例（假设名为 <code>pt1</code>, <code>pt2</code>, … ） ，它们与 <code>pt</code> 共享对象 <code>t</code>的所有权。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><code>enable_shared_from_this</code> 的常见实现为：其内部保存着一个对 <code>this</code> 的弱引用（例如 <code>std::weak_ptr</code> )。 <code>std::shared_ptr</code> 的构造函数发现是并能访问 <code>enable_shared_from_this</code> 的基类，并且若内部存储的弱引用未生成。则 <code>std::shared_ptr</code> 生成内部存储的弱引用。 <code>libc++</code> 的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> enable_shared_from_this</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; __weak_this_;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__weak_this_);&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp <span class="type">const</span>&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Tp&gt;(__weak_this_);&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code> 的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> = <span class="type">__enable_if_t</span>&lt;</span><br><span class="line">        _And&lt;</span><br><span class="line">            __raw_pointer_compatible_with&lt;_Yp, _Tp&gt;</span><br><span class="line">            <span class="comment">// In C++03 we get errors when trying to do SFINAE with the</span></span><br><span class="line">            <span class="comment">// delete operator, so we always pretend that it&#x27;s deletable.</span></span><br><span class="line">            <span class="comment">// The same happens on GCC.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_LIBCPP_CXX03_LANG) &amp;&amp; !defined(_LIBCPP_COMPILER_GCC)</span></span><br><span class="line">            , _If&lt;is_array&lt;_Tp&gt;::value, __is_array_deletable&lt;_Yp*&gt;, __is_deletable&lt;_Yp*&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &gt;::value</span><br><span class="line">    &gt; &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(_Yp* __p) : __ptr_(__p) &#123;</span><br><span class="line">        unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">        <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT&gt; _CntrlBlk;</span><br><span class="line">        __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT());</span><br><span class="line">        __hold.<span class="built_in">release</span>();</span><br><span class="line">        __enable_weak_this(__p, __p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_OrigPtr</span>, <span class="keyword">class</span> = <span class="type">__enable_if_t</span>&lt;</span><br><span class="line">        is_convertible&lt;_OrigPtr*, <span class="type">const</span> enable_shared_from_this&lt;_Yp&gt;*&gt;::value</span><br><span class="line">    &gt; &gt;</span><br><span class="line">    _LIBCPP_HIDE_FROM_ABI</span><br><span class="line">    <span class="type">void</span> __enable_weak_this(<span class="type">const</span> enable_shared_from_this&lt;_Yp&gt;* __e, _OrigPtr* __ptr) _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">__remove_cv_t</span>&lt;_Yp&gt; _RawYp;</span><br><span class="line">        <span class="keyword">if</span> (__e &amp;&amp; __e-&gt;__weak_this_.<span class="built_in">expired</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            __e-&gt;__weak_this_ = <span class="built_in">shared_ptr</span>&lt;_RawYp&gt;(*<span class="keyword">this</span>,</span><br><span class="line">                <span class="built_in">const_cast</span>&lt;_RawYp*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Yp*&gt;(__ptr)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>c++17</code> 前对没初始化的 <code>weak_ptr</code> 的对象调用 <code>shared_from_this</code> 行为未定义行,  <code>C++17</code> 起抛出 <code>std::bad_weak_ptr</code> 异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Good not_so_good;</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1 = not_so_good.<span class="built_in">getptr</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span>(std::bad_weak_ptr&amp; e) &#123;</span><br><span class="line">    <span class="comment">// C++17 前为未定义行为； C++17 起抛出 std::bad_weak_ptr 异常</span></span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="什么时候初始化-enable-shared-from-this-中的-weak-ptr？"><a href="#什么时候初始化-enable-shared-from-this-中的-weak-ptr？" class="headerlink" title="什么时候初始化 enable_shared_from_this 中的 weak_ptr？"></a>什么时候初始化 <code>enable_shared_from_this</code> 中的 <code>weak_ptr</code>？</h2><p>参考实现部分，构造 <code>shared_ptr</code> 的对象时判断是 <code>enable_shared_from_this</code>的时候会初始化。</p>
<h2 id="能不能非公有继承-enable-shared-from-this-？"><a href="#能不能非公有继承-enable-shared-from-this-？" class="headerlink" title="能不能非公有继承 enable_shared_from_this ？"></a>能不能非公有继承 <code>enable_shared_from_this</code> ？</h2><p><strong>不能</strong></p>
<p>非公有继承时候，判断 <code>class</code> 是否是 <code>enable_shared_from_this</code> 会失败就不会去初始化 <code>weak_ptr</code>。</p>
<h2 id="能不能在构造函数中调用？"><a href="#能不能在构造函数中调用？" class="headerlink" title="能不能在构造函数中调用？"></a>能不能在构造函数中调用？</h2><p><strong>不能</strong></p>
<p><code>shared_ptr</code> 初始化需要调用构造函数，而 <code>weak_ptr</code> 需要 <code>shared_ptr</code> 构造初始化。<code>GG</code> 了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>shared_ptr</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>std::make_shared vs. new</title>
    <url>/2023/02/07/c++/std-make-shared-vs-new/</url>
    <content><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p><code>std::make_shared</code> 执行<strong>一次</strong>堆分配，而调用<code>std::shared_ptr</code> 构造函数执行<strong>两次</strong>。</p>
<p>在一个典型的实现中 <code>std::shared_ptr</code> 管理两个实体：</p>
<ul>
<li>控制块（存储元数据，如引用计数、类型擦除删除器等）</li>
<li>被管理的对象</li>
</ul>
<p>控制块是一个动态分配的对象，它包含：</p>
<ul>
<li>指向托管对象的指针或托管对象本身；</li>
<li>删除器 (类型擦除)</li>
<li>分配器 (类型擦除)</li>
<li>拥有被管理对象的 <code>shared_ptr</code>的数量</li>
<li>引用托管对象的 <code>weak_ptr</code> 的数量</li>
</ul>
<p><code>std::make_shared</code>执行一次堆分配，计算控制块和数据所需的总空间。在另一种情况 <code>std::shared_ptr&lt;Obj&gt;(new Obj(&quot;foo&quot;))</code>下执行两次, <code>new Obj(&quot;foo&quot;)</code>为托管数据调用堆分配，<code>std::shared_ptr</code>构造函数为控制块执行另一个堆分配。</p>
<span id="more"></span>

<h1 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h1><p><strong>自 <code>C++17</code> 以来，这不是问题，因为函数参数的评估顺序发生了变化。具体来说，函数的每个参数都需要在评估其他参数之前完全执行</strong>。</p>
<p>考虑这个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(std::shared_ptr&lt;int&gt;(new int(42)), g())</span><br></pre></td></tr></table></figure>
<p>因为 C++ 允许对子表达式进行任意顺序的计算，所以一种可能的顺序是：</p>
<ol>
<li><code>new int(42)</code></li>
<li><code>g()</code></li>
<li><code>std::shared_ptr&lt;int&gt;</code></li>
</ol>
<p>现在，假设我们在第 <code>2</code> 步抛出一个异常。然后我们丢失了在步骤 <code>1</code> 分配的内存，因为没有将原始指针传给 <code>std::shared_ptr</code>, 后面没有任何东西有机会清理它。</p>
<p>解决这个问题的一种方法是在不同的行上执行它们，这样就不会发生这种任意排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto ptr = std::shared_ptr&lt;int&gt;(new int(42));</span><br><span class="line">f(ptr, g());</span><br></pre></td></tr></table></figure>

<p>更方便的的是采用 <code>std::make_shared</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(std::make_shared&lt;int&gt;(42), g())</span><br></pre></td></tr></table></figure>

<h1 id="std-make-shared-的一些缺点"><a href="#std-make-shared-的一些缺点" class="headerlink" title="std::make_shared 的一些缺点"></a><code>std::make_shared</code> 的一些缺点</h1><h2 id="weak-ptr内存保活"><a href="#weak-ptr内存保活" class="headerlink" title="weak_ptr内存保活"></a><code>weak_ptr</code>内存保活</h2><ul>
<li>通过 <code>std::make_shared</code> 构造的智能指针, 当没有 <code>shared_ptr</code> 引用计数为 <code>0</code> 时只调用析构函数，<code>weak_ptr</code>引用计数为 <code>0</code> 时才释放内存块。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> logging = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (logging) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Allocated: &quot;</span> &lt;&lt; (<span class="type">uintptr_t</span>)ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> <span class="keyword">noexcept</span>  </span>&#123;</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">if</span> (logging) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deallocated: &quot;</span> &lt;&lt; (<span class="type">uintptr_t</span>)ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget::~Widget()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span> </span>&#123;</span><br><span class="line">    logging = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="literal">true</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Allocated: 105553162522944 //分配一次</span><br><span class="line">Widget::~Widget() // 没有 shared_ptr 指针，只调用析构函数</span><br><span class="line">No std::shared_ptr&#x27;s anymore.</span><br><span class="line">Deallocated: 105553162522944 //没有 `weak_ptr` 释放整个内存块</span><br><span class="line">No std::weak_ptr&#x27;s anymore.</span><br><span class="line">---------------------</span><br><span class="line">Allocated: 105553164599312</span><br><span class="line">Allocated: 105553162522944 //分配两次</span><br><span class="line">Widget::~Widget()</span><br><span class="line">Deallocated: 105553164599312 //立即释放</span><br><span class="line">No std::shared_ptr&#x27;s anymore.</span><br><span class="line">Deallocated: 105553162522944</span><br><span class="line">No std::weak_ptr&#x27;s anymore.</span><br></pre></td></tr></table></figure>

<h2 id="无法访问公共构造函数"><a href="#无法访问公共构造函数" class="headerlink" title="无法访问公共构造函数"></a>无法访问公共构造函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">val</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make_shared 无法调用 A(int) </span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;A&gt; createNext()&#123; </span></span><br><span class="line">    <span class="comment">//     return std::make_shared&lt;A&gt;(val+1); </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以调用 A(int) </span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">createNext</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(val<span class="number">+1</span>)); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v): <span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">Difference in make_shared and normal shared_ptr in C++</a></li>
<li><a href="https://www.gamedev.net/forums/topic/695796-stdmake_shared-vs-new/">std::make_shared 与 new</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr/make_shared#Notes">make_shared#Notes</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>std::thread 注意事项</title>
    <url>/2023/11/03/c++/std-thread-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="join-和-detach"><a href="#join-和-detach" class="headerlink" title="join 和 detach"></a><code>join</code> 和 <code>detach</code></h1><ul>
<li><p><code>join</code> 或者 <code>detach</code> 只能调用<strong>一次</strong></p>
<p>当调用 <code>join</code> 或者 <code>detach</code> 之后会将持有的线程ID置为 <code>0</code>, 再次调用会抛异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread::join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ec = EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">    &#123;</span><br><span class="line">        ec = __libcpp_thread_join(&amp;__t_);</span><br><span class="line">        <span class="keyword">if</span> (ec == <span class="number">0</span>)</span><br><span class="line">            __t_ = _LIBCPP_NULL_THREAD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">        __throw_system_error(ec, <span class="string">&quot;thread::join failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread::detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ec = EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">    &#123;</span><br><span class="line">        ec = __libcpp_thread_detach(&amp;__t_);</span><br><span class="line">        <span class="keyword">if</span> (ec == <span class="number">0</span>)</span><br><span class="line">            __t_ = _LIBCPP_NULL_THREAD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">        __throw_system_error(ec, <span class="string">&quot;thread::detach failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<ul>
<li><code>thread</code> <strong>不能拷贝只能移动</strong>，但只能移动到没绑定线程的 <code>thread</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_EXPORTED_FROM_ABI</span> thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">__libcpp_thread_t</span> __t_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread</span>(<span class="type">const</span> thread&amp;);</span><br><span class="line">    thread&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread&amp;);</span><br><span class="line">     _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    thread&amp; <span class="keyword">operator</span>=(thread&amp;&amp; <span class="type">__t</span>) _NOEXCEPT &#123;</span><br><span class="line">        <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">            <span class="built_in">terminate</span>();</span><br><span class="line">        __t_ = <span class="type">__t</span>.__t_;</span><br><span class="line">        <span class="type">__t</span>.__t_ = _LIBCPP_NULL_THREAD;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="线程析构"><a href="#线程析构" class="headerlink" title="线程析构"></a>线程析构</h1><p>通过 <code>std::thread</code> 创建的线程**必须调用 <code>join</code> 或者 <code>detach</code>**。线程析构时会先判断线程ID为 <code>0</code> 就抛异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">thread::~<span class="built_in">thread</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">        <span class="built_in">terminate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::thread</code> 析构默认不会等待线程结束，在 <code>C++20</code> 可以使用 <code>std::jthread</code>, <code>std::jthread</code> 实际是使用了 <code>RAII</code> 技术， 在内部持有 <code>thread</code> 成员变量，在析构时调用 <code>join</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_AVAILABILITY_SYNC</span> jthread &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">_LIBCPP_HIDE_FROM_ABI ~<span class="built_in">jthread</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        <span class="built_in">request_stop</span>();</span><br><span class="line">        <span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread __thread_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>可变参数模板</title>
    <url>/2023/04/10/c++/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="可变参数模板的需求"><a href="#可变参数模板的需求" class="headerlink" title="可变参数模板的需求"></a>可变参数模板的需求</h1><p>可变参数模板有助于解决在编译时求值类型安全，不需要宏，不需要显式指定 参数的数量，可以编写可变参数函数模板和可变参数类模板。此外，也有可变参数变量模板和可变 参数别名模板。</p>
<h1 id="可变参数函数模板"><a href="#可变参数函数模板" class="headerlink" title="可变参数函数模板"></a>可变参数函数模板</h1><p>可变参数模板以两种方式使用省略号。在参数名称的左侧，表示参数包，在参数名称的右侧，将参数包扩展为单独的名称。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; </span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(a, <span class="built_in">min</span>(args...)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要在模板参数列表中指定一组参数，如 <code>typename... Args</code>，这称为模板参数包。可以为类型模板、非类型模板和双重模板参数定义的模板参数包。</li>
<li>函数参数列表中指定一组参数，如 <code>Args...args</code>，这称为函数参数包。</li>
<li>函数体中展开包，如在 <code>args...</code> 中，可在 <code>min(args...)</code> 中看到，这称为参数包展开。这种展开的结果是一个由零个或多个值 (或表达式) 组成的逗号分隔列表。</li>
</ul>
<h1 id="参数包"><a href="#参数包" class="headerlink" title="参数包"></a>参数包</h1><ul>
<li><code>sizeof...</code> 计算参数包的大小，返回 <code>std::size_t</code> 类型的 <code>constexpr</code> 值。</li>
</ul>
<h1 id="可变参数类模板"><a href="#可变参数类模板" class="headerlink" title="可变参数类模板"></a>可变参数类模板</h1><h1 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h1><table>
<thead>
<tr>
<th align="left">折叠方式</th>
<th align="center">语法</th>
<th align="right">展开方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一元右折叠</td>
<td align="center">(pack op …)</td>
<td align="right">(arg1 op (… op (argN-1 op argN)))</td>
</tr>
<tr>
<td align="left">一元左折叠</td>
<td align="center">(… op pack)</td>
<td align="right">(((arg1 op arg2) op …) op argN)</td>
</tr>
<tr>
<td align="left">二元右折叠</td>
<td align="center">(pack op … op init)</td>
<td align="right">(arg1 op (… op (argN-1 op (argN op init))))</td>
</tr>
<tr>
<td align="left">二元左折叠</td>
<td align="center">(init op … op pack)</td>
<td align="right">((((init op arg1) op arg2) op …) op argN)</td>
</tr>
</tbody></table>
<ul>
<li><p>一元折叠中，若参数包不包含任何元素，则只允许使用某些操作符。下表列出了这些值，以及 空参数包的值:</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>空参数包的值</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp; (逻辑 AND)</td>
<td>true</td>
</tr>
<tr>
<td>&#124;&#124; (逻辑 OR)</td>
<td>false</td>
</tr>
<tr>
<td>, (逗号操作符)</td>
<td>void()</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="可变参数别名模板"><a href="#可变参数别名模板" class="headerlink" title="可变参数别名模板"></a>可变参数别名模板</h1><h1 id="可变参数变量模板"><a href="#可变参数变量模板" class="headerlink" title="可变参数变量模板"></a>可变参数变量模板</h1>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解 C++20 中的 constinit</title>
    <url>/2023/12/29/c++/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3C++20%E4%B8%AD%E7%9A%84constinit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>在 <code>C++</code> 中，存储变量的方式有几种：</p>
<ul>
<li><p>存储期（<code>Storage Duration</code>）：<br>存储期是指变量在程序中存在的时间段。在 <code>C++</code> 中，有三种主要的存储期：</p>
<ul>
<li>自动存储期（<code>Automatic Storage Duration</code>）：变量在函数或代码块执行时创建，函数执行结束时销毁。</li>
<li>动态存储期（<code>Dynamic Storage Duration</code>）： 使用 <code>new</code> 或 <code>malloc</code> 分配的内存，直到使用 <code>delete</code> 或 <code>free</code> 手动释放为止。</li>
<li>静态存储期（<code>Static Storage Duration</code>）： 变量在程序启动时创建，在整个程序运行期间都存在，直到程序结束才销毁。</li>
</ul>
</li>
<li><p>静态存储变量：</p>
</li>
</ul>
<p>静态存储变量是在程序启动时创建，一直存在于整个程序运行期间的变量。这类变量有两种主要形式：</p>
<ul>
<li>全局变量（<code>Global Variables</code>）： 在函数外部声明的变量，可以被程序中的所有函数访问。</li>
<li>静态局部变量（<code>Static Local Variables</code>）： 在函数内部使用 <code>static</code> 关键字声明的变量，与自动存储期变量不同，它在函数调用之间保持其值。</li>
</ul>
<p>在 <code>C++</code> 中，我们经常使用静态存储期变量，包括全局变量和使用 <code>static</code> 关键字声明的局部变量。然而，这些变量并不保证在程序执行前被初始化，除非它们被声明为 <code>const</code> 常量。为了解决这一问题，<code>C++20</code> 引入了 <code>constinit</code> 关键字，它为我们提供了一种保证变量在程序启动时被初始化的方式，从而增强了可预测性和可靠性。</p>
<p>尽管 <code>constinit</code> 确保变量在程序启动时被初始化，但这并不意味着这些变量是不可修改的常量。相反，这个关键字允许变量在初始化后在运行时或编译时上下文中被修改。</p>
<p>因此，<code>constinit</code> 关键字为我们提供了一种在使用静态存储期变量时获得初始化保证的方法，同时允许在初始化后对其进行适当的修改。</p>
<span id="more"></span>

<h1 id="constinit-和-constexpr-有什么区别？"><a href="#constinit-和-constexpr-有什么区别？" class="headerlink" title="constinit 和 constexpr 有什么区别？"></a>constinit 和 constexpr 有什么区别？</h1><p>如果一个变量被声明为 <code>constexpr</code> ，那么它隐含地具有了 <code>constinit</code> 的性质。 <code>constexpr</code> 关键字用于指示编译器，在编译时可以计算该变量的值，并要求该变量在程序启动时被静态初始化。因此，<code>constexpr</code> 的变量天然地拥有 <code>constinit</code> 的特性<br>但是反过来并不成立，即如果一个变量被声明为 <code>constinit</code>，并不意味着它就是 <code>constexpr</code>。<code>constinit</code>仅确保变量在程序启动时被静态初始化，但不要求在编译时就能确定其值。相反，<code>constexpr</code> 要求在编译时就能确定变量的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">getArraySizeBasedOnArchitecture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sizeof</span>(std::<span class="type">size_t</span>) * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constinit</span> <span class="keyword">auto</span> arrSize2 = <span class="built_in">getArraySizeBasedOnArchitecture</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arrSize1 = <span class="built_in">getArraySizeBasedOnArchitecture</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     std::array&lt;<span class="type">int</span>, arrSize1&gt; intArray1;  <span class="comment">// Ok</span></span><br><span class="line">     std::array&lt;<span class="type">int</span>, arrSize2&gt; intArray2;  <span class="comment">// compilation error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>constexpr 和 constinit 不能同时出现在变量上。这会导致编译错误</strong>。</p>
<h1 id="constinit-有什么作用？"><a href="#constinit-有什么作用？" class="headerlink" title="constinit 有什么作用？"></a>constinit 有什么作用？</h1><ul>
<li>保证变量在编译时初始化</li>
<li>当变量不能在编译时初始化时编译器生成错误提示</li>
<li>处理静态初始化顺序，<a href="https://isocpp.org/wiki/faq/ctors#static-init-order">static-init-order</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>constinit</code> 说明符仅适用于变量</li>
<li><code>constinit</code> 保证变量在编译过程中被初始化，否则我们会得到一个编译错误。</li>
<li><code>constinit</code> 说明符表示静态存储持续时间，但反之则不成立</li>
<li><code>constexpr</code> 变量意味着 <code>constinit</code> ，但反过来并不正确。</li>
<li>一个变量只能出现 <code>constexpr</code> 和 <code>constinit</code> 说明符之一。</li>
<li><code>constinit</code> 可以应用于 <code>const</code> 限定变量。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++20</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解 C++20 中的 consteval</title>
    <url>/2023/12/29/c++/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3C-20%E4%B8%AD%E7%9A%84consteval%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>用最简单的术语来说，一个只能应用于函数的 <code>consteval</code> 关键字, 保证它产生一个编译时间常数。否则会导致编译错误。</p>
<p><code>cppreference</code> 页面对 <code>consteval</code> 说明符有如下描述：</p>
<blockquote>
<p><code>consteval</code> 指定函数是立即函数，也就是说，对该函数的每次调用都必须产生一个编译时常量</p>
</blockquote>
<p>什么是立即函数？</p>
<ul>
<li>不能是协程</li>
<li>函数主体中不能有 <code>throw</code> 语句</li>
<li>不能有 <code>goto</code> 语句或标签语句，除了 <code>case</code> 和 <code>default</code></li>
<li>参数和返回类型必须是<a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">LiteralType</a>,简单地说，是一个可以在编译时计算的类型（比如所有可以在 <code>constexpr</code> 上下文中使用的类型）</li>
</ul>
<span id="more"></span>

<h1 id="consteval-和-constexpr-方法的区别"><a href="#consteval-和-constexpr-方法的区别" class="headerlink" title="consteval 和 constexpr 方法的区别"></a><code>consteval</code> 和 <code>constexpr</code> 方法的区别</h1><p>他们最大的区别：<code>consteval</code> 保证编译时生成，不能编译时生成时会报错，但 <code>constexpr</code> 不一定，当编译时不能生成就转为运行时函数。</p>
<h1 id="从汇编看-consteval-和-constexpr-函数"><a href="#从汇编看-consteval-和-constexpr-函数" class="headerlink" title="从汇编看 consteval 和 constexpr 函数"></a>从汇编看 <code>consteval</code> 和 <code>constexpr</code> 函数</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>对于定义的普通函数、 <code>consteval</code> 函数、 <code>constexpr</code> 函数, 只有普通函数会生成汇编代码<br><img src="/images/consteval1.png" alt="consteval1"></p>
<h2 id="在编译时上下文调用-consteval-和-constexpr-函数"><a href="#在编译时上下文调用-consteval-和-constexpr-函数" class="headerlink" title="在编译时上下文调用 consteval 和 constexpr 函数"></a>在编译时上下文调用 <code>consteval</code> 和 <code>constexpr</code> 函数</h2><p>在编译时直接生成结果，不会生成对应的函数汇编代码和调用汇编指令<br><img src="/images/consteval2.png" alt="consteval2"></p>
<h2 id="在非编译时上下文调用-consteval-和-constexpr-函数"><a href="#在非编译时上下文调用-consteval-和-constexpr-函数" class="headerlink" title="在非编译时上下文调用 consteval 和 constexpr 函数"></a>在非编译时上下文调用 <code>consteval</code> 和 <code>constexpr</code> 函数</h2><p>会生成 <code>constexpr</code>函数的汇编代码和调用函数汇编指令<br><img src="/images/consteval3.png" alt="consteval3"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>consteval</code> 说明符只能应用于函数和构造函数</li>
<li>带有 <code>consteval</code> 的函数称为立即函数</li>
<li><code>constexpr</code> 函数在编译时上下文中执行时，与<code>consteval</code> 函数行为相同</li>
<li>当 <code>consteval</code> 函数不能产生编译时错误时，会导致错误，而对于 <code>constexpr</code> 函数则不会。</li>
<li>当需要对函数的编译时求值进行保证时，首选 <code>consteval</code></li>
<li>优先使用 <code>consteval</code> 函数而不是预处理器宏函数。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++20</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 踩坑记</title>
    <url>/2023/04/07/cmake/CMake-%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="install-CODE-和-execute-process-配合"><a href="#install-CODE-和-execute-process-配合" class="headerlink" title="install(CODE) 和 execute_process 配合"></a><code>install(CODE)</code> 和 <code>execute_process</code> 配合</h1><h2 id="确保-WORKING-DIRECTORY-存在"><a href="#确保-WORKING-DIRECTORY-存在" class="headerlink" title="确保 WORKING_DIRECTORY 存在"></a>确保 <code>WORKING_DIRECTORY</code> 存在</h2><p>示例代码: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="keyword">export</span>)</span><br><span class="line"><span class="keyword">install</span>(CODE <span class="string">&quot;</span></span><br><span class="line"><span class="string">    execute_process(COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory folder </span></span><br><span class="line"><span class="string">    WORKING_DIRECTORY \$&#123;CMAKE_INSTALL_PREFIX&#125;)</span></span><br><span class="line"><span class="string">    &quot;</span>) </span><br></pre></td></tr></table></figure>

<p>注意确保 <code>CMAKE_INSTALL_PREFIX</code> 存在，可能执行这段代码时还没有 <code>install target</code> 导致 <code>CMAKE_INSTALL_PREFIX</code> 还没有生成。</p>
<span id="more"></span>

<h2 id="注意变量转义"><a href="#注意变量转义" class="headerlink" title="注意变量转义"></a>注意变量转义</h2><p><strong>不转义容易在 <code>package</code> 时，执行 <code>execute_process</code> 因为路径问题出错</strong>。</p>
<p>示例代码: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="keyword">export</span>)</span><br><span class="line"><span class="keyword">install</span>(CODE <span class="string">&quot;</span></span><br><span class="line"><span class="string">    execute_process(COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory folder</span></span><br><span class="line"><span class="string">    WORKING_DIRECTORY \$&#123;CMAKE_INSTALL_PREFIX&#125;)</span></span><br><span class="line"><span class="string">    &quot;</span>) </span><br></pre></td></tr></table></figure>
<p>注意 <code>$&#123;WORKING_DIRECTORY&#125;</code> 之前是有 <code>\</code> 转义，当没有转义时，<code>CMAKE_INSTALL_PREFIX</code>会直接替换，此时 <code>CMAKE_INSTALL_PREFIX</code> 表示的 <code>install</code> 路径。 <code>make package</code>时会到一个临时目录处理，其中的 <code>CMAKE_INSTALL_PREFIX</code> 跟  <code>install</code> 路径是不一样的，所以执行 <code>execute_process</code> 会出问题。当转义了表示 execute_process时再去获取 <code>CMAKE_INSTALL_PREFIX</code>, 这时能获取到正确路径。可以在 <code>cmake_install.cmake</code> 查看生成的代码。注意 <code>WORKING_DIRECTORY</code> 的值。</p>
<h3 id="不转义生成代码："><a href="#不转义生成代码：" class="headerlink" title="不转义生成代码："></a>不转义生成代码：</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_INSTALL_COMPONENT <span class="keyword">STREQUAL</span> <span class="string">&quot;rel&quot;</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> CMAKE_INSTALL_COMPONENT)</span><br><span class="line">    <span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> /Users/xxx/Qt/Tools/CMake/CMake.app/Contents/bin/cmake -E <span class="keyword">make_directory</span> folder</span><br><span class="line">    WORKING_DIRECTORY <span class="string">&quot;/xxx/xxx/xxxx/export&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>转义生成代码：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_INSTALL_COMPONENT <span class="keyword">STREQUAL</span> <span class="string">&quot;rel&quot;</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> CMAKE_INSTALL_COMPONENT)</span><br><span class="line">    <span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> /Users/xxx/Qt/Tools/CMake/CMake.app/Contents/bin/cmake -E <span class="keyword">make_directory</span> folder</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h1 id="在-MacOS-上-No-CMAKE-CXX-COMPILER-could-be-found"><a href="#在-MacOS-上-No-CMAKE-CXX-COMPILER-could-be-found" class="headerlink" title="在 MacOS 上 No CMAKE_CXX_COMPILER could be found"></a>在 <code>MacOS</code> 上 <code>No CMAKE_CXX_COMPILER could be found</code></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode.app/Contents/Developer </span><br></pre></td></tr></table></figure>

<h1 id="CMAKE-OSX-ARCHITECTURES"><a href="#CMAKE-OSX-ARCHITECTURES" class="headerlink" title="CMAKE_OSX_ARCHITECTURES"></a>CMAKE_OSX_ARCHITECTURES</h1><ul>
<li>设置 <code>macOS</code>和 <code>iOS</code> 的特定架构</li>
<li>应在第一次 <code>project()</code> 或 <code>enable_language()</code> 命令之前设置</li>
<li>应设置为 <code>CACHE</code> 条目, 除非策略 <code>CMP0126</code> 设置为 <code>NEW</code> </li>
<li>在 <code>Apple</code> 以外的平台上被忽略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (APPLE)</span><br><span class="line">    set(CMAKE_OSX_ARCHITECTURES x86_64 CACHE STRING &quot;&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<h1 id="cmakedefine-的使用例子"><a href="#cmakedefine-的使用例子" class="headerlink" title="cmakedefine 的使用例子"></a>cmakedefine 的使用例子</h1><p><code>#cmakedefine</code> 用于 <code>configure_file()</code> 中用于生成头文件的文件中，只有当 <code>CMakeLists.txt</code> 中的同名变量为真时才会在生成的头文件中定义，区别于 <code>#define</code> 无论何时都会定义。</p>
<p>例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">cat</span> config.h.cmake</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifndef __CONFIG_H</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __CONFIG_H</span></span><br><span class="line"></span><br><span class="line">/* Define to 1 if you have the &lt;mach/mach_time.h&gt; header file. */</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmakedefine HAVE_MACH_MACH_TIME_H 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif /* __CONFIG_H */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="built_in">cat</span> CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line">include(CheckIncludeFiles)</span><br><span class="line">check_include_files(&quot;mach/mach_time.h&quot; HAVE_MACH_MACH_TIME_H)</span><br><span class="line">configure_file(</span><br><span class="line">        $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/config.h.cmake</span><br><span class="line">        $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h</span><br><span class="line">        NEWLINE_STYLE UNIX)</span><br><span class="line">list(APPEND HEADERS $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h)</span><br></pre></td></tr></table></figure>

<p>只有当 <code>mach/mach_time.h</code> 存在时，在 <code>config.h</code> 才会定义 <code>HAVE_MACH_MACH_TIME_H</code> 。</p>
]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Layout</title>
    <url>/2023/09/04/css/CSS-Layout/</url>
    <content><![CDATA[<h1 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h1><h2 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 1fr, 1fr, 1fr, 1fr;</span><br><span class="line">grid-template-columns: repeat(4, 1fr);</span><br><span class="line">grid-template-columns: 1fr, 1fr, 1fr, auto;</span><br></pre></td></tr></table></figure>

<h2 id="grid-column"><a href="#grid-column" class="headerlink" title="grid-column"></a>grid-column</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-column: 1</span><br><span class="line">grid-column: 1 / 4;</span><br><span class="line">grid-column: 1 / span 3;</span><br><span class="line">grid-column: 1 / -1;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor pattern</title>
    <url>/2023/03/06/design/reactor-pattern/</url>
    <content><![CDATA[<h1 id="什么是Reactor模式"><a href="#什么是Reactor模式" class="headerlink" title="什么是Reactor模式"></a>什么是Reactor模式</h1><h1 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h1><ul>
<li><code>Handles</code>:</li>
<li><code>Synchronous Event Demultiplexer</code></li>
<li><code>Initiation Dispatcher</code></li>
<li><code>Event Handler</code></li>
<li><code>Concrete Event Handler</code></li>
</ul>
<h1 id="Reactor模式模块之间的交互"><a href="#Reactor模式模块之间的交互" class="headerlink" title="Reactor模式模块之间的交互"></a>Reactor模式模块之间的交互</h1><h1 id="Reactor模式实现"><a href="#Reactor模式实现" class="headerlink" title="Reactor模式实现"></a>Reactor模式实现</h1><h1 id="Reactor模式优点"><a href="#Reactor模式优点" class="headerlink" title="Reactor模式优点"></a>Reactor模式优点</h1><h1 id="Reactor模式的缺点"><a href="#Reactor模式的缺点" class="headerlink" title="Reactor模式的缺点"></a>Reactor模式的缺点</h1><ul>
<li>Efficiency</li>
<li>Programming simplicity</li>
<li>Portability</li>
</ul>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 1：将C++视作一系列的语言</title>
    <url>/2020/12/07/effecitve-cpp/effective-cpp-1/</url>
    <content><![CDATA[<blockquote>
<p>Item 1: View C++ as a federation of languages</p>
</blockquote>
<p>一开始，<code>Ｃ++</code> 只是 <code>Ｃ</code> 加上一些面向对象特性，<code>Ｃ++</code> 最初的名称 <code>Ｃ with Classes</code> 也反映了这个血缘关系。现在这个语言逐渐成熟，已经是一个<strong>多重泛型编程语言</strong>(<code>multiparadigm programming language</code>)。同时支持过程形式(<code>procedural</code>)、面向对象形式(<code>object-oriented</code>)、函数形式(<code>functional</code>)、泛型形式(<code>generic</code>)、元编程形式(<code>metaprogramming</code>)</p>
<p>将 <code>C++</code> 视为一个由相关语言组成的联邦而非单一的语言。</p>
<p><code>C++</code> 主要４个子语言：</p>
<ul>
<li><code>C</code>。说到底Ｃ++仍是以Ｃ为基础。许多时候Ｃ++对问题的解法其实不过就是较高级的Ｃ的解法如<code>item2</code>、<code>item13</code>。当只使用<code>C++</code>中<code>C</code>的那部分语法，　会发现<code>C</code>语言的缺陷：没有模板、没有异常、没有重载。</li>
<li><code>Object-Oriented</code>。面向对象程序设计也是<code>C++</code>的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。</li>
<li><code>Template C++</code>。这是C++的泛型编程部分，大多数程序员经验最少的部分。<strong>TMP模板元编程</strong>（<code>template metaprogramming</code>）也是一个新兴的程序设计范式。</li>
<li><code>STL</code>。<code>STL</code>是一个特殊的模板库，它将容器、迭代器和算法优雅地结合在一起。</li>
</ul>
<p><code>C++</code> 程序设计的惯例并非一成不变，而是取决于你使用 <code>C++</code> 语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触 <code>Object-Oriented C++</code> 时会发现，传常量指针是更好的选择。运用<code>Template C++</code>时尤其如此，因为彼时你甚至不知道所处理的对象的类型。 但是你如果又碰到了<code>STL</code>，其中的迭代器和函数对象都是基于<code>C</code>语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 10：赋值运算符要返回自己的引用</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-10/</url>
    <content><![CDATA[<blockquote>
<p>Item 10：Have assignment operators return a reference to *this.</p>
</blockquote>
<p>赋值运算符要返回自己的引用只是个协议，并无强制性。这份协议被所有内置类型和标准程序库提供的类型如<code>string</code>, <code>vector</code>, <code>complex</code> <code>std::shared_ptr</code>等共同遵守。可以用来支持链式的赋值语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>; <span class="comment">//赋值连锁形式</span></span><br></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = ( y = ( z = <span class="number">15</span> ) );</span><br></pre></td></tr></table></figure>

<p>我们自定义的对象最好也能支持链式的赋值，这需要重载&#x3D;运算符时返回当前对象的引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;   </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算 +=, -=, *=, etc.</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;  </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 12：复制对象时勿忘其每一个成分</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-12/</url>
    <content><![CDATA[<blockquote>
<p>Item 12: Copy all parts of an object</p>
</blockquote>
<p>正确拷贝函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="情形一：-新添加了一个数据成员，忘记了更新拷贝函数"><a href="#情形一：-新添加了一个数据成员，忘记了更新拷贝函数" class="headerlink" title="情形一： 新添加了一个数据成员，忘记了更新拷贝函数"></a>情形一： 新添加了一个数据成员，忘记了更新拷贝函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line">  Date lastTransaction;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name)&#123;&#125;</span><br><span class="line">  Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">    name = rhs.name;                     <span class="comment">// copy rhs&#x27;s data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                        <span class="comment">// see Item 10</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时 <code>lastTransaction</code> 便被你忽略了，编译器也不会给出任何警告（即使在最高警告级别）</p>
<h3 id="情形二：-继承父类忘记了拷贝父类的部分"><a href="#情形二：-继承父类忘记了拷贝父类的部分" class="headerlink" title="情形二： 继承父类忘记了拷贝父类的部分"></a>情形二： 继承父类忘记了拷贝父类的部分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : <span class="built_in">priority</span>(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确写法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : <span class="built_in">Customer</span>(rhs), <span class="built_in">priority</span>(rhs.priority)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  PriorityCustomer&amp; </span><br><span class="line">  <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 13：以对象管理资源</title>
    <url>/2021/11/02/effecitve-cpp/effective-cpp-13/</url>
    <content><![CDATA[<blockquote>
<p>Item 13: Use objects to manage resources.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 11：赋值运算符需要考虑自我赋值问题</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-11/</url>
    <content><![CDATA[<blockquote>
<p>Item 11: Handle assignment to self in operator&#x3D;</p>
</blockquote>
<p>我们在重载一个类的赋值运算符时要考虑自我赋值的问题。有了指针和引用自我赋值不总是第一时间能够识别出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line">*px = *py;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">const</span> Base&amp; rb, Derived* pd)</span></span>;<span class="comment">// rb和女pd 有可能其实是同一对象</span></span><br><span class="line">rb = pd;</span><br></pre></td></tr></table></figure>

<p>自我赋值主要考虑到 <strong>自我赋值安全性</strong> 和 <strong>异常安全性</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">//指针，指向一个从heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既不自我赋值安全性也不异常安全性, 当 rhs &#x3D;&#x3D; *this时，delete pb使得rhs.pb成为空值，接下来 new 的数据便是空的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断两个地址是否相同，如果是自我赋值，就不做任何事。但开始就delete pb， 但 new 出现异常， pb就会置空出现风险。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 证同测试</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中<strong>仔细地排列语句顺序</strong>通常可以达到异常安全， 比如我们可以先申请空间，最后再delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap *pOrig = pb;  </span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更加通用的技术便是复制和交换（copy and swap）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>; <span class="comment">// 交换*this rhs 的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs); <span class="comment">//rhs 数据制作一份复件(副本)</span></span><br><span class="line">    <span class="built_in">swap</span> (temp); <span class="comment">//*this 数据和上述复件的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 14：在资源管理类中小心 copying 行为</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-14/</url>
    <content><![CDATA[<blockquote>
<p>Item 14: Think carefully about copying behavior in resource-managing classes.</p>
</blockquote>
<p>设计一个 <strong><code>RAII</code></strong> 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>:mutexPtr(pm)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>()&#123; <span class="built_in">unlock</span>(mutexPtr); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户对<code>Lock</code>的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个 <strong><code>RAII</code></strong> 对象被复制，会发生什么事？ 不确定？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(&amp;ml1)</span></span></span><br></pre></td></tr></table></figure>

<p>记住<strong>资源管理对象的拷贝行为取决于资源本身的拷贝行为，同时资源管理对象也可以根据业务需要来决定自己的拷贝行为</strong>。一般有如下四种方式：</p>
<ul>
<li><p><strong>禁止复制</strong>。参考<a href="/2021/10/25/effecitve-cpp/effective-cpp-6/" title="Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝">若不想使用编译器自动生成的函数，就该明确拒绝</a>。对Lock而言看起来是这样：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> : <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>引用计数</strong>，采用 <code>shared_ptr</code> 的逻辑。<code>shared_ptr</code> 构造函数提供了第二个参数 <code>deleter</code>，当引用计数到 <code>0</code> 时被调用。 所以 <code>Lock</code> 可以通过聚合一个 <code>shared_ptr</code> 成员来实现引用计数：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>: mutexPtr(pm, unlock)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutexPtr; <span class="comment">//shared_ptr替换 raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>   <code>Lock</code> 的析构会引起 <code>mutexPtr</code> 的析构，而 <code>mutexPtr</code> 计数到0时<code>unlock(mutexPtr.get())</code> 会被调用。</p>
</li>
<li><p><strong>拷贝底部资源</strong>。复制资源管理对象时，进行的是<strong>深拷贝</strong>。比如 <code>string</code> 的行为：内存存有指向对空间的指针，当它被复制时会复制那片空间。</p>
</li>
<li><p><strong>转移底部资源的拥有权</strong>。<code>auto_ptr</code> 就是这样做的，把资源移交给另一个资源管理对象，自己的资源置空。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 15：在资源管理类中提供对原始资源的访问</title>
    <url>/2021/11/05/effecitve-cpp/effective-cpp-15/</url>
    <content><![CDATA[<blockquote>
<p>Item 15: Provide access to raw resources in resource-managing classes.</p>
</blockquote>
<p><code>APIs</code> 往往要求访问原始资源(<code>raw resources</code>)，所以每一个RAII class 应该<strong>提供提供对原始资源访问的方法。获取资源的方式有两类：隐式地获取和显式地获取。</strong> 显式的资源获取会更安全，它最小化了无意中进行类型转换的机会。</p>
<ul>
<li><strong>显示获取</strong></li>
</ul>
<p><code>shared_ptr</code> 提供了 <code>get</code> 方法来得到资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Investment&gt; pInv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daysHeld</span><span class="params">(Investment *pi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>

<p>为了让 <code>pInv</code> 表现地更像一个指针，<code>shared_ptr</code>还重载了解引用运算符（<code>dereferencing operator</code>） <code>operator-&gt;</code>和 <code>operator*</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>());</span><br><span class="line"><span class="type">bool</span> texable2 = !((*pi1).<span class="built_in">isTaxFree</span>());</span><br></pre></td></tr></table></figure>

<p>我们封装了Font来管理资源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line">FontHandle f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span>: f(fh)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Font</span>()&#123; <span class="built_in">releaseFont</span>(f); &#125;;</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过get方法来访问FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>隐式地获取</strong></li>
</ul>
<p>可以隐式类型转换运算符将 <code>Font</code> 转换为 <code>FontHandle</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> f;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize);</span><br></pre></td></tr></table></figure>

<p>然而问题也随之出现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FontHandle h2 = f1;</span><br></pre></td></tr></table></figure>
<p>无意间 <code>h2</code> 并没有被资源管理起来，这将会引发意外的资源泄漏。所以隐式转换在提供便利的同时， 也引起了资源泄漏的风险。 </p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 16：使用同样的形式来new和delete</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-16/</url>
    <content><![CDATA[<blockquote>
<p>Item 16: Use the same form in corresponding uses of new and delete.</p>
</blockquote>
<p><strong>如果你用 <code>new</code> 申请了动态内存，请用 <code>delete</code> 来销毁；如果你用 <code>new xx[]</code> 申请了动态内存，请用 <code>delete[]</code> 来销毁</strong>: </p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string* stringPtrl = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* stringPtr2 = <span class="keyword">new</span> std::string[lOO];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringptrl;      <span class="comment">// 删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;  <span class="comment">// 删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure>

<p>上面很容易理解但需要注意<code>typedef</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];    <span class="comment">//每个人的地址有四行，</span></span><br><span class="line">                                        <span class="comment">//每行是一个string</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>AddressLines</code> 是个数组，如果这样使用 <code>new</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string *pal = <span class="keyword">new</span> AddressLines;     <span class="comment">//注意. &quot;new AddressLines&quot; 返回</span></span><br><span class="line">                                         <span class="comment">//一个 string*，就像 &quot;new string[4]&quot; 一样</span></span><br></pre></td></tr></table></figure>
<p>那就必须匹配 “<strong>数组形式</strong>“的 <code>delete</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pal;         <span class="comment">//行为未有定义!</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;     <span class="comment">//很好。</span></span><br></pre></td></tr></table></figure>

<p>为避免诸如此类的错误，最好尽量不要对数组形式做 <code>typedefs</code> 动作。可以使用更加面向对象的<code>vector</code>、<code>string</code>等对象。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 17：在单独的语句中将 new 的对象放入智能指针</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-17/</url>
    <content><![CDATA[<blockquote>
<p>Item 17: Store newed objects in smart pointers in standalone statements.</p>
</blockquote>
<p><strong>以单独的语句将 <code>new</code> 的对象放入智能指针内。这是为了防止由于其他表达式抛出异常而导致的资源泄漏</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>上述代码中，在 <code>processWidget</code> 函数被调用之前参数会首先得到计算。可以认为包括三部分的过程：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
<li>调用 <code>priority()</code></li>
</ol>
<p><strong>因为C++不同于其他语言，函数参数的计算顺序很大程度上决定于编译器</strong>，编译器认为顺序应当是1, 3, 2，即：</p>
<ol>
<li>执行 <code>new Widget</code></li>
<li>调用 <code>priority()</code></li>
<li>构造 <code>shared_ptr&lt;Widget&gt;</code></li>
</ol>
<p>那么如果 <code>priority</code>抛出了异常，新的 <code>Widget</code> 便永远地找不回来了。虽然我们使用了智能指针，但资源还是泄漏了！</p>
<p>于是更加健壮的实现中，应当将创建资源和初始化智能指针的语句独立出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Widget&gt; pw = <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget);</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 18：让接口容易被正确使用，不易被误用</title>
    <url>/2021/11/08/effecitve-cpp/effective-cpp-18/</url>
    <content><![CDATA[<blockquote>
<p>Item 18: Make interfaces easy to use correctly and hard to use incorrectly.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 19：设计 class 犹如设计 type</title>
    <url>/2021/11/11/effecitve-cpp/effective-cpp-19/</url>
    <content><![CDATA[<blockquote>
<p>Item 19: Teat class design as type design.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 2：尽量以const, enum, inline 替换 &amp;#35;define</title>
    <url>/2020/12/14/effecitve-cpp/effective-cpp-2/</url>
    <content><![CDATA[<blockquote>
<p>Item 2: Prefer consts, enums, and inlines to #defines</p>
</blockquote>
<p>我们先看看<code>#deifne</code> 有哪些的问题:</p>
<h1 id="不利于调试"><a href="#不利于调试" class="headerlink" title="不利于调试"></a>不利于调试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ASPECT_RATION 1.653</span><br></pre></td></tr></table></figure>
<p>在预处理时候 <code>ASPECT_RATION</code> 可能就被移走了,<code>ASPECT_RATION</code> 没有进入 符号表, 运行此常量获得编译错误信息时, 可能会疑惑。因为这个错误信息总是提到 <code>1.653</code>，而不是<code>ASPECT_RATION</code> ， 如果 <code>ASPECT_RATION</code> 定义不是自己写的头文件中，可能对 <code>1.653</code> 的来源毫无概念，将因追踪它浪费时间，解决之道是以一个常量替换上述宏 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏</span></span><br><span class="line">                                 <span class="comment">//因此这里改变名称写法</span></span><br></pre></td></tr></table></figure>
<p>作为一个语言常量，<code>ASPECT_RATION</code> 肯定会被编译器看到，当然会进入记号表内。此外对于浮点常量(<code>floating point constant</code>)而言，使用常量可能比使用<code>#define</code> 导致较少量的码。</p>
<h1 id="不重视scope"><a href="#不重视scope" class="headerlink" title="不重视scope"></a>不重视scope</h1><p>无法利用 <code>#define</code> 创建<code>class</code>专属常量。一旦宏定义，它就在其后的编译过程中有效（除非在某处 <code>#undef</code> ）。而 <code>const</code> 可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns; <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];      <span class="comment">//使用该常量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum-比-const-更好用"><a href="#enum-比-const-更好用" class="headerlink" title="enum 比 const 更好用"></a>enum 比 const 更好用</h2><p>旧式编译器也许不支持上述语法，　它们不允许static在声明式上获得初值，此外所谓的“<code>in-classs　初值设定</code>”也只运行对<strong>整数常量</strong>进行，　如果编译器不支持上述语法，可以将初值放在定义式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CostEstimate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> FudgeFactor;  <span class="comment">//staitc class　常量声明位于头文件内</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>; <span class="comment">//staitc class　常量定义位于实现文件内</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>emnu</code>就很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];　<span class="comment">//the enum hack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　</p>
<h1 id="不易理解"><a href="#不易理解" class="headerlink" title="不易理解"></a>不易理解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b)  f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);     　<span class="comment">//ａ被累加二次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b + <span class="number">10</span>);　<span class="comment">//ａ被累加一次</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须记住为宏的所有实参加上小括号</li>
<li>在这里调用ｆ之前，ａ的递增次取决与“它被拿来与谁比较”</li>
</ul>
<p>更好的做法是使用　<code>template inline</code>　函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 20：传常量引用比传值更好</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-20/</url>
    <content><![CDATA[<blockquote>
<p>Item 20: Prefer pass-by-reference-to-const to pass-by-value.</p>
</blockquote>
<p>缺省情况下<code>C++</code> 用传值得方式(一个继承自<code>C</code>的方式)传递对象至(或来自)函数。除非你另外指定，否则函数参数都是以实际实参的复件(副本)为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件(副本)系由对象的<code>copy</code>构造函数产出。</p>
<p><strong>尽量以传常量引用替换传值前者通常比较高效，并可避免切割问题 (<code>slicing problem</code>)，但是内置类型和 <code>STL</code> 迭代器，还是传值更加合适。</strong>。</p>
<span id="more"></span>

<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题:"></a>性能问题:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> ();</span><br><span class="line">    <span class="keyword">virtual</span> -<span class="built_in">Person</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    -<span class="built_in">Student</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑以下代码，其中调用函数 <code>validateStudent</code> ，后者需要一个 <code>Student</code><br>(<code>by value</code>) 并返回它是否有效:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;           <span class="comment">// function taking a Student by value</span></span><br><span class="line"></span><br><span class="line">Student plato;                             <span class="comment">// Plato studied under Socrates</span></span><br><span class="line"><span class="type">bool</span> platoIsOK = <span class="built_in">validateStudent</span>(plato);   <span class="comment">// call the functio</span></span><br></pre></td></tr></table></figure>

<p>在调用 <code>validateStudent(</code>) 时进行了 <strong>6</strong> 个函数调用：</p>
<ol>
<li><code>Person</code> 的拷贝构造函数，为什么 <code>Student</code> 的拷贝构造一定要调用 <code>Person</code> 的拷贝构造请参见：<a href="/2021/11/02/effecitve-cpp/effective-cpp-12/" title="Effective C++ 12：复制对象时勿忘其每一个成分">Item:12 复制对象时勿忘其每一个成分</a></li>
<li><code>Student</code> 的拷贝构造函数</li>
<li><code>name</code>, <code>address</code>, <code>schoolName</code>, <code>schoolAddress</code> 的拷贝构造函数</li>
</ol>
<p>解决办法便是传递常量引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>首先以引用的方式传递，不会构造新的对象，避免了上述例子中 <strong>6</strong> 个构造函数的调用。 同时 const 也是必须的：传值的方式保证了该函数调用不会改变原来的 <code>Student</code>， 而传递引用后为了达到同样的效果，需要使用 <code>const</code> 声明来声明这一点，让编译器去进行检查!</p>
<h2 id="截断问题"><a href="#截断问题" class="headerlink" title="截断问题"></a>截断问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// return name of window</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// draw window and contents</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在假设你希望写个函数打印窗口名称，然后显示该窗口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; w.<span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    w.<span class="built_in">display</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br></pre></td></tr></table></figure>

<p>当调用 <code>printNameAndDisplay</code> 时参数类型从 <code>WindowWithScrollBars</code> 被隐式转换为 <code>Window</code>。 该转换过程通过调用 <code>Window</code> 的拷贝构造函数来进行。 导致的结果便是函数中的 <code>w</code> 事实上是一个 <code>Window</code> 对象， 并不会调用多态子类 <code>WindowWithScrollBars</code> 的 <code>display()</code>。</p>
<p>正确做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fine, parameter won&#x27;t be sliced</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>一般情况下相比于传递值，传递常量引用是更好的选择。但也有例外情况，比如 <strong>内置类型</strong> 和 <strong>STL 迭代器</strong>和<strong>函数对象</strong>。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 21：需要返回对象时，不要返回引用</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-21/</url>
    <content><![CDATA[<blockquote>
<p>Item 21: Don’t to return a reference when you must return an object.</p>
</blockquote>
<p>Item 20 中提到，多数情况下传引用比传值更好。但不要无脑追求这一点，一定不要返回空引用或指针。</p>
<span id="more"></span>

<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;</span><br><span class="line">  <span class="type">int</span> n, d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Raitonal</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为什么是const请参考Item 3</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a, b;</span><br><span class="line">Rational c = a*b;</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>operator*</code> 返回的是一个实例，<code>a*b</code>时便会调用<code>operator*()</code>， 返回值被拷贝后用来初始化<code>c</code>。</p>
<p>不考虑编译器优化和 <code>C11</code> 的 <code>move</code> ,这个过程涉及到多个构造和析构过程：</p>
<ol>
<li><code>operator*</code>调用结束前，返回值被拷贝，调用拷贝构造函数</li>
<li><code>operator*</code>调用结束后，返回值被析构</li>
<li><code>c</code> 被初始化，调用拷贝构造函数</li>
</ol>
<p>我们能否通过传递引用的方式来避免这些函数调用？这要求在函数中创建那个要被返回给调用者的对象，而函数只有两种办法来创建对象：在栈空间中创建、或者在堆中创建。</p>
<p>在栈空间中创建显然是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n*rhs.n, lhs.d*rhs.d)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目标是要避免调用构造函数，而 <code>result</code> 却必须像任何对象一样地由构造函数构造起, 而且得到的 <code>result</code> 永远是空。因为 <code>result</code> 是一个 <code>local</code> 对象，当函数调用结束后 <code>result</code>即被销毁。</p>
<p>在堆中创建也会问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">  Rational *result  = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n*rhs.n, lhs.d*rhs.d);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是得必须付出一个”构造函数调用”代价， 并且谁去 <code>delete</code>?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x*y*z;</span><br></pre></td></tr></table></figure>

<p>上面这样合理的代码都会导致内存泄露。</p>
<p>使用静态变量的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">    <span class="type">static</span> Rational result; <span class="comment">// static 对象，此函数将返回</span></span><br><span class="line">    result = ... ; <span class="comment">// lhs 乘以 rhs. 并将结果置于 result 内。</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态变量首先便面临着线程安全问题，除此之外当我们需要不止一个的返回值同时存在时也会产生问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a*b) == (c*d))&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果operator*的返回值是静态变量，那么上述条件判断恒成立，因为等号两边是同一个对象。所以我们还是老老实实返回对象实例就好，并且考虑到编译器优化和<code>move</code>语意，拷贝构造返回值带来的代价没那么高。</p>
<p><strong>永远不要返回局部对象的引用或指针或堆空间的指针，如果需要多个返回对象时也不能是局部静态对象的指针或引用</strong>。<a href="/2021/01/13/effecitve-cpp/effective-cpp-4/" title="Effective C++ 4：确定对象被使用前已先被初始化">Item:4 确定对象被使用前已先被初始化</a>， 对于单例模式，返回局部静态对象的引用也是合理的。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 22：将成员变量声明为private</title>
    <url>/2022/03/23/effecitve-cpp/effective-cpp-22/</url>
    <content><![CDATA[<blockquote>
<p>Item 22: Declare data members private.</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 23：用非成员函数、非友元函数替换成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-23/</url>
    <content><![CDATA[<blockquote>
<p>Item 23: Prefer non-member non-friend functions to member functions</p>
</blockquote>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 24：若所有参数皆需类型转换，请采用非成员函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-24/</url>
    <content><![CDATA[<blockquote>
<p>Item 24: Declare non-member functions when type conversions should apply all parameters.</p>
</blockquote>
<p>令 <code>classes</code> 支持隐式转换通常是糟糕的设计，但也有例外，最常见的是在建立数值类型时。 比如设计一个有理数 <code>class</code> 允许整数隐式转换。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>); <span class="comment">//构造函数刻意不使用 explicit; 允许 int-to-Rational 隐式转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时我们想设计一个乘法，该使用 <code>member</code> 函数，还是 <code>non-member</code> 函数， 还是 <code>non-member-friend</code> 函数？</p>
<p>我们先采用 <code>member</code> 函数看有什么问题？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们使用如下没有什么问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Rational result = oneEighth * oneHalf; <span class="comment">//ok</span></span><br><span class="line">result = result * oneEighth;  <span class="comment">// ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但当我们想支持混合运算，那 <code>Rational</code> 和 <code>ints</code> 相乘, 就只有一半行的通。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">//ok  隐式转换</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">// no</span></span><br></pre></td></tr></table></figure>

<p>当我们设计成 <code>non-member</code> 函数就都支持：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>(), rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;  <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth;  <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>

<p><strong>如果需要为某个函数的所有参数进行类型转换，那这个函数必须是 <code>non-member</code></strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 25：设计一个不抛异常的 swap 函数</title>
    <url>/2022/04/09/effecitve-cpp/effective-cpp-25/</url>
    <content><![CDATA[<blockquote>
<p>Item 25: Consider support for a non-throwing swap.</p>
</blockquote>
<p><code>swap</code> 函数能置换两对象值，功能很重要!</p>
<ul>
<li>异常安全性编程</li>
<li>处理自我赋值可能性：<a href="/2021/11/01/effecitve-cpp/effective-cpp-11/" title="Effective C++ 11：赋值运算符需要考虑自我赋值问题">赋值运算符需要考虑自我赋值问题</a></li>
</ul>
<p><code>std</code> 的缺省基本实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="类的-swap"><a href="#类的-swap" class="headerlink" title="类的 swap"></a>类的 swap</h2><p>只要类型 <code>T</code> 支持 <code>copying</code>运算(拷贝构造和拷贝赋值运算)就能使用。 但缺省实现会有多次拷贝，在某些情况下不是性能最好的实现。比如针对 <code>pimpl</code> 手法实现的 <code>class</code>, 不仅要复制三次 <code>Widget</code> 还需要复制三次 <code>WdigetImpl</code>, 非常缺乏效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;);</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl *pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实我们发现这种情况只需要将 <code>pImpl</code> 指针交换就好， 我们可以将 <code>std::swap</code> 对 <code>Widget</code> 的特化来实现.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上述代码不能通过编译， 因为 <code>pImpl</code> 是私有变量， 所以，<code>Widget</code> 应当提供一个 <code>swap</code> 成员函数或友元函数。 惯例上会提供一个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap; <span class="comment">// 为何要这样？请看下文</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)&#123;</span><br><span class="line">      a.<span class="built_in">swap</span>(b);              <span class="comment">// 调用成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现与 STL 容器是一致的：<strong>提供公有 <code>swap</code> 成员函数， 并特化 <code>std::swap</code> 来调用那个成员函数</strong>。</p>
<h2 id="类模板的-swap"><a href="#类模板的-swap" class="headerlink" title="类模板的 swap"></a>类模板的 swap</h2><p>如果 <code>Widget</code> 和 <code>WidgetImpl</code> 是 <code>class templates</code> 而非 <code>classes</code>, 按照上面的 <code>swap</code> 实现方式，你可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;  ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但上述代码不能通过编译， <code>c++</code> 允许偏特化类模版，却不允许偏特化函数模版(虽然有的编译器中可以编译)。那我们继续尝试重载 <code>std::swap</code>  函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重载了 <code>std::swap</code>，相当于在 <code>std</code> 命名空间添加了一个函数模板。但这在 <code>C++</code> 标准中是不允许的！ <code>C++</code> 标准中，客户只能特化 <code>std</code> 中的模板，但不允许在 <code>std</code> 命名空间中添加任何新的模板。 上述代码虽然在有些编译器中可以编译，但会引发未定义的行为，所以不要这么做。所以我们最终可以把 <code>swap</code> 定义在 <code>Widget</code> 所在的命名空间中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何地方在两个 <code>Widget</code> 上调用 <code>swap</code> 时，<code>C++</code> 根据其 <code>argument-dependent lookup</code>（又称 <code>Koenig lookup</code>） 会找到 <code>WidgetStuff</code> 命名空间下的具有 <code>Widget</code> 参数的 <code>swap</code>。</p>
<p>其实类的 <code>swap</code> 也可以在同一命名空间下定义 <code>swap</code> 函数，而不必特化 <code>std::swap</code>。 但有人可能直接写 <code>std::swap(w1, w2)</code>，特化 <code>std::swap</code> 可以让你的类更加健壮。</p>
<p><strong>在成员函数中不要直接调用 <code>swap(pImpl, other.pImpl);</code> 因为指定了调用 <code>std::swap</code>，<code>argument-dependent lookup</code> 便失效了，<code>WidgetStuff::swap</code> 不会得到调用</strong>。</p>
<p>如果希望优先调用 <code>WidgetStuff::swap</code>，如果未定义则取调用 <code>std::swap</code>，那么应该如何写呢？ 看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;           <span class="comment">// 使得 std::swap 在该作用域内可见</span></span><br><span class="line">  <span class="built_in">swap</span>(obj1, obj2);          <span class="comment">// 现在，编译器会帮你选最好的 swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>C++</code> 编译器还是会优先调用指定了 <code>T</code> 的 <code>std::swap</code>，其次是 <code>obj1</code> 的类型 <code>T</code> 所在命名空间下的对应 <code>swap</code> 函数， 最后才会匹配 <code>std::swap</code> 的默认实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何实现 <code>swap</code> 呢？</p>
<ul>
<li>提供一个更加高效的，不抛异常的公有成员函数（比如 <code>Widget::swap</code>）。</li>
<li>在你类（或类模板）的同一命名空间下提供非成员函数 <code>swap</code>，调用你的成员函数。</li>
<li>如果你写的是类而不是类模板，也可以特化 <code>std::swap</code>，同样地在里面调用你的成员函数。</li>
<li>调用时，请首先用 <code>using</code> 使 <code>std::swap</code> 可见，然后直接调用 <code>swap</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 28：避免返回 handles 指向对象内部成分</title>
    <url>/2022/04/16/effecitve-cpp/effective-cpp-28/</url>
    <content><![CDATA[<blockquote>
<p>Item28: Avoid returning “handles” to object internals.</p>
</blockquote>
<p>避免返回 <code>handles</code> (包括 <code>references</code> 、指针、迭代器)指向对象内部。</p>
<span id="more"></span>

<h2 id="破坏封装性"><a href="#破坏封装性" class="headerlink" title="破坏封装性"></a>破坏封装性</h2><p><code>const</code> 函数不再是 <code>const</code>, 修改了私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;</span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这样的设计可通过编译，但却是错误的。<code>upperLeft</code> 和 <code>lowerRight</code> 被声明为 <code>const</code> 成员函数，但是可以更改内部数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>; <span class="comment">// rec是个const矩形, 从 (0 ，0) 到 (100 ， 100)</span></span><br><span class="line"></span><br><span class="line">rec.<span class="built_in">upperLeft</span>( ) .<span class="built_in">setX</span>(<span class="number">50</span>);  <span class="comment">// 现在rec却变成从 (50 ， 0) 到 (100 ， 100)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>成员变量的封装性最多只等于”返回其 <code>reference</code>“ 的函数的访问级别。</li>
<li>如果 <code>const</code> 成员函数传出一个 <code>reference</code>，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。(<code>bitwise constness</code>原因)</li>
</ul>
<h2 id="悬空问题"><a href="#悬空问题" class="headerlink" title="悬空问题"></a>悬空问题</h2><p>虽然我们可以修改函数，达到不能修改私有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br></pre></td></tr></table></figure>
<p>但也不能解决悬空问题。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span> &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">boundingBox</span><span class="params">(<span class="type">const</span> GUIObject&amp; obj)</span></span>; <span class="comment">//以 by value 方式返回一个矩形</span></span><br></pre></td></tr></table></figure>

<p>现在，客户有可能这么使用这个函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIObject* pgo; <span class="comment">// 让pgo指向某个GUIObject</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Point* pUpperLeft = &amp;(<span class="built_in">boundingBox</span>(*pgo) .<span class="built_in">upperLeft</span>()); <span class="comment">// 取得一个指针指向外框左上点</span></span><br></pre></td></tr></table></figure>

<p><code>pUpperLeft</code> 被悬空了，<code>boundingBox(*pgo)</code> 返回的是一个临时变量，在语句执行结束后就会销毁，导致 <code>pUpperLeft</code> 指针失效。</p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 26：尽可能推迟变量的定义</title>
    <url>/2022/04/15/effecitve-cpp/effective-cpp-26/</url>
    <content><![CDATA[<blockquote>
<p>Item 26:Postpone variable definitions as long as possible.</p>
</blockquote>
<p>推迟变量的定义有两个好处：</p>
<ul>
<li>改善程序效率，减少无用的构造和析构。</li>
<li>增加程序流程清晰度。</li>
</ul>
<p>这条规则看似简单，但存在流程控制语句的时候容易疏忽。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted = password;</span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="推迟到需要构造时执行"><a href="#推迟到需要构造时执行" class="headerlink" title="推迟到需要构造时执行"></a>推迟到需要构造时执行</h2><p>当 <code>encryptPassword</code> 抛出异常时，<code>encrypted</code> 是无用的, 根本不需要构造它。所以更好的写法是推迟 <code>encrypted</code> 的构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;       <span class="comment">// 默认构造函数</span></span><br><span class="line">    encrypted = password;   <span class="comment">// 赋值运算符</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推迟到有构造参数时"><a href="#推迟到有构造参数时" class="headerlink" title="推迟到有构造参数时"></a>推迟到有构造参数时</h2><p> <strong>“尽可能延后”</strong> 的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至<strong>应该尝试延后这份定义直到能够给它初值实参为止</strong>。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的 <code>default</code> 构造行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> string&amp; password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">encrypted</span><span class="params">(password)</span></span>;     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环中的变量"><a href="#循环中的变量" class="headerlink" title="循环中的变量"></a>循环中的变量</h2><p>循环中的变量定义也是一个常见的争论点。常有两种写法：</p>
<p>写法 <code>A</code>，在循环外定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; </span><br><span class="line">  w = some value dependent on i;</span><br><span class="line">  ...                           </span><br><span class="line">&#125;                  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写法 <code>B</code> ，在循环内定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>A</code>：<code>1</code> 个构造函数，<code>1</code> 个析构函数，<code>n</code> 个赋值运算符</li>
<li><code>B</code>：<code>n</code> 个构造函数，<code>n</code> 个析构函数</li>
</ul>
<p>但 <code>A</code> 使得循环内才使用的变量进入外部的作用域，不利于程序的理解和维护。软件工程中倾向于认为人的效率比机器的效率更加难得， 所以推荐采用 <code>B</code> 来实现。除非：</p>
<ul>
<li>这段代码是性能的关键.</li>
<li>赋值比一对构造&#x2F;析构更加廉价。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 3：尽可能使用 const</title>
    <url>/2021/01/05/effecitve-cpp/effective-cpp-3/</url>
    <content><![CDATA[<blockquote>
<p>Item3: Use const whenever possible.</p>
</blockquote>
<h1 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a>常量的声明</h1><p>指针的常量声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting;                 <span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;           <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;           <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;     <span class="comment">//const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>const</code> 出现在<code>*</code>左边，表示被指物为常量;　如果出现在<code>*</code>右边，表示指针自身为常量；如果出现在<code>*</code>两边，表示被指物和指针两者都是常量。</p>
<p>如果被指物是常量，<code>const</code> 放在类型之前和放在类型之后<code>*</code>之前表示的意义一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget* p)</span></span>;　<span class="comment">//f1　获得一个指针，指向一个常量Ｗidget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(widget <span class="type">const</span> *p)</span></span>;　<span class="comment">//f2 也是</span></span><br></pre></td></tr></table></figure>


<p>STL的<code>iterator</code> 系以指针塑模出来，所以<code>iterator</code>的作用像个<code>T*</code>指针。如果希望指针是常量，可以声明为 <code>const iterator</code>，如果希望被指物为常量，需使用 <code>const_iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">//iter的作用像个Ｔ* const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                             <span class="comment">//没问题，改变iter所指物  </span></span><br><span class="line">++iter;　　　　　　　　　　　　　　　　　　　　　　 　　　　     <span class="comment">//错误，iter是const</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();   <span class="comment">//cIter的作用像个const Ｔ*</span></span><br><span class="line">*cIter = <span class="number">10</span>;                                            <span class="comment">//错误，*cIter是const</span></span><br><span class="line">++cIter;                                                <span class="comment">//没问题，　改变cIter</span></span><br></pre></td></tr></table></figure>
<p>返回值声明为常量，可以降低代码被错误使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>　&#123;...&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*&#123;<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们本来想做个比较，错误地输入<code>=</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c) ...</span><br></pre></td></tr></table></figure>
<p>编译器就会报错误：不可给常量赋值。</p>
<h1 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h1><p>声明const 成员函数，是为了确认该成员函数可以作用与const对象，也使class接口比较容易理解，可以得知哪些函数可以改动对象内容，哪些不可以。</p>
<p>成员函数只是常量性不同是可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>   <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// const objects</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)               <span class="comment">// operator[] for</span></span><br><span class="line">  &#123; <span class="keyword">return</span> text[position]; &#125;                           <span class="comment">// non-const objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   std::string text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;             <span class="comment">// fine — writing a non-const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;            <span class="comment">// error! — writing a const TextBlock</span></span><br></pre></td></tr></table></figure>

<h1 id="bitsise-constness-和-logical-constness"><a href="#bitsise-constness-和-logical-constness" class="headerlink" title="bitsise constness 和　logical constness"></a>bitsise constness 和　logical constness</h1><p><code>bitsise constness</code>: 成员函数只有在不改变对象的任何非静态成员变量时才可以被称为常量函数。也是C++对常量性的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pText[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TextBlock tb;</span><br><span class="line"><span class="type">char</span> *p = &amp;tb[<span class="number">1</span>];</span><br><span class="line">*p = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h1><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>函数调用<code>const</code>函数可以避免代码重复。不可以反着来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position]</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">            [position]</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>*this</code> 的类型是 <code>TextBlock</code>，先把它强制隐式转换为 <code>const TextBlock</code>，这样我们才能调用那个常量方法。</li>
<li>调用 <code>operator[](std::size_t) const</code>，得到的返回值类型为 <code>const char&amp;</code>。</li>
<li>把返回值去掉 <code>const</code> 属性，得到类型为 <code>char&amp;</code> 的返回值。</li>
</ol>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 4：确定对象被使用前已先被初始化</title>
    <url>/2021/01/13/effecitve-cpp/effective-cpp-4/</url>
    <content><![CDATA[<blockquote>
<p>Item 4: Make sure that objects are initialized before they’re used.</p>
</blockquote>
<h1 id="手工初始化内置对象"><a href="#手工初始化内置对象" class="headerlink" title="手工初始化内置对象"></a>手工初始化内置对象</h1><p>为内置对象进行手工初始化，因为<code>C++</code>不保证初始化他们。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;                                  <span class="comment">//对 int 进行手工初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;A C-style string&quot;</span>;      <span class="comment">//对指针进行手工初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">std::cin &gt;&gt; d;                              <span class="comment">//以读取 input stream 的方式完成初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="构造函数最好使用成员初值列"><a href="#构造函数最好使用成员初值列" class="headerlink" title="构造函数最好使用成员初值列"></a>构造函数最好使用成员初值列</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones) &#123;</span><br><span class="line">    theName = name;             <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address;       <span class="comment">//而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在<code>class</code>中的声明次序相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address, <span class="type">const</span> std::list&lt;PhoneNumber&gt; &amp;phones) : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address), <span class="built_in">thePhones</span>(phones), <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="local-static-对象替换-non-local-static-对象。"><a href="#local-static-对象替换-non-local-static-对象。" class="headerlink" title="local static 对象替换 non-local static 对象。"></a><code>local static</code> 对象替换 <code>non-local static</code> 对象。</h1><p>为免除”跨单元之初始化次序“问题，请以 <code>local static</code> 对象替换 <code>non-local static</code> 对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;     </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户使用使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params )</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在初始化次序的重要性体现出来了，除非 <code>tfs</code> 在 <code>tempDir</code> 之前先被初始化，否则<code>tempDir</code>的构造函数会用到尚未初始化的<code>tfs</code>。但<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源文件建立起来的，它们是定义于不同编译单元内的 <code>non-local static</code> 对象。它们初始化相对次序并无明确定义。但我们可以将 <code>local static</code> 对象替换<code>non-local static</code> 对象来解决。这也是<strong>Singleton</strong>模式的常见实现手法。</p>
<p>这个手法的基础在于：C++保证，函数内的 <code>local static</code> 对象会在调用该函数时首次遇上该对象的定义式时被初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>( params) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 5：了解c++默默编写并调用哪些函数</title>
    <url>/2021/10/24/effecitve-cpp/effective-cpp-5/</url>
    <content><![CDATA[<blockquote>
<p>Item 5: Know what functions C++ silently writes and calls</p>
</blockquote>
<h1 id="默认函数"><a href="#默认函数" class="headerlink" title="默认函数"></a>默认函数</h1><p>在 <code>C++</code> 中，一个类有八个默认函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="built_in">Empty</span> () &#123;&#125; <span class="comment">//默认构造函数    </span></span><br><span class="line">    <span class="built_in">Empty</span> (<span class="type">const</span> Empty &amp;) &#123;&#125; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Empty</span> (<span class="type">const</span> Empty &amp;&amp;) &#123;&#125; <span class="comment">// 默认移动构造函数(`C++11`)</span></span><br><span class="line">    ~<span class="built_in">Empty</span>() &#123;&#125; <span class="comment">// 默认析构函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;) &#123;&#125; <span class="comment">// 默认重载赋值运算符函数</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;&amp;)&#123;&#125; <span class="comment">// 默认重载移动赋值操作符函数函数</span></span><br><span class="line">    Empty* <span class="keyword">operator</span> &amp;() &#123;&#125; <span class="comment">// 默认重载取址运算符函数</span></span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="type">const</span> &#123;&#125; <span class="comment">// 默认重载取址运算符 `const` 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h1><p>只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。</p>
<h1 id="引用成员"><a href="#引用成员" class="headerlink" title="引用成员"></a>引用成员</h1><p>如果你打算在一个“内含引用成员”或者“内含<code>const</code>成员”的类内支持赋值操作，就必须定义自己的默认拷贝赋值操作符。因为 <code>C++</code> 本身不允许引用改指不同的对象，也不允许更改 <code>const</code> 成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string &amp; name;</span><br><span class="line">    <span class="built_in">Person</span>(string &amp;str):<span class="built_in">name</span>(str) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(s1)</span>, <span class="title">p2</span><span class="params">(s2)</span></span>;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: object of type &#x27;Person&#x27; cannot be assigned because its copy assignment operator is implicitly deleted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 6：若不想使用编译器自动生成的函数，就该明确拒绝</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-6/</url>
    <content><![CDATA[<blockquote>
<p>Item 6: Explicitly disallow the use of compiler-generated functions you do not want.</p>
</blockquote>
<p>在C++中，编译器会自动生成一些你没有显式定义的函数。可以参考:<a href="/2021/10/24/effecitve-cpp/effective-cpp-5/" title="Effective C++ 5：了解c++默默编写并调用哪些函数">了解c++默默编写并调用哪些函数</a><br>然而有时候我们希望禁用掉这些函数，可以通过把自动生成的函数设为 <code>private</code> 来禁用它或者在 <code>c++11</code> 中使用 <code>delete</code> 关键字。</p>
<p>比如我们禁用拷贝的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale &amp;);  <span class="comment">// 只有声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;) = <span class="keyword">delete</span>； <span class="comment">// c++11</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以专门设计一个阻止<code>copying</code> 的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> noncopyable_ &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">noncopyable</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>() &#123;&#125;</span><br><span class="line">            ~<span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable() = default;</span></span><br><span class="line"><span class="comment">            ~noncopyable() = default;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">            noncopyable&amp; <span class="keyword">operator</span>=( <span class="type">const</span> noncopyable&amp; );</span><br><span class="line">            <span class="comment">/** C++11</span></span><br><span class="line"><span class="comment">            noncopyable( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            noncopyable&amp; operator=( const noncopyable&amp; ) = delete;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span> : <span class="keyword">private</span> noncopyable_::noncopyable</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HomeForSale p1, p2;</span><br><span class="line">p1 = p2;</span><br><span class="line"></span><br><span class="line">error: object of type <span class="string">&#x27;HomeForSale&#x27;</span> cannot be assigned because its copy assignment <span class="keyword">operator</span> is implicitly deleted</span><br><span class="line">    p1 = p2;</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 7：为多态基类声明 virtual 析构函数</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-7/</url>
    <content><![CDATA[<blockquote>
<p>Item 7: Declare destructors virtual in polymorphic base classes.</p>
</blockquote>
<p>析构函数声明为虚函数目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。 否则子类部分的内存将会泄漏，正确的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper *ptk = <span class="built_in">getTimeKeeper</span>():  <span class="comment">// 可能返回任何一种子类</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>

<ul>
<li>polymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果<br>class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。</li>
<li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性<br>(polymorphically) ，就不该声明 virtual 析构函数。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 8：析构函数不要抛出异常</title>
    <url>/2021/10/25/effecitve-cpp/effective-cpp-8/</url>
    <content><![CDATA[<blockquote>
<p>Item 8: Prevent exceptions from leaving destructors.</p>
</blockquote>
<p><code>C++</code> 本身不阻止在析构函数抛出异常，但在析构函数中抛出的异常往往会难以捕获，引发程序非正常退出或未定义行为。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123; ... &#125; <span class="comment">//假设这里可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::vector&lt;Widget&gt; v;  <span class="comment">// v 这里被自动析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。</p>
<p>不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在 <code>C++</code> 中，不要让析构函数抛出异常！</p>
<p>但是如果析构函数所使用的代码可能无法避免抛出异常呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span>&#123;                   <span class="comment">//某用来建立数据库连接的类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;     <span class="comment">//建立一个连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;                     <span class="comment">//关闭一个连接，假设可以抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;                         <span class="comment">//创建一个资源管理类来提供更好的用户接口</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    ~DBConn&#123; db.<span class="built_in">close</span>(); &#125;            <span class="comment">//终止时自动调用关闭连接的方法</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...&#123;                                 </span><br><span class="line">  <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>; <span class="comment">//创建一个DBConn类的对象</span></span><br><span class="line">  ...                                 <span class="comment">//使用这个对象</span></span><br><span class="line">&#125;                                     <span class="comment">//对象dbc被释放资源</span></span><br><span class="line">          </span><br></pre></td></tr></table></figure>

<p>析构函数所调用的 <code>close()</code> 方法可能会抛出异常，那么有什么方法来解决呢？</p>
<p><strong>吞掉异常</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>主动关闭程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    db.<span class="built_in">close</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">//记录访问历史</span></span><br><span class="line">    std::<span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把可能抛出异常的代码移出析构函数</strong></p>
<p>客户在需要关闭的时候主动调用 <code>close()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;        <span class="comment">//当要关闭连接时，手动调用此函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    closed = <span class="literal">false</span>;      <span class="comment">//显示连接是否被手动关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBConn::close</span><span class="params">()</span></span>&#123;    <span class="comment">//当需要关闭连接，手动调用此函数</span></span><br><span class="line">  db.<span class="built_in">close</span>();</span><br><span class="line">  closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DBConn::~<span class="built_in">DBcon</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!closed)            <span class="comment">//析构函数还是要留有备用，但不用每次都承担风险了</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">      <span class="comment">//记录访问历史</span></span><br><span class="line">      <span class="comment">//消化异常或者主动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析<br>构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 <code>class</code> 应该提<br>供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 9：绝不在构造和析构过程中调用 virtual 函数</title>
    <url>/2021/11/01/effecitve-cpp/effective-cpp-9/</url>
    <content><![CDATA[<blockquote>
<p>Item 9: Never call virtual functions during construction or destruction.</p>
</blockquote>
<p>在构造和析构期间不要调用 <code>virtual</code> 函数，因为这类调用不会下降至 <code>derived class</code><br>(比起当前执行构造函数和析构函数的那层)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;                               <span class="comment">// base class for all</span></span><br><span class="line"><span class="keyword">public</span>:                                           <span class="comment">// transactions</span></span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;                                <span class="comment">// base class ctor           </span></span><br><span class="line">        <span class="built_in">logTransaction</span>();                         <span class="comment">// as final action, log this               </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;      <span class="comment">// make type-dependent</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;        <span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// how to log trans-</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p><code>b</code> 在构造时，调用到父类Transaction的构造函数，其中对 <code>logTransaction</code> 的调用会被解析到 <code>Transaction</code> 类。 那是一个纯虚函数，因此程序会非正常退出。</p>
<p>在<code>derived class</code> 对象的 <code>base class</code> 构造期间，对象的类型是 <code>base class</code> 而不是 <code>derived classo</code> 不只 <code>virtual</code> 函数会被编译器解析至(resolve to) <code>base class</code> ，若使用运行期类型信息 <code>RTTI</code>(runtime type information, 例如 <code>dynamic_cast</code>  <code>typeid</code>) ，也会把对象视为 <code>base class</code> 类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BuyTransaction b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P11Transaction</span><br><span class="line">P14BuyTransaction</span><br></pre></td></tr></table></figure>

<p><strong>相同道理也适用于析构函数.</strong></p>
]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-STL 21：总是让比较函数在等值情况下返回 false</title>
    <url>/2023/03/10/effective-stl/effective-stl-21/</url>
    <content><![CDATA[<blockquote>
<p>Item 21: Always have comparison functions return false for equal values.</p>
</blockquote>
<h1 id="严格弱序-strict-weak-ordering"><a href="#严格弱序-strict-weak-ordering" class="headerlink" title="严格弱序( strict weak ordering )"></a>严格弱序( <code>strict weak ordering</code> )</h1><p>先补充下严格弱序的概念: 对两个变量 <code>x</code> 和 <code>y</code>：</p>
<ul>
<li><code>x &gt; y</code> 等同于 <code>y &lt; x</code></li>
<li><code>x == y</code> 等同于 <code>!(x &lt; y) &amp;&amp; !(x &gt; y)</code></li>
</ul>
<p>要想严格弱序，就需要遵循如下规则：</p>
<ul>
<li>每个变量值必须等于其本身（<code>irreflexivity</code>）：<code>x &lt; x</code> 永远不能为 <code>true</code></li>
<li>不对称性（<code>asymmetry</code>）：如果 <code>x &lt; y</code>，那么 <code>y &lt; x</code> 就不能为 <code>true</code></li>
<li>有序性必须可传递性：如果 <code>x &lt; y</code> 并且 <code>y &lt; z</code>，那么 <code>x &lt; z</code></li>
<li>值相同必须具有可传递性：如果 <code>x == y</code> 并且 <code>y == z</code>，那么 <code>x == z</code></li>
</ul>
<span id="more"></span>

<h1 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h1><h2 id="1-关联容器中的比较算法"><a href="#1-关联容器中的比较算法" class="headerlink" title="1. 关联容器中的比较算法"></a>1. 关联容器中的比较算法</h2><p>比如我们创建一个 <code>set</code> ， 用 <code>less_euqal</code> 作为比较类型，然后插入两个 <code>10</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>我们将第一个 <code>10</code> 记为 <code>10A</code>, 第二个 <code>10</code> 记为 <code>10B</code>, 我们在插入 <code>10B</code> 的时候会检查是否与 <code>10A</code> 相同, 我们用的是 <code>less_equal</code>，下面的表达式会为假，就会重复插入，显然不合理。:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!(10A &lt;= 10B) &amp;&amp; !(10B &lt;= 10A) //  !(true) &amp;&amp; !(true)</span><br></pre></td></tr></table></figure>

<p>另外在 <code>multiset</code> 中也不行: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>, less_equal&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入10A</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入10B</span></span><br></pre></td></tr></table></figure>

<p>当我们想要一个 <code>equal_range</code>, <code>10A</code> 和 <code>10B</code> 同样认为是不等，永远不会在同一个区间。</p>
<h2 id="2-sort-算法"><a href="#2-sort-算法" class="headerlink" title="2. sort 算法"></a>2. <code>sort</code> 算法</h2><p>对于 <code>std::sort</code>，当容器里面元素个数大于 <code>_S_threshold</code> 的值时（<code>16</code>），就会使用快速排序，会将所有的元素与中间值比较是无边界保护的，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">     _RandomAccessIterator</span><br><span class="line">     __unguarded_partition(_RandomAccessIterator __first,</span><br><span class="line">               _RandomAccessIterator __last,</span><br><span class="line">               _Tp __pivot, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span> (__comp(*__first, __pivot)) <span class="comment">// &lt;-------------------</span></span><br><span class="line">         ++__first;</span><br><span class="line">       --__last;</span><br><span class="line">       <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">         --__last;</span><br><span class="line">       <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">         <span class="keyword">return</span> __first;</span><br><span class="line">       std::<span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">       ++__first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入的 <code>vector</code> 中，后面的元素完全相等， <code>__comp()</code>函数一直返回 <code>true</code> ，在进行快速排序的时候，<code>++first</code> 就可能越界失效，导致 <code>coredump</code>。</p>
]]></content>
      <categories>
        <category>Effective-STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-STL</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-STL 9：慎重选择删除元素的方法</title>
    <url>/2023/02/16/effective-stl/effective-stl-9/</url>
    <content><![CDATA[<blockquote>
<p>Item9. Choose carefully among easing options.</p>
</blockquote>
<h1 id="一、删除特定值"><a href="#一、删除特定值" class="headerlink" title="一、删除特定值"></a>一、删除特定值</h1><ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code></p>
<p> 最好使用 <code>erase-remove</code>习惯用法: </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1963</span>, c.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器</p>
<p> 直接使用 <code>remove</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove</span>(<span class="number">1963</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>对于标准关联容器</p>
<p> 直接使用 <code>erase</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="number">1963</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>
<h1 id="二、删除满足特定判定条件的值"><a href="#二、删除满足特定判定条件的值" class="headerlink" title="二、删除满足特定判定条件的值"></a>二、删除满足特定判定条件的值</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">badValue</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// 返回x是否为&quot;坏值&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code><br> 使用 <code>erase-remove-if</code>方法: </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), badValue, c.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器<br> 直接使用 <code>remove_if</code> 方法:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">remove_if</span>(badValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于标准关联容器</p>
<p> <strong>把当前的i传给erase，i后缀递增</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c<span class="number">3.</span><span class="built_in">erase</span>(i++); </span><br><span class="line">    <span class="keyword">else</span> ++i;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="三、循环内部删除对象之外还要做某些事"><a href="#三、循环内部删除对象之外还要做某些事" class="headerlink" title="三、循环内部删除对象之外还要做某些事"></a>三、循环内部删除对象之外还要做某些事</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于 <code>vector</code>、 <code>string</code> 或 <code>deque</code></p>
<p> <strong>接收 <code>erase</code>返回的迭代器值。</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">badValue</span>(*i)) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(*i);</span><br><span class="line">        i = c.<span class="built_in">rease</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于 <code>list</code> 容器</p>
<p> 虽然也可以采用标准关联容器方法，但建议采用跟 <code>vector</code>、 <code>string</code> 或 <code>deque</code> 一致。</p>
</li>
<li><p>对于标准关联容器</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">badValue</span>(*i)) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(*i);</span><br><span class="line">        c.<span class="built_in">rease</span>(i++);</span><br><span class="line">    &#125; <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Effective-STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective-STL</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之tr</title>
    <url>/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/</url>
    <content><![CDATA[<p><code>Linux</code> 中 <code>tr</code> 命令用于转换或删除文件中的字符。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tr</span> [OPTION] SET1 [SET2]</span></span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c, --complerment：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换;</span><br><span class="line">-d, --delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s, --squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t, --truncate-set1：先删除第一字符集较第二字符集多出的字符;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>字符集1(<code>SET1</code>)：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数 “字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；</li>
<li>字符集2(<code>SET2</code>)：指定要转换成的目标字符集。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol>
<li><p>小写字母转换为大写字母:</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;HELLO WORLD&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -d &#x27;0-9&#x27;</span><br><span class="line">hello  world</span><br><span class="line"></span><br><span class="line">➜ echo &quot;hello 123 world 456&quot; | tr -cd &#x27;0-9&#x27;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></li>
<li><p>压缩字符</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ echo &quot;hello          world&quot; | tr -s &#x27;[:space:]&#x27;</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">➜  share echo &quot;hellooooo worldddddddddddd&quot; | tr -s &#x27;od&#x27; </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="常用的字符类"><a href="#常用的字符类" class="headerlink" title="常用的字符类"></a>常用的字符类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:print:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY</title>
    <url>/2022/04/19/linux/NO_PUBKEY/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt update </span><br><span class="line">命中:1 https://pro-driver-packages.uniontech.com eagle InRelease</span><br><span class="line">获取:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease [269 kB]                                 </span><br><span class="line">命中:3 http://packages.microsoft.com/repos/code stable InRelease                                             </span><br><span class="line">命中:4 https://home-packages.chinauos.com/home plum InRelease                                                </span><br><span class="line">命中:5 https://home-packages.chinauos.com/home plum/beta InRelease   </span><br><span class="line">命中:6 https://home-packages.chinauos.com/printer eagle InRelease</span><br><span class="line">错误:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease</span><br><span class="line">  由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">命中:7 https://home-store-img.uniontech.com/appstore eagle InRelease</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">W: GPG 错误：http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 871920D1991BC93C</span><br><span class="line">E: 仓库 “http://mirrors.tuna.tsinghua.edu.cn/ubuntu hirsute InRelease” 没有数字签名。</span><br><span class="line">N: 无法安全地用该源进行更新，所以默认禁用该源。</span><br><span class="line">N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 871920D1991BC93C</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>SUSE Linux 系统记录</title>
    <url>/2024/03/07/linux/SUSE-Linux-%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近接触到 <code>SUSE Linux</code> 操作系统，一些命令不一样，这里记录下:</p>
<h1 id="包管理器-zypper"><a href="#包管理器-zypper" class="headerlink" title="包管理器 zypper"></a>包管理器 <code>zypper</code></h1><ul>
<li>包的安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo zypper install 包名</span><br></pre></td></tr></table></figure>

<ul>
<li>搜索包</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo zypper search 包名</span><br></pre></td></tr></table></figure>
<h1 id="老旧版本系统的包查找"><a href="#老旧版本系统的包查找" class="headerlink" title="老旧版本系统的包查找"></a>老旧版本系统的包查找</h1><p>我用的系统是 <code>SUSE 12 SP5</code> 基本没有可用的在线 <code>Repositories</code>, 一些包很难找到了，可以通过<a href="https://www.suse.com/download/sle-sdk/">SUSE Linux Enterprise Software Development Kit</a> 下载对应的 <code>SDK ISO</code> 安装里面的 <code>rpm</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/unchch/p/12910463.html">SUSE 12 SP3 的源管理相关</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ARM64汇编入门</title>
    <url>/2023/03/18/macos/ARM64%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="ARM-指令概要介绍"><a href="#ARM-指令概要介绍" class="headerlink" title="ARM 指令概要介绍"></a><code>ARM</code> 指令概要介绍</h1><ul>
<li><code>A64</code> 指令集只能运行在 <code>aarch64</code> 环境中</li>
<li>所有的A64汇编指令都是 <code>32bits</code> 宽</li>
<li><code>A64</code> 支持全部是大写或者全部是小写的书写方式</li>
</ul>
<p>寄存器名：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Size</th>
<th align="left">Encoding</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Wn</td>
<td align="left">32 bits</td>
<td align="left">0-30</td>
<td align="left">Genral-purpose register 0-30</td>
</tr>
<tr>
<td align="left">Xn</td>
<td align="left">64 bits</td>
<td align="left">0-30</td>
<td align="left">Genral-purpose register 0-30</td>
</tr>
<tr>
<td align="left">WZR</td>
<td align="left">32 bits</td>
<td align="left">31</td>
<td align="left">Zero register</td>
</tr>
<tr>
<td align="left">XZR</td>
<td align="left">64 bits</td>
<td align="left">31</td>
<td align="left">Zero register</td>
</tr>
<tr>
<td align="left">WPS</td>
<td align="left">32 bits</td>
<td align="left">31</td>
<td align="left">Current stack pointer</td>
</tr>
<tr>
<td align="left">SP</td>
<td align="left">64 bits</td>
<td align="left">31</td>
<td align="left">Current stack pointer</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="ARM-指令的分类"><a href="#ARM-指令的分类" class="headerlink" title="ARM 指令的分类"></a><code>ARM</code> 指令的分类</h2><ul>
<li>内存加载和存储指令</li>
<li>多字节内存加载和存储</li>
<li>算术和位移指令</li>
<li>移位操作</li>
<li>位操作</li>
<li>条件操作</li>
<li>跳转指令</li>
<li>独占访存指令</li>
<li>内存屏障指令</li>
<li>异常处理指令</li>
<li>系统寄存器访问指令</li>
</ul>
<h2 id="ARM-指令的一般编码格式"><a href="#ARM-指令的一般编码格式" class="headerlink" title="ARM 指令的一般编码格式"></a><code>ARM</code> 指令的一般编码格式</h2><p>一条典型的 <code>ARM64</code> 指令语法格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;opcode&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125; &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;opcode&gt;</code>：是指令助记符，如 <code>ADD</code> 表示算术加操作指令。</li>
<li><code>&#123;&lt;cond&gt;&#125;</code>：表示指令执行的条件。</li>
<li><code>&#123;S&#125;</code>：决定指令的操作是否影响 <code>CPSR</code> 的值。</li>
<li><code>&lt;Rd&gt;</code>：表示目标寄存器。</li>
<li><code>&lt;Rn&gt;</code>：表示包含第 <code>1</code> 个操作数的寄存器。</li>
<li><code>&lt;shifter_operand&gt;</code>：表示第 <code>2</code> 个操作数。</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>文件MIME类型</title>
    <url>/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="什么是-MIME-类型？"><a href="#什么是-MIME-类型？" class="headerlink" title="什么是 MIME 类型？"></a>什么是 MIME 类型？</h1><p><code>MIME</code>（多用途 <code>Internet</code> 邮件扩展）的类型来识别文件格式。 <code>MIME</code> 类型构成了 <code>Internet</code> 上对文件类型进行分类的标准方法。</p>
<ul>
<li><code>MIME Type</code>是用于描述文件的类型的一种表述方法，其将文件划分为多种类型，方便对其进行统一的管理。</li>
<li><code>MIME Type</code>指定了文件的类型名称、描述、图标信息，同时通过与.desktop应用程序描述文件整合，指定了文件的打开方式。</li>
</ul>
<span id="more"></span>
<p><code>MIME</code> 类型名字遵循指定的格式：</p>
<p>类型和子类型， 在 MIME 类型中，类型和子类型不区分大小写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media-type/subtype-identifier</span><br></pre></td></tr></table></figure>

<p>目前，有十种注册类型：<code>application</code>，<code>audio</code>，<code>example</code>，<code>font</code>，<code>image</code>，<code>message</code>，<code>model</code>，<code>multipart</code>，<code>text</code>和<code>video</code>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multipart/form-data</span><br><span class="line">text/xml</span><br><span class="line">text/csv</span><br><span class="line">text/plain</span><br><span class="line">application/xml</span><br><span class="line">application/zip</span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<p>完整MIME 类型示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application/vnd.api+json</span><br></pre></td></tr></table></figure>

<p><code>application</code>作为类型，<code>api</code>作为子类型，<code>vnd</code>是厂商前缀，<code>+json</code>是后缀，表示可以解析为<code>JSON</code>。</p>
<h1 id="获取文件的-MIME-类型"><a href="#获取文件的-MIME-类型" class="headerlink" title="获取文件的 MIME 类型"></a>获取文件的 MIME 类型</h1><h2 id="xdg-mime命令"><a href="#xdg-mime命令" class="headerlink" title="xdg-mime命令"></a>xdg-mime命令</h2><ul>
<li><p>显示文件的<code>MIME</code>类型：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query filetype &#123;file&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query filetype one.jpg </span><br><span class="line">image/jpeg</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示<code>MIME</code> 类型的默认应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &#123;mimetype&#125;</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xdg-mime query default image/jpeg</span><br><span class="line">/usr/share/applications/deepin-image-viewer.desktop</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>显示文件默认应用程序的语法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default &quot;$(xdg-mime query filetype &#123;file&#125;)&quot;</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime query default \</span><br><span class="line">    `xdg-mime query filetype &quot;$(find ~ / -iname &#x27;*.png&#x27; -print -quit)&quot;`</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>MIME</code> 类型的默认打开应用程序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dekstop filetype</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-mime default dde-file-manager.desktop inode/directtory</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a>file 命令</h2><ul>
<li><p>查询文件类型：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file --mime-type INPUT_FILE</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ file --mime-type one.jpg </span><br><span class="line">one.jpg: inode/symlink</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="自定义的-MIME-类型"><a href="#自定义的-MIME-类型" class="headerlink" title="自定义的 MIME 类型"></a>自定义的 MIME 类型</h1><p>如需为系统上的所有用户添加一个自定义的 <code>MIME</code> 类型，并为该 <code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>/usr/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，在 <code>/usr/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<p>比如我们创建一个<code>application/x-newtype</code>类型：</p>
<ol>
<li><p>创建 &#x2F;usr&#x2F;share&#x2F;mime&#x2F;packages&#x2F;application-x-newtype.xml 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;mime-info xmlns=&quot;http://www.freedesktop.org/standards/shared-mime-info&quot;&gt;</span><br><span class="line">&lt;mime-type type=&quot;application/x-newtype&quot;&gt;</span><br><span class="line">    &lt;comment&gt;new mime type&lt;/comment&gt;</span><br><span class="line">    &lt;glob pattern=&quot;*.xyz&quot;/&gt;</span><br><span class="line">&lt;/mime-type&gt;</span><br><span class="line">&lt;/mime-info&gt;</span><br></pre></td></tr></table></figure>
<p> 上述 <code>application-x-newtype.xml</code> 文件定义了一种新的 <code>MIME</code> 类型<code>application/x-newtype</code>，并指定拓展名是 <code>.xyz</code> 的文件为该 <code>MIME</code> 类型。</p>
</li>
<li><p>创建一个名为例如 <code>myapplication1.desktop</code> 的新的 <code>.desktop</code> 文件，并将它放置在 <code>/usr/share/applications/</code> 目录下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=application/x-newtype</span><br><span class="line">Name=My Application 1</span><br><span class="line">Exec=myapplication1</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新 <code>MIME</code> 数据库以使您的更改生效：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-mime-database /usr/share/mime</span><br></pre></td></tr></table></figure>
</li>
<li><p>请以 <code>root</code> 身份更新应用程序数据库：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ update-desktop-database /usr/share/applications</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如需为个别用户添加自定义的 <code>MIME</code> 类型，并为该<code>MIME</code> 类型注册一个默认的应用程序，您需要在 <code>~/.local/share/mime/packages/</code> 目录下创建一个新的 <code>MIME</code> 类型说明文件，并在 <code>~/.local/share/applications/</code> 目录下创建一个 <code>.desktop</code> 文件。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/desktop_migration_and_administration_guide/file_formats">配置文件关联</a></p>
</li>
<li><p><a href="https://www.baeldung.com/linux/file-mime-types">file-mime-types</a></p>
</li>
<li><p><a href="https://specifications.freedesktop.org/mime-apps-spec/mime-apps-spec-latest.html">mime-apps-spec</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mime</tag>
      </tags>
  </entry>
  <entry>
    <title>Disk Arbitration</title>
    <url>/2023/02/16/macos/Disk-Arbitration/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>Disk Arbitration framework</code> 是一个基于 <code>Core Foundation</code> 的低级框架。会在磁盘出现和消失时通知您的应用程序，并让您的应用程序影响该过程。借助 <code>Disk Arbitration</code>，我们可以：</p>
<ul>
<li>检测何时出现新磁盘</li>
<li>阻止挂载</li>
<li>使用不同的标志或在不同的安装点上安装卷</li>
<li>卸载卷</li>
<li>观察卷的变化</li>
</ul>
<span id="more"></span>

<h1 id="使用磁盘仲裁通知和批准回调"><a href="#使用磁盘仲裁通知和批准回调" class="headerlink" title="使用磁盘仲裁通知和批准回调"></a>使用磁盘仲裁通知和批准回调</h1><ol>
<li>通过调用创建会话对象 <code>DASessionCreate</code>。</li>
<li>如果您想知道磁盘相关事件何时发生，请注册通知回调；如果您想积极参与仲裁过程，请注册批准回调。</li>
<li>在运行循环或调度队列上安排会话对象（并在必要时启动运行循环或调度队列）。</li>
<li>处理您的应用收到的任何回调。</li>
<li>当应用程序不再需要接收回调时，取消调度会话对象并释放它。</li>
</ol>
<h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p>编写磁盘仲裁通知客户端时必须做的第一件事是创建一个会话 (<code>DASessionRef</code>)。要创建磁盘仲裁会话，请调用<code>DASessionCreate</code>，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DASessionRef session;</span><br><span class="line">session = DASessionCreate(kCFAllocatorDefault);</span><br></pre></td></tr></table></figure>

<h2 id="注册通知和批准"><a href="#注册通知和批准" class="headerlink" title="注册通知和批准"></a>注册通知和批准</h2><p>磁盘仲裁支持两种类型的回调。通知回调告诉您发生了某些事情。批准回调允许您阻止挂载、卸载或弹出操作发生。</p>
<h3 id="通知回调"><a href="#通知回调" class="headerlink" title="通知回调"></a>通知回调</h3><ul>
<li><code>DADiskAppearedCallback</code>—出现磁盘或出现分区时调用</li>
<li><code>DADiskDescriptionChangedCallback</code>—当磁盘的描述发生变化时调用（在 <code>OS X v10.7</code> 及更高版本中，当首次安装卷时）</li>
<li><code>DADiskDisappearedCallback</code>—弹出可移动磁盘时调用</li>
<li><code>DADiskPeekCallback</code>—在首次探测磁盘时、自动挂载开始之前以及发送任何其他通知之前调用</li>
</ul>
<h3 id="注册函数"><a href="#注册函数" class="headerlink" title="注册函数"></a>注册函数</h3><ul>
<li><code>DARegisterDiskAppearedCallback</code></li>
<li><code>DARegisterDiskDescriptionChangedCallback</code></li>
<li><code>DARegisterDiskDisappearedCallback</code></li>
<li><code>DARegisterDiskPeekCallback</code></li>
</ul>
<p>这些注册函数中的大多数都采用匹配字典。您通常应该传递 <code>NULL``（以匹配所有磁盘）或传递标准匹配字典，例如kDADiskDescriptionMatchMediaUnformatted</code>. 这些匹配字典的详细匹配行为如下所示:</p>
<table>
<thead>
<tr>
<th align="left">标准字典</th>
<th align="left">内容</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">kDADiskDescriptionMatchMediaUnformatted</td>
<td align="left">kDADiskDescriptionMediaSizeKey价值为0</td>
<td align="left">匹配未格式化的媒体（如空白 DVD）。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchMediaWhole</td>
<td align="left">kDADiskDescriptionMediaWholeKey有价值true</td>
<td align="left">仅匹配整盘媒体（&#x2F;dev&#x2F;disk0例如 ）。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchVolumeMountable</td>
<td align="left">kDADiskDescriptionVolumeMountableKey有价值true</td>
<td align="left">匹配可安装的卷。</td>
</tr>
<tr>
<td align="left">kDADiskDescriptionMatchVolumeUnrecognized</td>
<td align="left">kDADiskDescriptionVolumeMountableKey有价值false</td>
<td align="left">匹配不可挂载的磁盘。</td>
</tr>
</tbody></table>
<p>例如，要限制与 USB 连接媒体的匹配，您可以创建一个匹配字典，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFMutableDictionaryRef matchingDict =</span><br><span class="line">    CFDictionaryCreateMutable(</span><br><span class="line">        kCFAllocatorDefault,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">        &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"> </span><br><span class="line">CFDictionaryAddValue(matchingDict,</span><br><span class="line">    kDADiskDescriptionDeviceProtocolKey,</span><br><span class="line">    CFSTR(kIOPropertyPhysicalInterconnectTypeUSB));</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/kernel/kiopropertyphysicalinterconnecttypeusb">IOStorageProtocolCharacteristics.h User-Space Reference</a>中描述了其他互连类型和其他相关常量。最后，只要磁盘事件与指定的匹配字典（或多个字典）和使用上下文指针的事件类型匹配，您就可以将任意数据传递给回调。通过传递不同的上下文指针，您可以使用不同的匹配字典多次注册相同的回调，并向回调提供指示哪个注册匹配的信息。如果您不需要提供此类上下文信息，只需传递NULL此参数即可。</p>
<p>每个回调的详细信息在以下部分中有更详细的描述。</p>
<h3 id="注销通回调"><a href="#注销通回调" class="headerlink" title="注销通回调"></a>注销通回调</h3><p>当您不再需要通知回调时，通过调用取消注册 <code>DAUnregisterCallback</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DAUnregisterCallback(session, mycallbackfuntion, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>请务必传入注册函数时使用的原始上下文指针值</strong>。</p>
<h3 id="批准回调"><a href="#批准回调" class="headerlink" title="批准回调"></a>批准回调</h3><p>通过三种方式在磁盘仲裁中注册批准回调，具体取决于您希望何时收到通知。</p>
<ul>
<li>如果您希望在弹出磁盘之前获得许可，请调用 <code>DARegisterDiskEjectApprovalCallback</code>.</li>
<li>如果您希望在安装卷之前获得许可，请调用 <code>DARegisterDiskMountApprovalCallback</code>.</li>
<li>如果您希望在卸载卷之前获得许可，请调用 <code>DARegisterDiskUnmountApprovalCallback</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DADissenterRef <span class="title function_">allow_mount</span><span class="params">(DADiskRef disk, <span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">session = DASessionCreate(kCFAllocatorDefault);</span><br><span class="line"> </span><br><span class="line">DARegisterDiskMountApprovalCallback(session,</span><br><span class="line">                <span class="literal">NULL</span>, <span class="comment">/* Match all disks */</span></span><br><span class="line">                allow_mount,</span><br><span class="line">                <span class="literal">NULL</span>); <span class="comment">/* No context */</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">DADissenterRef <span class="title function_">allow_mount</span><span class="params">(</span></span><br><span class="line"><span class="params">        DADiskRef disk,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> allow = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (allow) &#123;</span><br><span class="line">                <span class="comment">/* Return NULL to allow */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;allow_mount: allowing mount.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Return a dissenter to deny */</span></span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;allow_mount: refusing mount.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> DADissenterCreate(</span><br><span class="line">                        kCFAllocatorDefault, kDAReturnExclusiveAccess,</span><br><span class="line">                        CFSTR(<span class="string">&quot;It&#x27;s mine!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注销批准回调"><a href="#注销批准回调" class="headerlink" title="注销批准回调"></a>注销批准回调</h3><p>当您不再需要批准回调时，您应该通过调用取消注册 <code>DAUnregisterApprovalCallback</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DAUnregisterApprovalCallback(session, mycallbackfuntion, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>请务必传入注册函数时使用的原始上下文指针值</strong>。</p>
<h2 id="使用调度队列"><a href="#使用调度队列" class="headerlink" title="使用调度队列"></a>使用调度队列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Schedule the session on a dispatch queue. */</span></span><br><span class="line">DASessionSetDispatchQueue(session, <span class="built_in">queue</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Unschedule the session on a dispatch queue. */</span></span><br><span class="line">DASessionSetDispatchQueue(session, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Clean up the session resources. */</span></span><br><span class="line">CFRelease(session);</span><br></pre></td></tr></table></figure>
<h2 id="使用运行循环"><a href="#使用运行循环" class="headerlink" title="使用运行循环"></a>使用运行循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Schedule a disk arbitration session. */</span></span><br><span class="line">DASessionScheduleWithRunLoop(session, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Start the run loop.  (Don&#x27;t do this if you already have</span></span><br><span class="line"><span class="comment">   a running Core Foundation or Cocoa run loop.) */</span></span><br><span class="line">CFRunLoopRun();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Clean up a session. */</span></span><br><span class="line">DASessionUnscheduleFromRunLoop(session,</span><br><span class="line">    CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);</span><br><span class="line">CFRelease(session);</span><br></pre></td></tr></table></figure>

<h1 id="操作磁盘和卷"><a href="#操作磁盘和卷" class="headerlink" title="操作磁盘和卷"></a>操作磁盘和卷</h1><h2 id="获取磁盘对象"><a href="#获取磁盘对象" class="headerlink" title="获取磁盘对象"></a>获取磁盘对象</h2><p>在您可以操作磁盘或卷之前，您必须<code>DADiskRef</code>为该磁盘或卷获取一个对象。通过四种方式获取对象：</p>
<ul>
<li>作为传递给事件回调的参数（在使用磁盘仲裁通知和批准回调中描述）</li>
<li>通过调用从 <code>io_service_t</code>用户空间引用到有效设备切片的对象 <code>IOMediaDADiskCreateFromIOMedia</code></li>
<li>您可以通过调用或io_service_t来获取对象的用户空间引用。</li>
<li>从 <code>BSD</code> 设备名称（disk1s1例如）使用 <code>DADiskCreateFromBSDName</code></li>
<li>从挂载点调用 <code>DADiskCreateFromVolumePath</code></li>
</ul>
<p>如果您有一个<code>io_service_t</code>对象或一个 <code>BSD</code> 设备名称，您的应用程序可以创建一个<code>DADiskRef</code>对象，如下所示：</p>
<p><code>DASessionRef</code>按照创建会话中的描述创建一个对象。</p>
<ul>
<li>按照<code>Scheduling the Session with the Run Loop or Dispatch Queue</code>中的描述安排它。确保您的调度队列或运行循环正在运行。</li>
<li>创建磁盘对象。</li>
<li>根据需要操纵它们。</li>
</ul>
<h2 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h2><p>盘仲裁提供三个函数来获取有关磁盘和分区的附加信息：<code>DADiskCopyDescription</code> 、<code>DADiskGetBSDName</code> 和<code>DADiskCopyIOMedia</code>。通常，您可以通过调用 获得关于特定磁盘的几乎所有信息 <code>DADiskCopyDescription</code>。然而，对于一些相当深奥的信息，您可能必须<code>IOMedia</code>为磁盘获取一个对象并查询该对象。</p>
<p>如果您需要磁盘或分区的 <code>BSD</code> 设备名称（<code>disk1s1</code>例如）作为 <code>C</code> 字符串（通常在使用 <code>POSIX</code> 级 <code>API</code> 时使用），请调用 <code>DADiskGetBSDName</code>.<br>对于大多数其他信息，请调用<code>DADiskCopyDescription</code>，如获取描述字典中所述。<br>如果无法通过 获得您需要的信息 <code>DADiskCopyDescription</code>，请调用DADiskCopyIOMedia。</p>
<h3 id="获取描述字典"><a href="#获取描述字典" class="headerlink" title="获取描述字典"></a>获取描述字典</h3><p><code>DADiskCopyDescription</code>方法返回一个 <code>CFDictionaryRef</code> 对象，其中包含有关磁盘或分区的几十条信息。一些常用的数据包括：</p>
<ul>
<li>挂载点和卷名</li>
<li><code>BSD</code> 设备节点名称和主要和次要编号</li>
<li>有关硬件的信息（<code>设备 ID</code> 、<code>供应商 ID</code> 、<code>GUID</code> 等）</li>
<li>连接信息（总线名称和路径</li>
</ul>
<p>您可以在磁盘仲裁框架的标头中找到完整的属性列表 <a href="https://developer.apple.com/documentation/diskarbitration/dadisk_h?language=objc">DADisk.h Reference.</a>，以及每个键值的预期数据类型的描述。</p>
<h3 id="从-I-O-Kit-获取附加信息"><a href="#从-I-O-Kit-获取附加信息" class="headerlink" title="从 I/O Kit 获取附加信息"></a>从 <code>I/O Kit</code> 获取附加信息</h3><p>在极少数情况下，您可能需要获取有关磁盘的其他信息，而不是磁盘仲裁提供的信息。如果这样做，您可以调用<code>DADiskCopyIOMedia</code>以获取一个 <code>io_service_t</code>对象，该对象是对象的用户空间表示 <code>IOMedia</code>。您可以像操作任何 <code>I/O Registry</code> 对象一样操作此对象。</p>
<p>例如，您可以通过调用 <code>IORegistryEntryCreateCFProperties</code>结果对象来获取具有媒体 <code>I/O</code> 注册表属性的 <code>Core Foundation</code> 字典。</p>
<p><code>I/O Registry</code> 字典中的属性在 <code>I/O Kit Framework</code> 中定义。有关详细信息，请参阅<a href="https://developer.apple.com/documentation/iokit">I&#x2F;O Kit Framework Reference</a>。</p>
<h2 id="安装和卸载卷"><a href="#安装和卸载卷" class="headerlink" title="安装和卸载卷"></a>安装和卸载卷</h2><ul>
<li><p><code>DADiskMount</code></p>
</li>
<li><p><code>DADiskMountWithArguments</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *mppath = <span class="string">&quot;/mnt/mydisk&quot;</span>;</span><br><span class="line"></span><br><span class="line">path = CFURLCreateFromFileSystemRepresentation(</span><br><span class="line">    kCFAllocatorDefault,</span><br><span class="line">    mppath,</span><br><span class="line">    <span class="built_in">strlen</span>(mppath),</span><br><span class="line">    <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">DADiskMountWithArguments(disk, path, kDADiskMountOptionDefault,</span><br><span class="line">    mount_complete_callback, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>DADiskUnmount</code></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">DADissenterRef dissenter,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">DADiskUnmount(disk, kDADiskUnmountOptionDefault,</span><br><span class="line">    unmount_done, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        <span class="comment">/* Unmount failed. */</span></span><br><span class="line">        <span class="type">char</span> buf[MAXPATHLEN];</span><br><span class="line">        <span class="keyword">if</span> (CFURLGetFileSystemRepresentation(fspath, <span class="literal">false</span>, (UInt8 *)buf, <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unmount failed (Error: 0x%x Reason: %s).  Retrying.\n&quot;</span>,</span><br><span class="line">                DADissenterGetStatus(dissenter),</span><br><span class="line">                buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Something is *really* wrong. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Do something. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="弹出磁盘"><a href="#弹出磁盘" class="headerlink" title="弹出磁盘"></a>弹出磁盘</h2><p>在弹出磁盘之前，您必须卸载磁盘上的所有卷。首先调用 <code>DADiskUnmount</code>，将整个磁盘分区作为磁盘参数传递，并<code>kDADiskUnmountOptionWhole</code> 在卸载选项中设置标志。然后调用 <code>DADiskEject</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eject_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Unmount all volumes */</span></span><br><span class="line">DADiskRef wholedisk = DADiskCopyWholeDisk(partition);</span><br><span class="line">DADiskUnmount(wholedisk, kDADiskUnmountOptionWhole,</span><br><span class="line">    unmount_done, <span class="literal">NULL</span>);</span><br><span class="line">CFRelease(wholedisk);</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* In the unmount callback, eject the volume. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmount_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DADiskEject(disk, kDADiskEjectOptionDefault,</span><br><span class="line">            eject_done, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Eject callback. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eject_done</span><span class="params">(DADiskRef disk,</span></span><br><span class="line"><span class="params">    DADissenterRef dissenter,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dissenter) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/DriversKernelHardware/Conceptual/DiskArbitrationProgGuide/">Disk Arbitration Programming Guide</a></li>
</ul>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Disk</tag>
      </tags>
  </entry>
  <entry>
    <title>@executable path, @load path 和 @rpath</title>
    <url>/2023/08/25/macos/executable-path-load-path-%E5%92%8C-rpath/</url>
    <content><![CDATA[<p>在 <code>macOS</code> 上，动态链接器使用特定的路径变量来解析运行时的库位置。这些路径变量包括：绝对路径、 <code>@executable_path</code>、<code>@loader_path</code> 和 <code>@rpath</code>。</p>
<h1 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h1><p>对于安装在系统中共享位置的框架很有用，一般是 <code>/Library/Frameworks/xxx</code>、 <code>/usr/lib/xxx</code>, 但是查找嵌入在应用内部的动态库就很难使用，应用安装的位置都不固定，所以引出新的方式。</p>
<h1 id="executable-path"><a href="#executable-path" class="headerlink" title="@executable path"></a>@executable path</h1><p><code>@executable_path</code> 是用于指代<strong>当前正在执行的程序或应用的路径</strong>。当你的应用程序或其动态库需要引用位于与可执行文件相同路径（或其子目录）下的其他动态库时，这会非常有用。</p>
<span id="more"></span>
<p>举例说明: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyApp/</span><br><span class="line">|-- MyApp.app/</span><br><span class="line">    |-- Contents/</span><br><span class="line">        |-- MacOS/</span><br><span class="line">            |-- MyApp (可执行文件)</span><br><span class="line">            |-- libA.dylib (动态库A)</span><br><span class="line">        |-- Frameworks/</span><br><span class="line">            |-- libB.dylib (动态库B)</span><br></pre></td></tr></table></figure>

<p>假设 <code>MyApp</code> 依赖于 <code>libA.dylib</code>，而 <code>libA.dylib</code> 依赖于 <code>libB.dylib</code>。<br>如果你希望 <code>libA.dylib</code> 在运行时找到 <code>libB.dylib</code>，可以设置 <code>libB.dylib</code> 的安装名称为 <code>@executable_path/../Frameworks/libB.dylib</code>。当 <code>MyApp</code> 启动并加载 <code>libA.dylib</code> 时，<code>@executable_path</code> 将解析为 <code>MyApp.app/Contents/MacOS/</code>，因此 <code>libA.dylib</code> 会正确地找到 <code>libB.dylib</code> 在 <code>MyApp.app/Contents/Frameworks/</code> 目录下。</p>
<h1 id="load-path"><a href="#load-path" class="headerlink" title="@load path"></a>@load path</h1><p><strong>加载的动态库的路径</strong>。在很多情况下，这个路径是基于正在加载该库的模块，因此它可能会随着加载该库的不同模块而变化。</p>
<p>举例说明:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyApp/</span><br><span class="line">|-- MyApp.app/</span><br><span class="line">    |-- Contents/</span><br><span class="line">        |-- MacOS/</span><br><span class="line">            |-- MyApp (主应用程序)</span><br><span class="line">            |-- libMain.dylib (主应用的动态库)</span><br><span class="line">        |-- Plugins/</span><br><span class="line">            |-- PluginA.bundle/</span><br><span class="line">                |-- PluginA (插件)</span><br><span class="line">                |-- libPluginA.dylib (插件的动态库)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>MyApp</code> 依赖 <code>libMain.dylib</code>，而 <code>PluginA</code> 依赖 <code>libPluginA.dylib</code>。</p>
<ul>
<li><p>使用 <code>@executable_path</code>：</p>
<p>如果 <code>libMain.dylib</code> 需要引用与其位于同一目录下的另一个库，如 <code>libHelper.dylib</code>，它可以使用 <code>@executable_path/libHelper.dylib</code> 作为路径。但是，这对 <code>PluginA</code> 中的库不起作用，因为 <code>@executable_path</code> 总是指向 <code>MyApp.app/Contents/MacOS/</code>，不考虑加载它的实际模块。</p>
</li>
<li><p>使用 <code>@loader_path</code>：</p>
<p>如果 <code>libPluginA.dylib</code> 需要引用与其位于同一目录下的另一个库，如 <code>libHelper.dylib</code>，它可以使用 <code>@loader_path/libHelper.dylib</code> 作为路径。这样，不管 <code>libPluginA.dylib</code> 被哪个模块加载，它都会正确地引用到相对于加载它的模块的库。</p>
</li>
</ul>
<p><strong>如果是一个应用程序，那么 <code>@load path</code> 与 <code>@executable_path</code> 相同。</strong></p>
<h1 id="rpath"><a href="#rpath" class="headerlink" title="@rpath"></a>@rpath</h1><p><code>@rpath (Runtime Search Path)</code> 提供了一种动态方式来指定和查找动态库。它的主要优势是提供了更多的灵活性，尤其是在面对多种可能的库位置或多个版本的库时。</p>
<p>举例说明:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyApp/</span><br><span class="line">|-- MyApp.app/</span><br><span class="line">    |-- Contents/</span><br><span class="line">        |-- MacOS/</span><br><span class="line">            |-- MyApp (可执行文件)</span><br><span class="line">        |-- Frameworks/</span><br><span class="line">            |-- libA.dylib (动态库A版本1)</span><br><span class="line">        |-- Plugins/</span><br><span class="line">            |-- PluginA/</span><br><span class="line">                |-- libA.dylib (动态库A版本2)</span><br></pre></td></tr></table></figure>

<p>假设 <code>MyApp</code> 可能需要加载两个版本中的任何一个 <code>libA.dylib</code>，具体取决于特定的运行时情境。使用<code> @rpath</code> 可以轻松管理这种情况。</p>
<ul>
<li><p>设置 <code>@rpath</code>:</p>
<p>  在构建 <code>MyApp</code> 时，你可以设置多个运行时搜索路径（<code>rpaths</code>）:</p>
<ul>
<li><code>@executable_path/../Frameworks</code></li>
<li><code>@executable_path/../Plugins/PluginA</code></li>
</ul>
</li>
<li><p>使用 <code>@rpath</code> 在动态库中:</p>
<p>  设 <code>libA.dylib</code> 的安装名称为 <code>@rpath/libA.dylib</code>。</p>
</li>
<li><p>运行时解析:</p>
<p>  当 <code>MyApp</code> 需要加载 <code>libA.dylib</code> 时，它会沿着 <code>rpath</code> 列表搜索。首先在 <code>Frameworks</code> 文件夹中查找，然后在 <code>PluginA</code> 文件夹中查找。</p>
</li>
</ul>
<p>这种方法的好处是，你可以轻松地将相同的库放在多个位置，而不需要为每个位置硬编码路径。此外，应用程序的用户或开发人员可以通过修改 <code>rpath</code> 来改变库的搜索顺序或位置。</p>
<h1 id="install-name-tool"><a href="#install-name-tool" class="headerlink" title="install_name_tool"></a><code>install_name_tool</code></h1><p>要查看或修改一个可执行文件或动态库的 <code>rpath</code>，你可以使用 <code>otool</code> 和 <code>install_name_tool</code> 这两个命令行工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ otool -l WeChat</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Load command 104</span><br><span class="line">          cmd LC_LOAD_DYLIB</span><br><span class="line">      cmdsize 64</span><br><span class="line">         name /usr/lib/swift/libswiftsimd.dylib (offset 24)</span><br><span class="line">   time stamp 2 Thu Jan  1 08:00:02 1970</span><br><span class="line">      current version 9.0.0</span><br><span class="line">compatibility version 1.0.0</span><br><span class="line">Load command 105</span><br><span class="line">          cmd LC_LOAD_DYLIB</span><br><span class="line">      cmdsize 64</span><br><span class="line">         name /usr/lib/swift/libswiftFoundation.dylib (offset 24)</span><br><span class="line">   time stamp 2 Thu Jan  1 08:00:02 1970</span><br><span class="line">      current version 1.0.0</span><br><span class="line">compatibility version 1.0.0</span><br><span class="line">Load command 106</span><br><span class="line">          cmd LC_RPATH</span><br><span class="line">      cmdsize 32</span><br><span class="line">         path /usr/lib/swift (offset 12)</span><br><span class="line">Load command 107</span><br><span class="line">          cmd LC_RPATH</span><br><span class="line">      cmdsize 48</span><br><span class="line">         path @executable_path/../Frameworks (offset 12)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加 <code>rpath</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install_name_tool -add_rpath @executable_path/. a.out</span><br></pre></td></tr></table></figure>

<p>修改 <code>rpath</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install_name_tool -change libFoo @rpath/libFoo a.out</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>DYLD</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 完全磁盘访问权限</title>
    <url>/2024/01/05/macos/macOS-%E5%AE%8C%E5%85%A8%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Ventura App 管理</title>
    <url>/2024/01/04/macos/macOS-Ventura-App-%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>从 <code>macOS Monterey</code> 开始，如果应用程序被未由相同开发团队签名且未由 <code>NSUpdateSecurityPolicy</code> 允许的东西修改，<code>macOS</code> 将阻止修改并通知用户应用程序希望管理其他应用程序。点击通知会将用户发送到系统设置，他们可以在那里允许应用程序更新和修改其他应用程序。</p>
<p><img src="/images/appmanager.png" alt="appmanager"></p>
<span id="more"></span>

<ul>
<li>从 <code>macOS Ventura</code> 开始，<code>Gatekeeper</code> 将检查所有经过公证的应用程序的完整性，而不仅仅是隔离的应用程序。</li>
<li>从 <code>macOS Ventura</code> 开始，如果您的认证应用程序的签名不再有效，<code>Gatekeeper</code> 将在<strong>首次启动</strong>时阻止其运行。<ul>
<li><code>macOS Monterey</code> 及更早版本仅在修改后的已认证应用程序仍<strong>处于隔离状态</strong>时才会阻止首次启动。</li>
</ul>
</li>
<li>从 <code>macOS Ventura</code> 开始，<code>Gatekeeper</code> 还将阻止应用以某些方式修改您的应用程序。</li>
<li><strong>完全磁盘访问自动包含应用程序管理权限</strong>。即使在系统设置中禁用了应用程序管理权限。</li>
<li>应用程序如何更新<ul>
<li>由同一开发者帐户或团队有效签名的应用程序将继续能够互相更新。这将自动进行。</li>
<li>要允许另一个开发团队更新您的应用程序或限制仅由您的更新程序更新，需要在 <code>info-plist</code>，添加 <code>NSUpdateSecurityPolicy</code> 。在 <code>NSUpdateSecurityPolicy</code> 内部，添加”<code>AllowProcesses</code>“，一个将团队标识符映射到签名标识符数组的字典。</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2022/10096/">What’s new in privacy</a></li>
<li><a href="https://lapcatsoftware.com/articles/AppManagement.html">How macOS Ventura App Management works and doesn’t work</a></li>
</ul>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 设置面板快捷链接</title>
    <url>/2023/12/28/macos/macOS-%E8%AE%BE%E7%BD%AE%E9%9D%A2%E6%9D%BF%E5%BF%AB%E6%8D%B7%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Accessibility-Preference-Pane"><a href="#Accessibility-Preference-Pane" class="headerlink" title="Accessibility Preference Pane"></a>Accessibility Preference Pane</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main    x-apple.systempreferences:com.apple.preference.universalaccess</span><br><span class="line">Display x-apple.systempreferences:com.apple.preference.universalaccess?Seeing_Display</span><br><span class="line">Zoom    x-apple.systempreferences:com.apple.preference.universalaccess?Seeing_Zoom</span><br><span class="line">VoiceOver   x-apple.systempreferences:com.apple.preference.universalaccess?Seeing_VoiceOver</span><br><span class="line">Descriptions    x-apple.systempreferences:com.apple.preference.universalaccess?Media_Descriptions</span><br><span class="line">Captions    x-apple.systempreferences:com.apple.preference.universalaccess?Captioning</span><br><span class="line">Audio   x-apple.systempreferences:com.apple.preference.universalaccess?Hearing</span><br><span class="line">Keyboard    x-apple.systempreferences:com.apple.preference.universalaccess?Keyboard</span><br><span class="line">Mouse &amp; Trackpad    x-apple.systempreferences:com.apple.preference.universalaccess?Mouse</span><br><span class="line">Switch Control  x-apple.systempreferences:com.apple.preference.universalaccess?Switch</span><br><span class="line">Dictation   x-apple.systempreferences:com.apple.preference.universalaccess?SpeakableItems</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="Security-Privacy-Preference-Pane"><a href="#Security-Privacy-Preference-Pane" class="headerlink" title="Security &amp; Privacy Preference Pane"></a>Security &amp; Privacy Preference Pane</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main    x-apple.systempreferences:com.apple.preference.security</span><br><span class="line">General x-apple.systempreferences:com.apple.preference.security?General</span><br><span class="line">FileVault   x-apple.systempreferences:com.apple.preference.security?FDE</span><br><span class="line">Firewall    x-apple.systempreferences:com.apple.preference.security?Firewall</span><br><span class="line">Advanced    x-apple.systempreferences:com.apple.preference.security?Advanced</span><br><span class="line">Privacy x-apple.systempreferences:com.apple.preference.security?Privacy</span><br><span class="line">Privacy-Camera x-apple.systempreferences:com.apple.preference.security?Privacy_Camera</span><br><span class="line">Privacy-Microphone  x-apple.systempreferences:com.apple.preference.security?Privacy_Microphone</span><br><span class="line">Privacy-Automation  x-apple.systempreferences:com.apple.preference.security?Privacy_Automation</span><br><span class="line">Privacy-AllFiles    x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles</span><br><span class="line">Privacy-Accessibility   x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility</span><br><span class="line">Privacy-Assistive   x-apple.systempreferences:com.apple.preference.security?Privacy_Assistive</span><br><span class="line">Privacy-Location Services   x-apple.systempreferences:com.apple.preference.security?Privacy_LocationServices</span><br><span class="line">Privacy-SystemServices  x-apple.systempreferences:com.apple.preference.security?Privacy_SystemServices</span><br><span class="line">Privacy-Advertising x-apple.systempreferences:com.apple.preference.security?Privacy_Advertising</span><br><span class="line">Privacy-Contacts    x-apple.systempreferences:com.apple.preference.security?Privacy_Contacts</span><br><span class="line">Privacy-Diagnostics &amp; Usage x-apple.systempreferences:com.apple.preference.security?Privacy_Diagnostics</span><br><span class="line">Privacy-Calendars   x-apple.systempreferences:com.apple.preference.security?Privacy_Calendars</span><br><span class="line">Privacy-Reminders   x-apple.systempreferences:com.apple.preference.security?Privacy_Reminders</span><br><span class="line">Privacy-Facebook    x-apple.systempreferences:com.apple.preference.security?Privacy_Facebook</span><br><span class="line">Privacy-LinkedIn    x-apple.systempreferences:com.apple.preference.security?Privacy_LinkedIn</span><br><span class="line">Privacy-Twitter x-apple.systempreferences:com.apple.preference.security?Privacy_Twitter</span><br><span class="line">Privacy-Weibo   x-apple.systempreferences:com.apple.preference.security?Privacy_Weibo</span><br><span class="line">Privacy-Tencent Weibo   x-apple.systempreferences:com.apple.preference.security?Privacy_TencentWeibo</span><br></pre></td></tr></table></figure>

<h2 id="macOS-Catalina-10-15"><a href="#macOS-Catalina-10-15" class="headerlink" title="macOS Catalina 10.15"></a>macOS Catalina 10.15</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Privacy-ScreenCapture   x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture</span><br><span class="line">Privacy-DevTools    x-apple.systempreferences:com.apple.preference.security?Privacy_DevTools</span><br><span class="line">Privacy-InputMonitoring x-apple.systempreferences:com.apple.preference.security?Privacy_ListenEvent</span><br><span class="line">Privacy-DesktopFolder   x-apple.systempreferences:com.apple.preference.security?Privacy_DesktopFolder</span><br><span class="line">Privacy-DocumentsFolder x-apple.systempreferences:com.apple.preference.security?Privacy_DocumentsFolder</span><br><span class="line">Privacy-DownloadsFolder x-apple.systempreferences:com.apple.preference.security?Privacy_DownloadsFolder</span><br><span class="line">Privacy-NetworkVolume   x-apple.systempreferences:com.apple.preference.security?Privacy_NetworkVolume</span><br><span class="line">Privacy-RemovableVolume x-apple.systempreferences:com.apple.preference.security?Privacy_RemovableVolume</span><br><span class="line">Privacy-SpeechRecognition   x-apple.systempreferences:com.apple.preference.security?Privacy_SpeechRecognition</span><br></pre></td></tr></table></figure>
<h1 id="Dictation-Speech-Preference-Pane"><a href="#Dictation-Speech-Preference-Pane" class="headerlink" title="Dictation &amp; Speech Preference Pane"></a>Dictation &amp; Speech Preference Pane</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dictation   x-apple.systempreferences:com.apple.preference.speech?Dictation</span><br><span class="line">Text to Speech  x-apple.systempreferences:com.apple.preference.speech?TTS</span><br><span class="line">Sharing Preference Pane</span><br><span class="line">Main    x-apple.systempreferences:com.apple.preferences.sharing</span><br><span class="line">Screen Sharing  x-apple.systempreferences:com.apple.preferences.sharing?Services_ScreenSharing</span><br><span class="line">File Sharing    x-apple.systempreferences:com.apple.preferences.sharing?Services_PersonalFileSharing</span><br><span class="line">Printer Sharing x-apple.systempreferences:com.apple.preferences.sharing?Services_PrinterSharing</span><br><span class="line">Remote Login    x-apple.systempreferences:com.apple.preferences.sharing?Services_RemoteLogin</span><br><span class="line">Remote Management   x-apple.systempreferences:com.apple.preferences.sharing?Services_ARDService</span><br><span class="line">Remote Apple Events x-apple.systempreferences:com.apple.preferences.sharing?Services_RemoteAppleEvent</span><br><span class="line">Internet Sharing    x-apple.systempreferences:com.apple.preferences.sharing?Internet</span><br><span class="line">Bluetooth Sharing   x-apple.systempreferences:com.apple.preferences.sharing?Services_BluetoothSharing</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O 相关记录</title>
    <url>/2023/03/10/macos/mach-o/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1>]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>存储和加载指令</title>
    <url>/2023/03/18/macos/%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="存储和加载指令"><a href="#存储和加载指令" class="headerlink" title="存储和加载指令"></a>存储和加载指令</h3><h4 id="ldr-指令寻址之1：-地址偏移模式-unsigned-offset"><a href="#ldr-指令寻址之1：-地址偏移模式-unsigned-offset" class="headerlink" title="ldr 指令寻址之1： 地址偏移模式 (unsigned offset)"></a><code>ldr</code> 指令寻址之1： 地址偏移模式 (<code>unsigned offset</code>)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR Xd, [Xn, $offset]</span><br></pre></td></tr></table></figure>
<p>首先在 <code>Xn</code> 寄存器的内容上加上一个 <code>offset</code> 偏移量后作为内存地址，加载此地址的内容到 <code>Xd</code> 寄存器。</p>
<h4 id="ldr-指令寻址之2：-变基模式"><a href="#ldr-指令寻址之2：-变基模式" class="headerlink" title="ldr 指令寻址之2： 变基模式"></a><code>ldr</code> 指令寻址之2： 变基模式</h4><ul>
<li>前变基模式（<code>pre-index</code> 模式）： 先更新偏移地址然后再访问内存。</li>
<li>后变基模式（<code>post-index</code> 模式）：先访问内存地址然后再更新偏移地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR X0, [X1, #8]! // 前变基模式。先更新X1 的值为 X1+8，然后义新的X1值为地址，加载内存的值到X0</span><br><span class="line"></span><br><span class="line">LDR X0, [X1], #8  // 后变基模式。以x1的值为地址，加载该内存地址的值到X0，然后在更新X1寄存器为X1+8</span><br></pre></td></tr></table></figure>

<h4 id="ldr-指令寻址之3：-标签（literal）"><a href="#ldr-指令寻址之3：-标签（literal）" class="headerlink" title="ldr 指令寻址之3： 标签（literal）"></a><code>ldr</code> 指令寻址之3： 标签（<code>literal</code>）</h4><p>PC + label offset</p>
<h4 id="ldr-伪指令"><a href="#ldr-伪指令" class="headerlink" title="ldr 伪指令"></a>ldr 伪指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR x7, =MY_LABEL</span><br></pre></td></tr></table></figure>

<h4 id="move-指令"><a href="#move-指令" class="headerlink" title="move 指令"></a>move 指令</h4><ul>
<li>16位立即数</li>
<li>16立即数左移16，32，48位</li>
</ul>
<h4 id="多字节加载和存储指令-ldp-和stp"><a href="#多字节加载和存储指令-ldp-和stp" class="headerlink" title="多字节加载和存储指令 ldp 和stp"></a>多字节加载和存储指令 ldp 和stp</h4>]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb 入门-Aggregate</title>
    <url>/2023/08/31/mongodb/mongodb-%E5%85%A5%E9%97%A8-Aggregate/</url>
    <content><![CDATA[<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1>]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS平台上符号化崩溃报告</title>
    <url>/2022/07/26/macos/%E5%9C%A8MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="dSYM"><a href="#dSYM" class="headerlink" title=".dSYM"></a><code>.dSYM</code></h1><p><code>.dSYM</code> (<code>debugging SYMbols</code>) 又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的 <code>DWARF</code>（<code>Debugging With Attributed Record Formats</code>），其在.xcarchive目录中的层次结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.xcarchive</span><br><span class="line">--dSYMs</span><br><span class="line">  |--Your.app.dSYM</span><br><span class="line">    |--Contents</span><br><span class="line">      |--Resources</span><br><span class="line">        |--DWARF</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果在XCode中设置了带有 <code>dSYM</code> 文件的 <code>DWARF</code> 选项，则编译器会生成 <code>dSYM</code> 文件，并将其存储在您的构建中。</p>
<p><img src="/../../images/dsym.png"></p>
<h1 id="确定符号表和崩溃日志的一致性"><a href="#确定符号表和崩溃日志的一致性" class="headerlink" title="确定符号表和崩溃日志的一致性"></a>确定符号表和崩溃日志的一致性</h1><h2 id="崩溃日志中获取UUID"><a href="#崩溃日志中获取UUID" class="headerlink" title="崩溃日志中获取UUID"></a>崩溃日志中获取UUID</h2><p>崩溃日志比较靠下的位置有个 <code>Binary Images</code> 模块，其第一行内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x109724000 - 0x109cf7fff Your &lt;19a667b1-8910-3890-a0b0-03befee8876e&gt; /Library/Application Support/YourApp/*/YourApp.app/Contents/MacOS/YourApp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>代码段的起终地址: <code>0x109724000 - 0x109cf7fff</code></li>
<li>应用的UUID：<code>19a667b1-8910-3890-a0b0-03befee8876e</code>（不区分大小写）</li>
</ul>
<h2 id="从符号表中获取UUID"><a href="#从符号表中获取UUID" class="headerlink" title="从符号表中获取UUID"></a>从符号表中获取UUID</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --uuid Your.app.dSYM</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --uuid Your.app.dSYM/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure>

<p><strong>崩溃日志中和符号表中的UUID一致，才能正确解析</strong></p>
<h1 id="计算崩溃符号表地址"><a href="#计算崩溃符号表地址" class="headerlink" title="计算崩溃符号表地址"></a>计算崩溃符号表地址</h1><h2 id="符号表堆栈地址计算方式"><a href="#符号表堆栈地址计算方式" class="headerlink" title="符号表堆栈地址计算方式"></a>符号表堆栈地址计算方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 0::  Dispatch queue: com.apple.main-thread</span><br><span class="line">0   libsystem_kernel.dylib        	    0x7ff8159e775e write + 10</span><br><span class="line">1   libapr-1.0.dylib              	    0x10a6c1cee apr_file_write + 286</span><br><span class="line">2   liblog4cxx.10.0.0.dylib       	    0x10a369531 log4cxx::helpers::FileOutputStream::write(log4cxx::helpers::ByteBuffer&amp;, log4cxx::helpers::Pool&amp;) + 81</span><br><span class="line">3   Your      	                        0x10a3ae877❶  0x10a340000❷ + 452727❸</span><br></pre></td></tr></table></figure>

<ul>
<li>❶ 运行时堆栈地址</li>
<li>❷ 运行时起始地址</li>
<li>❸ 偏移量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时堆栈地址 = 运行时起始地址 + 偏移量</span><br></pre></td></tr></table></figure>

<p>崩溃堆栈中的起始地址和崩溃地址均为运行时地址，根据虚拟内存偏移量不变原理，只要提供了符号表TEXT段的起始地址，再加上偏移量就能得到符号表中的堆栈地址，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">符号表堆栈地址 = 符号表起始地址 + 偏移量</span><br></pre></td></tr></table></figure>

<h2 id="符号表中TEXT段的起始地址可以通过以下命令获得："><a href="#符号表中TEXT段的起始地址可以通过以下命令获得：" class="headerlink" title="符号表中TEXT段的起始地址可以通过以下命令获得："></a>符号表中TEXT段的起始地址可以通过以下命令获得：</h2><p>使用 <code>otool</code> 查找 <code>LC_SEGMENT_64</code> 段和 <code>vmaddr</code> 条目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ otool -l Your.app.dSYM/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load command 4</span><br><span class="line">      cmd LC_SEGMENT_64</span><br><span class="line">  cmdsize 232</span><br><span class="line">  segname __TEXT</span><br><span class="line">   vmaddr 0x0000000100000000·</span><br><span class="line">   vmsize 0x0000000000004000</span><br><span class="line">  fileoff 0</span><br><span class="line"> filesize 0</span><br><span class="line">  maxprot 0x00000005</span><br><span class="line"> initprot 0x00000005</span><br><span class="line">   nsects 2</span><br><span class="line">    flags 0x0</span><br></pre></td></tr></table></figure>
<p>其中的<code>vmaddr 0x0000000100000000</code>字段即为TEXT段的起始地址。</p>
<h1 id="使用-LLDB-进行符号化"><a href="#使用-LLDB-进行符号化" class="headerlink" title="使用 LLDB 进行符号化"></a>使用 <code>LLDB</code> 进行符号化</h1><h2 id="crashlog"><a href="#crashlog" class="headerlink" title="crashlog"></a>crashlog</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ xcrun lldb</span><br><span class="line"></span><br><span class="line">(lldb) command script import lldb.macosx.crashlog</span><br><span class="line"></span><br><span class="line">(lldb) crashlog &lt;path/to/crashlog.crash&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(lldb) target create --no-dependents --arch &lt;architecture&gt; &lt;path/to/dSYMs/App.app.dSYM/Contents/Resources/DWARF/App&gt;</span><br><span class="line"></span><br><span class="line">(lldb) image lookup --address &lt;symboladdress&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-ATOS-符号化"><a href="#使用-ATOS-符号化" class="headerlink" title="使用 ATOS 符号化"></a>使用 <code>ATOS</code> 符号化</h1><h2 id="符号表崩溃地址的解析方式"><a href="#符号表崩溃地址的解析方式" class="headerlink" title="符号表崩溃地址的解析方式"></a>符号表崩溃地址的解析方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; -l &lt;load address&gt; &lt;stack address 1&gt; &lt;stack address 2&gt; ...</span><br></pre></td></tr></table></figure>

<h2 id="无需符号表崩溃地址的解析方式"><a href="#无需符号表崩溃地址的解析方式" class="headerlink" title="无需符号表崩溃地址的解析方式"></a>无需符号表崩溃地址的解析方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; &lt;symboladdress&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-Dwarfdump-符号化"><a href="#使用-Dwarfdump-符号化" class="headerlink" title="使用 Dwarfdump 符号化"></a>使用 <code>Dwarfdump</code> 符号化</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dwarfdump --arch x86_64 Your.app.dSYM --lookup symboladdress</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb 入门-CRUD</title>
    <url>/2023/08/27/mongodb/mongodb-%E5%85%A5%E9%97%A8-CRUD/</url>
    <content><![CDATA[<h1 id="文档主键"><a href="#文档主键" class="headerlink" title="文档主键"></a>文档主键</h1><h2 id="文档主键-id"><a href="#文档主键-id" class="headerlink" title="文档主键 _id"></a>文档主键 <code>_id</code></h2><p>文档主键 <code>_id</code> 是每篇文档必备的字段,具有以下特性:</p>
<ul>
<li>文档主键的唯一性</li>
<li>支持所有数据类型(数组除外)</li>
<li>复合主键</li>
</ul>
<h2 id="对象主键-ObjectId"><a href="#对象主键-ObjectId" class="headerlink" title="对象主键 ObjectId"></a>对象主键 <code>ObjectId</code></h2><p>当我们不提供主键，<code>MongoDB</code> 自动为我们生成的默认对象主键 <code>ObjectId</code></p>
<ul>
<li>默认的文档主键</li>
<li>可以快速生成的 <code>12</code> 字节 <code>id</code></li>
<li>包含创建时间</li>
</ul>
<p><code>ObjectId</code> 默认值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">ObjectId()</span></span><br><span class="line">ObjectId(&quot;64eeed51b64b9d7e95e6b8ea&quot;)</span><br></pre></td></tr></table></figure>
<p>手动设置 <code>ObjectId</code> 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">ObjectId(<span class="string">&quot;123456789011123456789011&quot;</span>)</span></span><br><span class="line">ObjectId(&quot;123456789011123456789011&quot;)</span><br></pre></td></tr></table></figure>

<p>提取 <code>ObjectId</code> 的创建时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">ObjectId(<span class="string">&quot;123456789011123456789011&quot;</span>).getTimestamp()</span></span><br><span class="line">ISODate(&quot;1979-09-05T22:51:36.000Z&quot;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h2><p>使用文档作为文档主键</p>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.insert(&#123;</span><br><span class="line">    _id: &#123;accountNo: &quot;001&quot;, type: &quot;savings&quot;&#125;,</span><br><span class="line">    name: &quot;irene&quot;,</span><br><span class="line">    balance: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>复合主键仍然要满足文档主键的唯一性</strong>，需要字段值和顺序完全一致才算重复。</p>
<p>下面是不同的 <code>_id</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_id: &#123;accountNo: &quot;001&quot;, type: &quot;savings&quot;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_id: &#123; type: &quot;savings&quot;, accountNo: &quot;001&quot;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h1><h2 id="创建单个文档"><a href="#创建单个文档" class="headerlink" title="创建单个文档"></a>创建单个文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.insertOne(</span><br><span class="line">    &lt;document&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;collection&gt;</code>： 文档集合名</li>
<li><code>&lt;document&gt;</code>： 准备写入数据库的文档<ul>
<li><code>Json</code> 文档格式  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    _id: &quot;account1&quot;,</span><br><span class="line">    name: &quot;alice&quot;,</span><br><span class="line">    balance: 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>writeConcern</code>： 文档定义了本次文档创建操作的安全写级别简单来说，安全写级别用来判断一次数据库写入操作是否成功。安全写级别越高，丢失数据的风险就越低，然而写入操作的延迟也可能更高。如果不提供<code>writeConcern</code> 文档，<code>MongoDB</code> 使用默认的安全写级别</li>
</ul>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.insertOne(</span><br><span class="line">    &#123;</span><br><span class="line">        _id: &quot;account1&quot;,</span><br><span class="line">        name: &quot;alice&quot;,</span><br><span class="line">        balance: 100</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>insertOne</code>、<code>insetMany</code>、<code>insert</code> 会自动创建相应集合</p>
</li>
<li><p><code>_id</code> 字段<strong>不能重复</strong>，省略创建文档中的 <code>_id</code> 字段，会自动生成 <code>_id</code>。</p>
</li>
</ul>
<h2 id="创建多个文档"><a href="#创建多个文档" class="headerlink" title="创建多个文档"></a>创建多个文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.insertMany(</span><br><span class="line">    [&lt;document1&gt;, &lt;document2&gt;, ...],</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;,</span><br><span class="line">        ordered: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ordered</code>: <code>MongoDB</code> 是否按照顺序来写入这些文档。默认为 <code>true</code>。</li>
</ul>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.insertMany(</span><br><span class="line">    [</span><br><span class="line">        &#123;name: &quot;charlie&quot;, balance: 500&#125;,</span><br><span class="line">        &#123;name: &quot;david&quot;, balance: 200&#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在<strong>顺序</strong>写入时，一旦遇到错误，操作便会退出，剩余的文档无论正确与否，都不会被写入。 </p>
<p>在<strong>乱序</strong>写入时，即使某些文档造成了错误，剩余的正确文档仍然会被写入</p>
<h2 id="创建单个或多个文档"><a href="#创建单个或多个文档" class="headerlink" title="创建单个或多个文档"></a>创建单个或多个文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.insert(</span><br><span class="line">    &lt;document or array of documents&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;,</span><br><span class="line">        ordered: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>insert</code> 命令既可以提供单个 <code>document</code> 也可以提供 <code>document</code> 数组, 返回结果不同， 正确返回 <code>WriteReult</code> 对象</p>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.insert(</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;george&quot;,</span><br><span class="line">        balance: 1000</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WriteResult(&#123; &quot;nInserted&quot;: 1 &#125;)</span><br><span class="line">// nInserted: 插入数量</span><br></pre></td></tr></table></figure>

<h2 id="三个命令的区别"><a href="#三个命令的区别" class="headerlink" title="三个命令的区别"></a>三个命令的区别</h2><ul>
<li>返回结果不同</li>
<li><code>insertOne</code> 和 <code>insertMany</code> 命令不支持 <code>db.collection.explain()</code> 命令，<code>insert</code> 命令支持。</li>
</ul>
<h2 id="save"><a href="#save" class="headerlink" title="save"></a>save</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.save(</span><br><span class="line">    &lt;document&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当 <code>db.collection.save()</code> 命令处理一个新文档的时候，会调用 <code>db.collection.insert()</code> 命令</p>
<h1 id="读取文档"><a href="#读取文档" class="headerlink" title="读取文档"></a>读取文档</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.find(&lt;query&gt;, &lt;projection&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;query&gt;</code>: 查询文档</li>
<li><code>&lt;projection&gt;</code>: 定义了对读取结果进行的投射</li>
</ul>
<h2 id="读取全部文档"><a href="#读取全部文档" class="headerlink" title="读取全部文档"></a>读取全部文档</h2><p>既不筛选，也不使用投射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find()</span><br></pre></td></tr></table></figure>

<p>格式友好:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find().pretty()</span><br></pre></td></tr></table></figure>

<h2 id="筛选文档"><a href="#筛选文档" class="headerlink" title="筛选文档"></a>筛选文档</h2><h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;name: &quot;alice&quot;, balance: 100&#125;)</span><br></pre></td></tr></table></figure>
<p>嵌入文档的查询:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;&quot;_id.type&quot;: &quot;savings&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><p>常用的比较操作符包括:</p>
<ul>
<li><code>$eq</code> 匹配字段值相等的文档</li>
<li><code>$ne</code> 匹配字段值不等的文档<ul>
<li><strong>也会筛选出不包含查询字段的文档</strong></li>
</ul>
</li>
<li><code>$gt</code> 匹配字段值大于查询值的文档</li>
<li><code>$gte</code> 匹配字段值大于或等于查询值的文档</li>
<li><code>$le</code> 匹配字段值小于查询值的文档</li>
<li><code>$lte</code> 匹配字段值小于或等于查询值的文档</li>
</ul>
<p>操作命令格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &lt;field&gt;: &#123;$&lt;operator&gt;: &lt;value&gt; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子:</p>
<p>读取 <code>alice</code> 的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123; name: &#123; $eq: &quot;alice&quot; &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>读取余额大于 <code>100</code> 的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123; balance: &#123; $gt: 100 &#125;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$in</code> 匹配字段值与任一查询值相等的文档</li>
<li><code>$nin</code> 匹配字段值与任何查询值都不相等的文档<ul>
<li><strong>也会筛选出不包含查询字段的文档</strong></li>
</ul>
</li>
</ul>
<p>操作命令格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &lt;field&gt;: &#123; $in: [&lt;value1&gt;, &lt;value2&gt;, ...] &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子:</p>
<p>读取 <code>alice</code> 和 <code>charlie</code> 的银行账户文档:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123; name: &#123; $in: [&quot;alice&quot;, &quot;charlie&quot;] &#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><ul>
<li><code>$not</code> 匹配筛选条件不成立的文档<ul>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &lt;field&gt;: &#123; $not: &#123;&lt;operator-expression&gt; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>也会筛选出不包含查询字段的文档</strong></li>
</ul>
</li>
<li><code>$and</code> 匹配筛选条件全部成立的文档<ul>
<li>操作命令格式: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $and: [&#123;&lt;operator-expression1&gt;&#125;, &#123;&lt;operator-expression2&gt;&#125;, ...]&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>$or</code> 匹配筛选条件至少一个成立的文档<ul>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $or: [&#123;&lt;operator-expression1&gt;&#125;, &#123;&lt;operator-expression2&gt;&#125;, ...]&#125;</span><br></pre></td></tr></table></figure></li>
<li>当所有的筛选条件都是 <code>$eq</code> 操作符时，<code>$or</code> 和 <code>$in</code> 效果一样</li>
</ul>
</li>
<li><code>$nor</code> 匹配多个筛选条件全部不成立的文档<ul>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $nor: [&#123;&lt;operator-expression1&gt;&#125;, &#123;&lt;operator-expression2&gt;&#125;, ...]&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>也会筛选出不包含查询字段的文档</strong></li>
</ul>
</li>
</ul>
<p>举个例子：</p>
<p>读取余额不小于 <code>500</code> 的银行账户文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;balance: &#123;$not: &#123;$lt: 500 &#125;&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>读取余额大于 <code>100</code> 且用户姓名排在 <code>fred</code> 之后的银行账户文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123; and: &#123;</span><br><span class="line">        &#123;balance: &#123;$gt: 100&#125;&#125;,</span><br><span class="line">        &#123;name: &#123;$lt: &quot;fred&quot; &#125;&#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当筛选条件应用在不同字段上时，可以省略 <code>$and</code> 操作符, 上面等价于:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;balance: &#123;$gt: 100&#125;&#125;,</span><br><span class="line">    &#123;name: &#123;$lt: &quot;fred&quot; &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当筛选条件应用在同一字段上时，也可以省略 <code>$and</code> 操作符。例如：</p>
<p>查询余额大于 <code>100</code> 并且小于 <code>500</code> 的银行账户:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;balance: &#123;$gt: 100, $lt: 500 &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="字段操作符"><a href="#字段操作符" class="headerlink" title="字段操作符"></a>字段操作符</h3><ul>
<li><code>$exists</code> <ul>
<li>查询包含字段值的文档</li>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; field: &#123; $exists: &lt;boolean&gt; &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>举个例子:<br>读取文档主键 <code>_id.type</code> 存在并且不等于 <code>checking</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;&quot;_id.type&quot;: &#123; $ne: &quot;checking&quot;, $exists: true &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$type</code> <ul>
<li>查询包含字段值类型的文档</li>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; field: &#123; $type: &lt;BSON type&gt; &#125;&#125;</span><br><span class="line">&#123; field: &#123; $type: [&lt;BSON type1&gt;, &lt;BSON type2&gt;, ... ]&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>举个例子:</p>
<p>读取文档主键是字符串的银行账户文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;_id: &#123; $type: &quot;string&quot; &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>读取文档主键是对象主键或者是复合主键的银行账户文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;_id: &#123; $type: [&quot;ObjectId&quot;, &quot;object&quot;] &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>BSON</code> 类型序号作为 <code>$type</code> 操作符的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;_id: &#123; $type: 2 &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="数组操作符"><a href="#数组操作符" class="headerlink" title="数组操作符"></a>数组操作符</h3><ul>
<li><code>$all</code> <ul>
<li>筛选数组中包含所有的查询值的文档</li>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; field: &#123; $all: [&lt;value1&gt;, &lt;value2&gt;, ... ]&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>$elemMatch</code> <ul>
<li>筛选数组中任一一个元素满足查询条件</li>
<li>操作命令格式:  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; field: &#123; $elemMatch: &#123;&lt;query1&gt;, &lt;query2&gt;, ... &#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>举个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;contact: &#123; $elemMatch: &#123; $gt: 100, %lt: 200 &#125;&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>$all</code> 可以 与 <code>$elemMatch</code> 结合使用:<br>读取包含一个在 <code>1000</code> 至 <code>2000</code> 之间和一个在 <code>2000</code> 至 <code>3000</code> 之间的联系电话的银行账户文档:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(</span><br><span class="line">    &#123;contact: &#123; $all: [</span><br><span class="line">        &#123;$elemMatch:&#123;$gt: 1000, $lt: 2000&#125;&#125;,</span><br><span class="line">        &#123;$elemMatch:&#123;$gt: 2000, $lt: 3000&#125;&#125;,</span><br><span class="line">    ]&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><h4 id="regex"><a href="#regex" class="headerlink" title="$regex"></a>$regex</h4><p>正则表达式，操作命令格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &lt;field&gt;: &#123; : /pattern/, : &#x27;&lt;options&gt;&#x27;&#125;&#125;</span><br><span class="line">&#123; &lt;field&gt;: &#123; : /pattern/&lt;options&gt; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>兼容 <code>PCRE v8.41</code> 正则表达式库</p>
<p>在和 <code>$in</code> 操作符一起使用时，只能使用 <code>/pattern/&lt;options&gt;</code> 方式</p>
<p>举个例子:</p>
<p>读取用户姓名以 c 或者 j 开头的银行账户文档:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;name: &#123;$in: [ /^c/, /^j/ ]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>读取用户姓名包含 <code>ALI</code> (不区分大小写)的银行账户文档:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;name: &#123;$regex: /ALI/, $options: &quot;i&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="文档游标"><a href="#文档游标" class="headerlink" title="文档游标"></a>文档游标</h2><p><code>db.collection.find()</code> 返回一个文档集合游标</p>
<p>在不迭代游标的情况下，只列出前 <code>20</code> 个文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">var myCursor = db.accounts.find(); myCursor</span></span><br></pre></td></tr></table></figure>
<p><del>可以使用游标下标直接访问文档集合中的某一个文档</del></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">var myCursor = db.accounts.find(); myCursor[0]</span></span><br></pre></td></tr></table></figure>

<p>遍历完游标中所有的文档之后，或者在 <code>10</code> 分钟之后，游标会自动关闭， 可以使用 <code>noCursorTimeout()</code> 函数来保持游标一直有效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">var myCursor = db.accounts.find().noCursorTimeout()</span></span><br></pre></td></tr></table></figure>
<p>主动关闭游标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">myCursor.close()</span></span><br></pre></td></tr></table></figure>
<h3 id="游标函数"><a href="#游标函数" class="headerlink" title="游标函数"></a>游标函数</h3><ul>
<li>cursor.hasNext()</li>
<li>cursor.next()</li>
<li>cursor.forEach()</li>
<li>cursor.limit()<ul>
<li><code>limit(0)</code> 相当于没有 <code>limit</code></li>
</ul>
</li>
<li>cursor.skip()</li>
<li>cursor.count(<applySKipLimit>)<ul>
<li>默认情况下 <code>applySKipLimit</code> 为 <code>false</code>, 即 <code>count</code> 不会考虑 <code>skip</code> 和 <code>limit</code> 的效果</li>
<li>不提供筛选条件时， <code>count</code> 会从集合的元数据 <code>Metadata</code> 中取得结果，当数据库分布式结构较为复杂时，元数据中的文档数量可能不正确，这时更建议使用<strong>聚合管道</strong>来计算文档数量</li>
</ul>
</li>
<li>cursor.sort(<document>)<ul>
<li><code>document</code> 定义排序要求，<code>1</code> 表示正向排序，<code> -1</code> 表示逆向排序</li>
<li><code>&#123;field: ordering&#125;</code></li>
</ul>
</li>
</ul>
<p><strong>不管命令顺序，执行的顺序永远是 <code>sort &gt; skip &gt; limit</code></strong></p>
<h2 id="文档投影"><a href="#文档投影" class="headerlink" title="文档投影"></a>文档投影</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.find(&lt;query&gt;, &lt;projection&gt;)</span><br></pre></td></tr></table></figure>
<p>不使用投影时， <code>find</code> 返回符合条件的完整文档，而使用投影可以有选择性的返回文档中的部分字段</p>
<p><code>projection</code> 格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; filed: inclusion &#125;</span><br></pre></td></tr></table></figure>
<p><code>1</code> 表示返回字段，<code>0</code> 表示不返回字段， <strong>没有设置主键默认会返回</strong></p>
<p>举个例子:</p>
<p>只返回银行账户的用户姓名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;&#125;, &#123;name: 1&#125;)</span><br></pre></td></tr></table></figure>

<p>只返回银行账户的用户姓名(不包含主键)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;&#125;, &#123;name: 1, _id: 0&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>除了文档主键外，不可以在投影文档上混合使用包含和不包含这两种投影操作</strong></p>
<p>🙅</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;&#125;, &#123;name: 1， balance: 0&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数组字段上使用投影"><a href="#数组字段上使用投影" class="headerlink" title="数组字段上使用投影"></a>数组字段上使用投影</h3><h4 id="slice"><a href="#slice" class="headerlink" title="$slice"></a><code>$slice</code></h4><p><code>$slice</code> 操作符可以返回数组字段中的部分元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$slice : n| -n | [i, j]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>n</code>: 数组前 <code>n</code> 个元素</li>
<li><code>-n</code>: 数组后 <code>n</code> 个元素</li>
<li><code>[i, j]</code>: 跳过 <code>i</code> 个元素,返回接下来 <code>j</code> 个元素</li>
</ul>
<p>只返回 <code>contact</code> 数组中的第一个元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;&#125;, &#123;_id : 0, name: 1, contact: &#123;$slice: 1&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="eleeMatch"><a href="#eleeMatch" class="headerlink" title="$eleeMatch &amp; $"></a><code>$eleeMatch</code> &amp; <code>$</code></h4><p><code>$eleeMatch</code> 和 <code>$</code>操作符返回数组中满足筛选条件的第一个元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;&#125;, &#123;_id : 0, name: 1, contact: &#123;$elemMatch: &#123;$gt: &quot;Alabama&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>与下等同: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.find(&#123;contact: &#123; $gt: &quot;Alabama&quot;&#125;&#125;, &#123;_id : 0, name: 1, contact: &quot;contact.$: 1&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.update(&lt;query&gt;, &lt;update&gt;, &lt;options&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;query&gt;</code> 筛选条件</li>
<li><code>&lt;update&gt;</code> 更新文档</li>
<li><code>&lt;options&gt;</code> 设置参数</li>
</ul>
<h2 id="更新整篇文档"><a href="#更新整篇文档" class="headerlink" title="更新整篇文档"></a>更新整篇文档</h2><p>如果 <code>&lt;update&gt;</code> 文档不包含任何更新操作符，<code>db.collection.update()</code> 将会使用 <code>&lt;update&gt;</code>文档直接替换集合中符合 <code>&lt;query&gt;</code> 文档筛选条件的文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.account.update(&#123;name:&quot;alice&quot; &#125;, &#123;name : &quot;alice&quot;, &quot;balance&quot;:123&#125;)</span><br></pre></td></tr></table></figure>

<p>注意问题: </p>
<ul>
<li>文档主键 <code>_id</code> 是不可以更改的</li>
<li>只有<strong>第一篇</strong>符合 <code>&lt;query&gt;</code> 文档符合筛选条件的文档会被更新</li>
</ul>
<h2 id="更新特定字段"><a href="#更新特定字段" class="headerlink" title="更新特定字段"></a>更新特定字段</h2><p>更新文档特定字段，需要使用到文档更新操作符，如下:</p>
<ul>
<li><code>$set</code> 更新或新增字段</li>
<li><code>$unset</code> 删除字段</li>
<li><code>$rename</code> 重命名</li>
<li><code>$inc</code> 加减字段值</li>
<li><code>$mul</code> 相乘字段值</li>
<li><code>$min</code> 比较减小字段值</li>
<li><code>$max</code> 比较增大字段值</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $set: &#123; &lt;filed1&gt;: &lt;value1&gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;jack&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: </span><br><span class="line">        &#123;</span><br><span class="line">            balance: 3000,</span><br><span class="line">            info: &#123;</span><br><span class="line">                dateOpened: new Date(&quot;2016-05-18T16:00:00Z&quot;),</span><br><span class="line">                branch: &quot;branch1&quot; </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="更新或新增内嵌文档的字段"><a href="#更新或新增内嵌文档的字段" class="headerlink" title="更新或新增内嵌文档的字段"></a>更新或新增内嵌文档的字段</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;jack&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;info.dateOpened&quot;: new Date(&quot;2017-01-01T16:00:00Z&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="更新或新增数组字段"><a href="#更新或新增数组字段" class="headerlink" title="更新或新增数组字段"></a>更新或新增数组字段</h4><p>在 <code>$set</code> 中使用<strong>数组名加下标</strong>，如果向现有数组字段范围以外的位置添加新值，数组字段的长度会被扩大，未被赋值的数组成员将被设置为 <code>null</code></p>
<p>举个例子 <code>jack</code>的  <code>contact</code> 数组中默认有 <code>3</code> 个元素: </p>
<ul>
<li><p>更新  <code>jack</code>的 <code>contact</code> 数组中第一个元素</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;jack&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;contact.0&quot;: &quot;666666&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>更新 <code>jack</code>的 <code>contact</code> 数组中第四元素</p>
<p>  在 <code>$set</code> 中使用数组名加下标 <code>3</code>， 默认只有 <code>3</code> 个，这个操作会在数组后边新增一个元素.</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;jack&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;contact.3&quot;: &quot;77777&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新  <code>jack</code>的 <code>contact</code> 数组中第六个元素</p>
<p>  在 <code>$set </code>中使用数组名加下标 <code>5</code>， 现在只有 <code>4</code> 个，这个操作会在数组后边新增两个元素，第五个元素为 <code>null</code> 值，第六个为新增值</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;jack&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;contact.5&quot;: &quot;99999&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="unset"><a href="#unset" class="headerlink" title="$unset"></a>$unset</h3><p>删除字段, 传入任何值都一样，默认设置为 <code>&quot;&quot;</code>, 格式如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123; $unset: &#123;field1: &quot;&quot;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>例如删除 <code>jack</code> 的银行账户余额和开户地点:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name:&quot;jack&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $unset:</span><br><span class="line">        &#123;</span><br><span class="line">            balance: &quot;&quot;,</span><br><span class="line">            &quot;info.branch&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除内嵌文档的字段<ul>
<li>同更新内嵌文档字段方式</li>
</ul>
</li>
<li>删除数组内的字段<ul>
<li>同更新内嵌文档字段方式。删除数组中元素成功时，这个元素不会被删除，只会被赋以 <code>null</code> 值，而<strong>数组的长度不会改变</strong>。</li>
</ul>
</li>
</ul>
<p><strong>如果 <code>$unset</code> 命令中的字段不存在，那么文档内容将保持不变</strong></p>
<h3 id="rename"><a href="#rename" class="headerlink" title="$rename"></a>$rename</h3><p>重命名文档字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $rename: &#123;&lt;field1&gt;: &lt;newName1&gt;, &lt;field2&gt;:&lt;newName2&gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>$rename</code> 命令中的字段不存在，那么文档内容将保持不变</li>
<li>如果新的字段名已经存在，那么原有的这个字段会被覆盖</li>
</ul>
<p><strong>当 <code>$rename</code> 命令中的新字段存在时，<code>$rename</code> 命令会先 <code>$unset</code> 旧字段，然后再 <code>$set</code> 新字段</strong></p>
<ul>
<li>重命名内嵌文档的字段<ul>
<li>普通重命名字段名<ul>
<li>同更新内嵌文档字段方式</li>
</ul>
</li>
<li>更新内嵌文档中字段的位置  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;karen&quot; &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        $rename:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;info.branch&quot;: &quot;branch&quot;,</span><br><span class="line">            &quot;balance&quot;: &quot;info.balance&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>$rename 命令中的旧字段和新字段都不可以指向数组元素</strong></p>
<h3 id="inc-mul"><a href="#inc-mul" class="headerlink" title="$inc &amp; $mul"></a>$inc &amp; $mul</h3><p>更新字段值, <code>$inc</code> 加减字段值(正负数)，<code>$mul</code> 相乘字段值，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $inc: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123; $mul: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子 <code>david</code> 账户的 <code>notYetExist</code> 值加  <code>10</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;david&quot;&#125;，</span><br><span class="line">    &#123;</span><br><span class="line">        $inc:</span><br><span class="line">        &#123;</span><br><span class="line">            notYetExist: 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>使用注意</strong>: </p>
<ul>
<li><code>$inc</code>、 <code>$mul</code> 只能应用在<strong>数字</strong>字段上</li>
<li>当更新字段不存在时<ul>
<li><code>$inc</code> 会创建字段，并且将字段值设定为命令中的<strong>增减值</strong></li>
<li><code>$mul</code> 会创建字段，但是把字段值设为 <code>0</code></li>
</ul>
</li>
</ul>
<h3 id="min-max"><a href="#min-max" class="headerlink" title="$min &amp; $max"></a>$min &amp; $max</h3><p>比较后更新值，<code>$min</code> 比较后保留较小字段值 <code>$max</code> 比较后保留较大字段值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $min: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123; $max: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子:</p>
<p>会将 <code>info.balance</code> 的当前值同 <code>5000</code> 比较，保留较小的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;david&quot;&#125;，</span><br><span class="line">    &#123;</span><br><span class="line">        $min:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;info.balance&quot;: 5000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>使用注意</strong>: </p>
<ul>
<li>可以在任何可以比较大小的字段上使用</li>
<li>当更新字段不存在时<ul>
<li><code>$min</code> 和 <code>$max</code> <strong>都会创建字段</strong>，并且将字段值设定为命令中的<strong>更新值</strong>。</li>
</ul>
</li>
<li>被更新的字段类型和更新值类型不一致<ul>
<li><code>$min</code> 和 <code>$max</code>会按照 <code>BSON</code> 数据类型排序规则进行比较。<blockquote>
<p>不同 <code>BSON</code> 类型的值时，<code>MongoDB</code> 使用以下<strong>从低到高</strong>的比较顺序：<br>  <br>  MinKey (internal type)<br>  Null<br>  Numbers (ints, longs, doubles, decimals)<br>  Symbol, String<br>  Object<br>  Array<br>  BinData<br>  ObjectId<br>  Boolean<br>  Date<br>  Timestamp<br>  Regular Expression<br>  MaxKey (internal type)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="更新数组操作符"><a href="#更新数组操作符" class="headerlink" title="更新数组操作符"></a>更新数组操作符</h2><ul>
<li><code>$addToSet</code> 向数组中增添元素</li>
<li><code>$pop </code>从数组中移除元素</li>
<li><code>$pull</code> 从数组中有选择性的移出元素</li>
<li><code>$pullAll</code> 从数组中有选择性的移出元素</li>
<li><code>$push</code> 向数组中增添元素</li>
</ul>
<p><strong>以上字段只能用到数组字段上，否则会收到错误</strong></p>
<h3 id="addToSet"><a href="#addToSet" class="headerlink" title="$addToSet"></a>$addToSet</h3><p><code>$addToSet</code> 向数组中增添元素:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $addToSet: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果要插入的值不存在数组字段中<ul>
<li>新增字段会被添加到原文档中</li>
</ul>
</li>
<li>如果要插入的值已经存在数组字段中<ul>
<li><code>$addToSet</code> 不会再添加重复值。 <strong>使用 <code>$addToSet</code>插入数组和文档时，插入值中的字段顺序和已有值重复时，才被算着重复值被忽略</strong></li>
</ul>
</li>
</ul>
<p><code>$addToSet</code> 会将数组插入被更新的数组字段中，成为内嵌数组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;karen&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $addToSet: &#123;contact: [&quot;contact1&quot;, &quot;contact2&quot;]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果想要将多个元素直接添加到数组字段中，则需要使用 <code>$each</code> 操作符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;karen&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $addToSet: &#123;contact: &#123; $each:   [&quot;contact1&quot;, &quot;contact2&quot;] &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="$pop"></a>$pop</h3><p><code>$pop</code> 从数组字段中删除元素, <strong>只能删除数组中的第一个(-1)和最后一个元素(1)</strong>, 删除掉数组中最后一个元素后，会留下<strong>空数组</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $pop: &#123; &lt;field&gt;: &lt; -1 | 1 &gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>karen</code> 的账户文档中删除最后一个联系方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;karen&quot;&#125;,</span><br><span class="line">    &#123; $pop: &#123; contact: 1 &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="pull"><a href="#pull" class="headerlink" title="$pull"></a>$pull</h3><p><code>$pull</code> 从数组中删除符合值或者条件的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $pull: &#123; &lt;field1&gt;: &lt;value|condition&gt;, ... &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>karen</code>的联系方式中删除包含 <code>hi</code>字母的元素:</p>
<p>针对数组<strong>顶级</strong>元素的筛选无需使用 <code>$elemMatch</code>, 下面是错误的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123; name: &quot;karen&quot;&#125;,</span><br><span class="line">    &#123; $pull: &#123; contact: &#123; $elemMatch: &#123;$regex: /hi/ &#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>应该是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123; name: &quot;karen&quot;&#125;,</span><br><span class="line">    &#123; $pull: &#123; contact: &#123; $regex: /hi/ &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>要删除数组元素是<strong>内嵌数组</strong>，可以使用 <code>$elemMatch</code> 对内嵌数组进行筛选:</p>
<p>从 <code>karen</code>的联系方式中删除包含 <code>22222222</code>的内嵌数组元素:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123; name: &quot;karen&quot;&#125;,</span><br><span class="line">    &#123; $pull: &#123; contact: &#123; $elemMatch: &#123; $eq: &quot;22222222&quot; &#125;&#125;&#125;&#125;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="pullAll"><a href="#pullAll" class="headerlink" title="$pullAll"></a>$pullAll</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $pullAll: &#123; &lt;field1&gt;: [&lt;value1, value2&gt;, ...], ... &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>其实</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $pullAll: &#123; &lt;field1&gt;: [&lt;value1, value2&gt;] &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $pull: &#123; &lt;field1&gt;: &#123;$in: [&lt;value1, value2&gt;] &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果要删除的元素是一个数组，数组的元素的值和排列顺序都必须和要被删除的数组完全一样</strong>。</p>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $pullAll: &#123;contact: [[&quot;333333&quot;, &quot;222222&quot;]]&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果删除的元素是一个<strong>文档</strong></p>
<ul>
<li><code>$pullAll</code> 命令只会删除字段和排列顺序都<strong>完全匹配</strong>的文档元素</li>
<li><code>$pull</code> 命令会删除匹配的文档元素，模糊度更高(<strong>形成包含关系，或者能通过字段名找到</strong>)。</li>
</ul>
<p>现有文档格式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">db.accounts.find()</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    _id: ObjectId(&quot;64ef4c42cb559b034e8de6a0&quot;),</span><br><span class="line">    contact: [</span><br><span class="line">      &#x27;1&#x27;,</span><br><span class="line">      [ &#x27;2&#x27;, &#x27;3&#x27; ],</span><br><span class="line">      &#123;</span><br><span class="line">        primaryEmail: &#x27;xxx@gmail.com&#x27;,</span><br><span class="line">        secondaryEmail: &#x27;yyy@gmail.com&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    name: &#x27;alice&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>pullAll</code> 不完全匹配无法删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">db.accounts.update( &#123;name:<span class="string">&quot;alice&quot;</span>&#125;, &#123;<span class="variable">$pullAll</span>: &#123;contact:[&#123;<span class="string">&quot;scondaryEmail&quot;</span>:<span class="string">&quot;yyy@gmail.com&quot;</span>&#125;]&#125;&#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">  acknowledged: true,</span><br><span class="line">  insertedId: null,</span><br><span class="line">  matchedCount: 0,</span><br><span class="line">  modifiedCount: 0,</span><br><span class="line">  upsertedCount: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pull</code> 不完全匹配可以删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">db.account.update( &#123;name:<span class="string">&quot;alice&quot;</span>&#125;, &#123;<span class="variable">$pull</span>: &#123;contact : &#123;<span class="string">&quot;secondaryEmail&quot;</span> : <span class="string">&quot;yyy@gmail.com&quot;</span>&#125;&#125;&#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">  acknowledged: true,</span><br><span class="line">  insertedId: null,</span><br><span class="line">  matchedCount: 0,</span><br><span class="line">  modifiedCount: 0,</span><br><span class="line">  upsertedCount: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="push"><a href="#push" class="headerlink" title="$push"></a>$push</h3><p><code>$push </code>向数组中添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; $push: &#123; &lt;field1&gt; : &lt;value1&gt;, ...&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>$push</code> 和 <code>addTosSet</code>命令相似地方:</p>
<ul>
<li><p>如果要插入的值不存在数组字段中</p>
<ul>
<li>新增字段会被添加到原文档中</li>
</ul>
</li>
<li><p>可以搭配 <code>$each</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">     &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">     &#123; $push: &#123;</span><br><span class="line">         newArray: &#123;</span><br><span class="line">             $each:[2, 3, 4]</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;&#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p><code>$push</code> 比 <code>addTosSet</code>增强地方:</p>
</li>
<li><p>搭配 <code>$each</code> 实现更复杂的操作</p>
<ul>
<li><p>使用 <code>$position</code> 操作符将元素插入到数组的指定位置, <code>$position</code> 的值 <code>0</code> 表示 从数组第一个位置开始插入，<code>-2</code> 表示从数组最后一个元素往前走 <code>2</code> 个开始插入。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[&quot;pos1&quot;, &quot;pos2&quot;],</span><br><span class="line">            $position: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>$sort</code> 排序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[&quot;sort1&quot;],</span><br><span class="line">            $sort: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>如果插入的元素是内嵌文档，也可以根据内嵌文档的字段值排序</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[&#123;key: &quot;sort&quot;, value: 100&#125;, &#123;key: &quot;sort1&quot;, value: 200&#125;],</span><br><span class="line">            $sort: &#123; value: -1 &#125; // 只排序插入的内嵌文档</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>不想插入，只想对数组中的字段进行排序:</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[],</span><br><span class="line">            $sort: -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>$slice</code> 截取部分数组</p>
<p>  插入 <code>slice1</code> 元素后，保留从后往前数 <code>8</code> 个元素:</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[&quot;slice1&quot;],</span><br><span class="line">            $slice: -8</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>不想插入，只想截取部分数组:</p>
<p>  保留数组中的前 <code>6</code> 个元素:</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[],</span><br><span class="line">            $slice: 6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><code>$position</code>, <code>$sort</code>, <code>$slice</code> 可以一起使用, 他们的执行顺序是 <code>$position &gt; $sort &gt;  $slice</code>。<strong>写在命令中的操作顺序并不重要，并不会影响命令的执行顺序</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123; $push: &#123;</span><br><span class="line">        newArray: &#123;</span><br><span class="line">            $each:[&quot;push1&quot;, &quot;push2&quot;],</span><br><span class="line">            $position: 2,</span><br><span class="line">            $sort: -1,</span><br><span class="line">            $slice: 5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="占位符"><a href="#占位符" class="headerlink" title="$ 占位符"></a><code>$</code> 占位符</h3><p><code>$</code> 是数组中第一个符合筛选条件的数组元素的占位符, 搭配更新操作符使用，可以对满足筛选条件的数组元素进行更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">    &#123; &lt;array&gt;: &lt;query selector&gt; &#125;,</span><br><span class="line">    &#123; &lt;update operator&gt; : &#123; &quot;&lt;array&gt;.$&quot;: value &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>举个例子，将 <code>lawrence</code> 中 <code>newArray</code> 中的 <code>pos2</code> 替换为 <code>updated</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;lawrence&quot;,</span><br><span class="line">        newArray: &quot;pos2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: &#123;</span><br><span class="line">            &quot;newArray.$&quot;: &quot;updated&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="占位符-1"><a href="#占位符-1" class="headerlink" title="$[] 占位符"></a><code>$[]</code> 占位符</h3><p><code>$[]</code> 指代数组中的所有元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &lt;update operator&gt; : &#123; &quot;&lt;array&gt;.$[]&quot;: value &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，将 <code>lawrence</code> 账户中的 <code>contact</code>数组中的第一个内嵌数组，全部替换为 <code>999999</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;lawrence&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: &#123;</span><br><span class="line">            &quot;contact.0.$[]&quot;: 999999</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><h3 id="multi"><a href="#multi" class="headerlink" title="multi"></a>multi</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; multi: &lt;boolean&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，即使筛选条件对应了多篇文档，<code>update</code> 命令仍然只会更新<strong>一篇</strong>文档</p>
<p>设置 <code>multi</code> 为 <code>true</code> 选项可以更新所有符合筛选条件的文档, 注意，<code>MongoDB</code> 只能保证<strong>单个</strong>文档操作的原子性，不能保证<strong>多个</strong>文档操作的原子性。多个文档操作时的原子性需要 <code>MongoDB 4.0</code> 版本引入的事务功能进行操作。</p>
<p>举个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: &#123;</span><br><span class="line">            currency: &quot;USD&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; multi: true&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="upsert"><a href="#upsert" class="headerlink" title="upsert"></a>upsert</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; upsert: &lt;boolean&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>更新或者创建文档</p>
<p>在默认情况下，如果 <code>update</code> 命令中的筛选条件没有匹配任何文档，则不会进行任何操作</p>
<p>将 <code>upsert</code> 设置为<code> true</code>， 如果 <code>update</code> 命令中的筛选条件没有匹配任何文档，则会创建新文档</p>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.update(</span><br><span class="line">    &#123;name: &quot;maggie&quot;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $set: &#123;</span><br><span class="line">            balance: 700</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; upsert: true&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>如果筛选条件中能推断出确定的字段，新创建的文档会包含筛选条件设计的字段</strong></p>
<h2 id="save-1"><a href="#save-1" class="headerlink" title="save"></a>save</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.save(&lt;document&gt;)</span><br></pre></td></tr></table></figure>

<p>如果 <code>document</code> 文档中包含 <code>_id</code> 字段， <code>save()</code> 命令将会调用 <code>db.collection.update()</code> 命令<code>(upsert: true)</code>, <code>_id</code> 值存在就更新，不存在就创建新文档。</p>
<p>举个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.save(</span><br><span class="line">    &#123; _id : &quot;account1&quot;, name: &quot;alice&quot;, balance: 100 &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul>
<li>删除集合</li>
<li>删除特定文档</li>
</ul>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.remove(&lt;query&gt;, &lt;options&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&lt;query&gt;</code> 筛选条件</p>
</li>
<li><p><code>&lt;options&gt;</code> 设置参数</p>
</li>
<li><p>在默认情况下，<code>remove</code> 命令会删除<strong>所有</strong>复合筛选条件的文档</p>
</li>
<li><p>如果只想删除复合筛选条件的<strong>第一篇</strong>文档，可以使用 <code>justOne</code> 选项</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.remove(</span><br><span class="line">    &#123;balance: &#123; $lt: 100&#125; &#125;,</span><br><span class="line">    &#123;justOne: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除集合内的<strong>所有</strong>文档</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>举个例子, 删除 <code>balance</code> 等 <code>50</code> 的文档:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accounts.remove(</span><br><span class="line">    &#123;balance: 50 &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p><code>remove</code> 只会删除集合内所有的文档，但不会删除集合</p>
<p><code>drop</code> 命令可以删除整个集合，包括集合中的所有文档，以及集合的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.drop(&#123; writeConcern: &lt;document&gt; &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>writeConcern</code> 定义了本次集合删除操作的安全写级别</li>
</ul>
<p>举个例子:</p>
<pre><code class="shell">db.accounts.drop()
</code></pre>
<blockquote>
<p>如果集合中的文档数量较多，使用 <code>remove</code> 命令删除所有的文档效率不高，这种情况下推荐，使用 <code>drop</code> 命令删除集合，然后再创建空集合并创建索引。</p>
</blockquote>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb 入门-索引</title>
    <url>/2023/08/26/mongodb/mongodb-%E5%85%A5%E9%97%A8-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>对文档部分内容进行排序的数据结构</li>
<li>加快文档查询和文档排序的速度</li>
<li>复合键索引只能支持前缀子查询</li>
</ul>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.createIndex(&lt;keys&gt;, &lt;options&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;keys&gt;</code> 文档指定了创建索引的字段</li>
<li><code>&lt;options&gt;</code> 创建索引的参数和设定索引的特性</li>
</ul>
<h4 id="创建一个单键索引"><a href="#创建一个单键索引" class="headerlink" title="创建一个单键索引"></a>创建一个单键索引</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;name: 1&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="创建一个复合键索引"><a href="#创建一个复合键索引" class="headerlink" title="创建一个复合键索引"></a>创建一个复合键索引</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;name: 1, balance: -1&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="创建一个多键索引，创建在数组字段上-数组字段中的每一个元素都会在多键索引中创建一个键"><a href="#创建一个多键索引，创建在数组字段上-数组字段中的每一个元素都会在多键索引中创建一个键" class="headerlink" title="创建一个多键索引，创建在数组字段上, 数组字段中的每一个元素都会在多键索引中创建一个键"></a>创建一个多键索引，创建在数组字段上, 数组字段中的每一个元素都会在多键索引中创建一个键</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;currency: 1&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="列出集合中的索引"><a href="#列出集合中的索引" class="headerlink" title="列出集合中的索引"></a>列出集合中的索引</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.getIndexes()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>如果需要更改某些字段上已经创建的索引必须首先删除原有索引，再重新创建新索引，否则新索引不会包含原有字段</p>
<h4 id="使用索引名字删除"><a href="#使用索引名字删除" class="headerlink" title="使用索引名字删除"></a>使用索引名字删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.dropIndex(&quot;name_1&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="使用索引定义删除"><a href="#使用索引定义删除" class="headerlink" title="使用索引定义删除"></a>使用索引定义删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.dropIndex( &#123; name: 1, balance: -1 &#125;)</span><br></pre></td></tr></table></figure>


<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul>
<li>单键索引</li>
<li>复合键索引</li>
<li>多键索引</li>
</ul>
<h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a>索引特性</h2><h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;balance:1&#125;,&#123;unique:true&#125;)</span><br></pre></td></tr></table></figure>

<p>如果已有文档中的某个字段出现了重复性，就不可以在这个字段上创建唯一性索引</p>
<p>如果新增的文档不包含唯一性索引字段，只有第一篇缺失该字段的文档可以被写入数据库，索引中该文档的键值被默认为null</p>
<h3 id="稀疏性"><a href="#稀疏性" class="headerlink" title="稀疏性"></a>稀疏性</h3><p>只将包含索引字段的文档加入到索引中(即使索引键字段为null)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;balance:1&#125;, &#123; sparse:true&#125;)</span><br></pre></td></tr></table></figure>
<p>如果同一个索引既具有唯一性，又具有稀疏性，就可以保存多篇缺失索引键值的文档了 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;balance:1&#125;, &#123; sparse:true, unique:true&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复合键索引也可以具有稀疏性，在这种情况下，只有在缺失复合键所包含的所有字段的情况下，文档才不会加入到索引中</p>
<h3 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.createIndex(&#123;lastAccess:1&#125;,&#123;expireAfterSeconds:20&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>复合键索引不具有生存时间特性</strong>，当索引键是包含日期元素的数组字段时，数组中<strong>最小</strong>的的日期将被用来计算文档是否过期。数据库使用一个后台线程来监测和删除过期文档，删除操作可能有一定的延迟。</p>
<h2 id="查询分析"><a href="#查询分析" class="headerlink" title="查询分析"></a>查询分析</h2><h3 id="检视索引的效果-explain"><a href="#检视索引的效果-explain" class="headerlink" title="检视索引的效果 explain()"></a>检视索引的效果 <code>explain()</code></h3><ul>
<li><p>命令操作格式:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.explain().&lt;method(...)&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>可以使用 <code>explain()</code> 进行分析的命令包括 <code>aggregate()</code>，<code>count()</code>，<code>distinct()</code>，<code>find()</code>，<code>group()</code>，<code>remove()</code>，<code>update()</code></p>
</li>
<li><p><code>explain()</code>返回结果中包含的 <code>winningPlan</code>字段表示数据库的查询方法</p>
<ul>
<li><code>stage</code><ul>
<li><code>COLLSCAN</code> 完整查询整个集合</li>
<li><code>FETCH</code> <code>IXSCAN</code> 通过索引查询，返回完整文档<br>  -<code> PROJECTION_COVERED</code>  <code>IXSCAN</code>, 直接使用索引存在的字段，无序完整文档，没有 <code>FETCH</code> 阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>没有 <code>IXSCAN</code> 阶段，都耗费资源</p>
<p>举个例子，<code>explain</code> 排序:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.accountWithIndex.explain().find().sort(&#123;name:1, balance: -1&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h2><ul>
<li>如何创建一个合适的索引</li>
<li>索引对数据库写入操作的影响</li>
</ul>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O 多路复用</title>
    <url>/2023/08/17/network/I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p><code>select</code> 实现多路复用的方式是，将已连接的 <code>socket</code> 都放到一个文件描述符集合，然后调用 <code>select</code>函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 <code>socket</code> 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 <code>socket</code>，然后再对其处理。</p>
<p>所以，对于 <code>select</code> 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<h2 id="select-函数原型"><a href="#select-函数原型" class="headerlink" title="select 函数原型"></a>select 函数原型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> errorfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值 <ul>
<li>若有就绪描述符则为其数目，若超时则为 <code>0</code>，若出错则为 <code>-1</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>maxfd</code>: 待测试的描述符基数，它的值是待测试的最大描述符加 <code>1</code></li>
<li><code>readfds</code>：读描述符集合</li>
<li><code>writefds</code>：写描述符集合</li>
<li><code>errorfds</code>：异常描述符集合</li>
<li><code>timeout</code>: 超时设置</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="操作描述集合"><a href="#操作描述集合" class="headerlink" title="操作描述集合"></a>操作描述集合</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;　　　　　　</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;　　</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;　　　</span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FD_ZERO</code> 清空描述符集合；</li>
<li><code>FD_SET</code> 向描述符集合增加 <code>fd</code>；</li>
<li><code>FD_CLR</code> 向描述符集合删除 <code>fd</code>；</li>
<li><code>FD_ISSET</code> 判断描述符集合中的 <code>fd</code> 是否有响应；</li>
</ul>
<h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><p><code>timeval</code> 结构体时间: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="type">long</span>   tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="type">long</span>   tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后一个参数,可以设置 <code>3</code> 种值:</p>
<ul>
<li>设置成空 <code>(NULL)</code>，表示如果没有 <code>I/O</code> 事件发生，则 <code>select</code> 一直等待下去</li>
<li>设置一个非零的值，等待超时时间阻塞返回</li>
<li><code>tv_sec</code> 和 <code>tv_usec</code> 都设置成 <code>0</code>，表示不等待，检测完毕立即返回</li>
</ul>
<h2 id="使用-🌰"><a href="#使用-🌰" class="headerlink" title="使用 🌰"></a>使用 🌰</h2><p>在使用 <code>select</code> 时, 两个注意点:</p>
<ul>
<li><strong>描述符基数是当前最大描述符 +1；</strong></li>
<li><strong>每次 <code>select</code> 调用完成之后，要重置待测试集合。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> socket_fd = ...;</span><br><span class="line">fd_set ready_fds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   FD_ZERO(&amp;read_fds);</span><br><span class="line">   FD_SET(socket_fd, &amp;read_fds);</span><br><span class="line">   <span class="type">int</span> rc = select(socket_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(socket_fd, &amp;read_fds)) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**<code>select</code> 有一个缺点，那就是所支持的文件描述符的个数是有限的。在 <code>Linux</code> 系统中，<code>select</code> 的默认最大值为 <code>1024</code>**。</p>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a><code>poll</code></h1><p><code>poll</code> 可以突破 <code>select</code> 文件描述符的个数限制， 函数原型如下: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值<ul>
<li>若有就绪描述符则为其数目，若超时则为 <code>0</code>，若出错则为 <code>-1</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>fds</code>: <code>pollfd</code>数组</li>
<li><code>nfds</code>: 描述 <code>fds</code>数组的大小</li>
<li><code>timeout</code>: 超时设置, 单位 <code>ms</code></li>
</ul>
</li>
</ul>
<h2 id="pollfd数组"><a href="#pollfd数组" class="headerlink" title="pollfd数组"></a><code>pollfd</code>数组</h2><p><code>pollfd</code> 结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    fd;       <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span>  events;   <span class="comment">/* events to look for */</span></span><br><span class="line">    <span class="type">short</span>  revents;  <span class="comment">/* events returned */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fd</code>: 文件描述</li>
<li><code>events</code>: 待检测的事件类型</li>
<li><code>revents</code>:  响应的事件类型</li>
</ul>
<p><code>events</code> 类型的事件可以分为三大类。</p>
<p>第一类是可读事件，有以下几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN          0x0001          <span class="comment">/* any readable data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI         0x0002          <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM      0x0040          <span class="comment">/* non-OOB/URG data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND      0x0080          <span class="comment">/* OOB/Urgent readable data */</span></span></span><br></pre></td></tr></table></figure>
<p>我们一般使用 <code>POLLIN</code>, 系统内核通知套接字缓冲区已准备好，通过 <code>read</code> 函数执行读操作不会被阻塞。</p>
<p>第二类是可写事件，有以下几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT         0x0004          <span class="comment">/* file descriptor is writeable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM      POLLOUT         <span class="comment">/* no write type differentiation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND      0x0100          <span class="comment">/* OOB/Urgent data can be written */</span></span></span><br></pre></td></tr></table></figure>
<p>我们一般使用 <code>POLLOUT</code>, 系统内核通知套接字缓冲区已准备好，通过 <code>write</code> 函数执行写操作不会被阻塞。</p>
<p>还有另一大类是错误事件，没有办法通过 <code>poll</code> 向系统内核递交检测请求，只能通过 <code>returned events</code>来加以检测:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR    0x0008    <span class="comment">/* 一些错误发送 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP    0x0010    <span class="comment">/* 描述符挂起 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL   0x0020    <span class="comment">/* 请求的事件无效 */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>不想对某个 <code>pollfd</code> 结构进行事件检测</strong>，可以把它对应的 <code>pollfd</code> 结构的 <code>fd</code> 成员设置成一个<strong>负值</strong>。这样，<code>poll</code> 函数将忽略这样的 <code>events</code> 事件，检测完成以后，所对应的<code>returned events</code>的成员值也将设置为 <code>0</code>。</p>
<h2 id="超时设置-1"><a href="#超时设置-1" class="headerlink" title="超时设置"></a>超时设置</h2><ul>
<li><code>&lt; 0</code>，表示如果没有 <code>I/O</code> 事件发生，则 <code>poll</code> 一直等待下去</li>
<li><code>&gt; 0</code>，等待超时时间阻塞返回</li>
<li><code>= 0</code>，表示不等待，检测完毕立即返回</li>
</ul>
<h2 id="使用-🌰-1"><a href="#使用-🌰-1" class="headerlink" title="使用 🌰"></a>使用 🌰</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SIZE 128</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, connected_fd;</span><br><span class="line">    <span class="type">int</span> ready_number;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"> </span><br><span class="line">    listen_fd = tcp_server_listen(SERV_PORT);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化 pollfd 数组，这个数组的第一个元素是 listen_fd，其余的用来记录将要连接的 connect_fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">event_set</span>[<span class="title">INIT_SIZE</span>];</span></span><br><span class="line">    event_set[<span class="number">0</span>].fd = listen_fd;</span><br><span class="line">    event_set[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用 -1 表示这个数组位置还没有被占用</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; INIT_SIZE; i++) &#123;</span><br><span class="line">        event_set[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ready_number = poll(event_set, INIT_SIZE, <span class="number">-1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;poll failed &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (event_set[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">            <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">            connected_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *) &amp;client_addr, &amp;client_len);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 找到一个可以记录该连接套接字的位置</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; INIT_SIZE; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event_set[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    event_set[i].fd = connected_fd;</span><br><span class="line">                    event_set[i].events = POLLRDNORM;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i == INIT_SIZE) &#123;</span><br><span class="line">                error(<span class="number">1</span>, errno, <span class="string">&quot;can not hold so many clients&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (--ready_number &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; INIT_SIZE; i++) &#123;</span><br><span class="line">            <span class="type">int</span> socket_fd;</span><br><span class="line">            <span class="keyword">if</span> ((socket_fd = event_set[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (event_set[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = read(socket_fd, buf, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (write(socket_fd, buf, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        error(<span class="number">1</span>, errno, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span> || errno == ECONNRESET) &#123;</span><br><span class="line">                    close(socket_fd);</span><br><span class="line">                    event_set[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (--ready_number &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>MTU与MSS的奥秘</title>
    <url>/2024/03/18/network/MTU%E4%B8%8EMSS%E7%9A%84%E5%A5%A5%E7%A7%98/</url>
    <content><![CDATA[<h1 id="最大传输单元（Maximum-Transmission-Unit-MTU）"><a href="#最大传输单元（Maximum-Transmission-Unit-MTU）" class="headerlink" title="最大传输单元（Maximum Transmission Unit, MTU）"></a>最大传输单元（Maximum Transmission Unit, MTU）</h1><p>数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（<code>Maximum Transmission Unit, MTU</code>）」</p>
<span id="more"></span>
<p>不同的数据链路层的 <code>MTU</code> 是不同的。通过 <code>netstat -i</code> 可以查看网卡的 <code>MTU</code>，比如在 我的 <code>ubuntu</code> 机器上可以看到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens33     1500     4513      0      0 0          2872      0      0      0 BMRU</span><br><span class="line">lo       65536     5307      0      0 0          5307      0      0      0 LRU</span><br></pre></td></tr></table></figure>

<h1 id="IP-分段"><a href="#IP-分段" class="headerlink" title="IP 分段"></a><code>IP</code> 分段</h1><h1 id="网络中的木桶效应：路径-MTU"><a href="#网络中的木桶效应：路径-MTU" class="headerlink" title="网络中的木桶效应：路径 MTU"></a>网络中的木桶效应：路径 <code>MTU</code></h1><h1 id="TCP-最大段大小（Max-Segment-Size，MSS）"><a href="#TCP-最大段大小（Max-Segment-Size，MSS）" class="headerlink" title="TCP 最大段大小（Max Segment Size，MSS）"></a><code>TCP</code> 最大段大小（<code>Max Segment Size</code>，<code>MSS</code>）</h1><h1 id="为什么有时候抓包看到的单个数据包大于-MTU"><a href="#为什么有时候抓包看到的单个数据包大于-MTU" class="headerlink" title="为什么有时候抓包看到的单个数据包大于 MTU"></a>为什么有时候抓包看到的单个数据包大于 <code>MTU</code></h1><h1 id="TCP-套接字选项-TCP-MAXSEG"><a href="#TCP-套接字选项-TCP-MAXSEG" class="headerlink" title="TCP 套接字选项 TCP_MAXSEG"></a><code>TCP</code> 套接字选项 <code>TCP_MAXSEG</code></h1><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>IP</code> 数据包长度在超过链路的 MTU 时在发送之前需要分片，而 <code>TCP</code> 层为了 <code>IP</code> 层不用分片主动将包切割成 <code>MSS</code> 大小。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>MTU</tag>
        <tag>MSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Netfilter 框架浅析</title>
    <url>/2024/07/11/network/Netfilter-%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p><code>Netfilter</code>，在 <code>Linux</code> 内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（<code>NAT</code>）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如 <code>iptables</code> 、<code>nftables</code> 、<code>ebtables</code> 和 <code>arptables</code> 等，来控制 <code>Netfilter</code>，系统管理者可以管理通过Linux操作系统的各种网络数据包。<code>1990</code> 年代，<code>Netfilter</code> 在 <code>Linux 2.3.15</code> 版时进入Linux内核，正式应用于 <code>Linux 2.4</code> 版。</p>
<span id="more"></span>

<p>下图为网络数据包通过 <code>Netfilter</code> 时的工作流向图：</p>
<p><img src="/../../images/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%9A%E8%BF%87Netfilter%E6%97%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%90%91.png" alt="网络数据包通过Netfilter时的工作流向"></p>
<h1 id="Netlfilter-框架"><a href="#Netlfilter-框架" class="headerlink" title="Netlfilter 框架"></a>Netlfilter 框架</h1><p><img src="/../../images/netlfilter%E6%A1%86%E6%9E%B6.png" alt="netlfilter框架"></p>
<p><code>Netlfilter</code> 有 <code>5</code> 个 <code>HOOK</code> 点：</p>
<ul>
<li><code>PREROUTING</code>：数据包进入路由表之前</li>
<li><code>INPUT</code>：通过路由表后目的地为本机</li>
<li><code>FORWARD</code>：通过路由表后，目的地不为本机</li>
<li><code>OUTPUT</code>：由本机产生，向外发送</li>
<li><code>POSTROUTIONG</code>：发送到网卡接口之前。</li>
</ul>
<p>从图中可以看到，三个方向的数据包需要经过的钩子节点不完全相同：</p>
<ul>
<li>发往本地：<code>NF_INET_PRE_ROUTING --&gt; NF_INET_LOCAL_IN</code></li>
<li>转发：<code>NF_INET_PRE_ROUTING--&gt;NF_INET_FORWARD--&gt;NF_INET_POST_ROUTING</code></li>
<li>本地发出：<code>NF_INET_LOCAL_OUT--&gt;NF_INET_POST_ROUTING</code></li>
</ul>
<h1 id="Netfilter-重要数据结构及相关函数"><a href="#Netfilter-重要数据结构及相关函数" class="headerlink" title="Netfilter 重要数据结构及相关函数"></a>Netfilter 重要数据结构及相关函数</h1><h2 id="钩子操作数据结构"><a href="#钩子操作数据结构" class="headerlink" title="钩子操作数据结构"></a>钩子操作数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: include/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">/* User fills in from here down. */</span></span><br><span class="line">	nf_hookfn		*hook;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">void</span>			*priv;</span><br><span class="line">	<span class="type">u_int8_t</span>		pf;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		hooknum;</span><br><span class="line">	<span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">	<span class="type">int</span>			priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体中存储了自定义的钩子函数（<code>nf_hookfn</code>），函数优先级（<code>priority</code>），处理协议类型（<code>pf</code>），钩子函数生效的钩子节点（<code>hooknum</code>）等信息。</p>
<h2 id="钩子点枚举类型"><a href="#钩子点枚举类型" class="headerlink" title="钩子点枚举类型"></a>钩子点枚举类型</h2><p>上面提到的网络层中 <code>Netfilter</code> 的几个钩子节点，在内核中是以枚举数据类型进行标记的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">// linux/netfilter.h 会引入uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">    NF_INET_PRE_ROUTING,</span><br><span class="line">    NF_INET_LOCAL_IN,</span><br><span class="line">    NF_INET_FORWARD,</span><br><span class="line">    NF_INET_LOCAL_OUT,</span><br><span class="line">    NF_INET_POST_ROUTING,</span><br><span class="line">    NF_INET_NUMHOOKS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="钩子函数声明"><a href="#钩子函数声明" class="headerlink" title="钩子函数声明"></a>钩子函数声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hook;</span><br><span class="line">	<span class="type">u_int8_t</span> pf;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">in</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">out</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	<span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="注册和解注册钩子函数"><a href="#注册和解注册钩子函数" class="headerlink" title="注册和解注册钩子函数"></a>注册和解注册钩子函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: include/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Function to register/unregister hook points. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_unregister_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hooks</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *reg,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_unregister_net_hooks</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *reg,</span></span><br><span class="line"><span class="params">			     <span class="type">unsigned</span> <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="钩子函数返回的动作"><a href="#钩子函数返回的动作" class="headerlink" title="钩子函数返回的动作"></a>钩子函数返回的动作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">// linux/netfilter.h 会引入uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_DROP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_ACCEPT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_STOLEN 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_QUEUE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_REPEAT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_STOP 5	<span class="comment">/* Deprecated, for userspace nf_queue compatibility. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_MAX_VERDICT NF_STOP</span></span><br></pre></td></tr></table></figure>

<h2 id="处理协议类型-pf"><a href="#处理协议类型-pf" class="headerlink" title="处理协议类型 pf"></a>处理协议类型 <code>pf</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">// linux/netfilter.h 会引入uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	NFPROTO_UNSPEC =  <span class="number">0</span>,</span><br><span class="line">	NFPROTO_INET   =  <span class="number">1</span>,</span><br><span class="line">	NFPROTO_IPV4   =  <span class="number">2</span>,</span><br><span class="line">	NFPROTO_ARP    =  <span class="number">3</span>,</span><br><span class="line">	NFPROTO_NETDEV =  <span class="number">5</span>,</span><br><span class="line">	NFPROTO_BRIDGE =  <span class="number">7</span>,</span><br><span class="line">	NFPROTO_IPV6   = <span class="number">10</span>,</span><br><span class="line">	NFPROTO_DECNET = <span class="number">12</span>,</span><br><span class="line">	NFPROTO_NUMPROTO,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优先级-priorities"><a href="#优先级-priorities" class="headerlink" title="优先级 priorities"></a>优先级 priorities</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: include/uapi/linux/netfilter_ipv4.h</span></span><br><span class="line"><span class="comment">// include/netfilter_ipv4.h 会引入uapi/linux/netfilter_ipv4.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_ip_hook_priorities</span> &#123;</span></span><br><span class="line">	NF_IP_PRI_FIRST = INT_MIN,</span><br><span class="line">	NF_IP_PRI_RAW_BEFORE_DEFRAG = <span class="number">-450</span>,</span><br><span class="line">	NF_IP_PRI_CONNTRACK_DEFRAG = <span class="number">-400</span>,</span><br><span class="line">	NF_IP_PRI_RAW = <span class="number">-300</span>,</span><br><span class="line">	NF_IP_PRI_SELINUX_FIRST = <span class="number">-225</span>,</span><br><span class="line">	NF_IP_PRI_CONNTRACK = <span class="number">-200</span>,</span><br><span class="line">	NF_IP_PRI_MANGLE = <span class="number">-150</span>,</span><br><span class="line">	NF_IP_PRI_NAT_DST = <span class="number">-100</span>,</span><br><span class="line">	NF_IP_PRI_FILTER = <span class="number">0</span>,</span><br><span class="line">	NF_IP_PRI_SECURITY = <span class="number">50</span>,</span><br><span class="line">	NF_IP_PRI_NAT_SRC = <span class="number">100</span>,</span><br><span class="line">	NF_IP_PRI_SELINUX_LAST = <span class="number">225</span>,</span><br><span class="line">	NF_IP_PRI_CONNTRACK_HELPER = <span class="number">300</span>,</span><br><span class="line">	NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,</span><br><span class="line">	NF_IP_PRI_LAST = INT_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="一个-demo"><a href="#一个-demo" class="headerlink" title="一个 demo"></a>一个 <code>demo</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPLv3&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;TY&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Netfliter test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_test_in_hook</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">nf_test_ops</span>[] __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    .hook = nf_test_in_hook,</span><br><span class="line">    .pf = NFPROTO_IPV4,</span><br><span class="line">    .hooknum = NF_INET_LOCAL_IN,</span><br><span class="line">    .priority = NF_IP_PRI_FIRST,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hdr_dump</span><span class="params">(<span class="keyword">struct</span> ethhdr *ehdr)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;[MAC_DES:%x,%x,%x,%x,%x,%x&quot;</span></span><br><span class="line">           <span class="string">&quot;MAC_SRC: %x,%x,%x,%x,%x,%x Prot:%x]\n&quot;</span>,</span><br><span class="line">           ehdr-&gt;h_dest[<span class="number">0</span>],ehdr-&gt;h_dest[<span class="number">1</span>],ehdr-&gt;h_dest[<span class="number">2</span>],ehdr-&gt;h_dest[<span class="number">3</span>],</span><br><span class="line">           ehdr-&gt;h_dest[<span class="number">4</span>],ehdr-&gt;h_dest[<span class="number">5</span>],ehdr-&gt;h_source[<span class="number">0</span>],ehdr-&gt;h_source[<span class="number">1</span>],</span><br><span class="line">           ehdr-&gt;h_source[<span class="number">2</span>],ehdr-&gt;h_source[<span class="number">3</span>],ehdr-&gt;h_source[<span class="number">4</span>],</span><br><span class="line">           ehdr-&gt;h_source[<span class="number">5</span>],ehdr-&gt;h_proto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIPQUAD(addr) \</span></span><br><span class="line"><span class="meta">        ((unsigned char *)&amp;addr)[0], \</span></span><br><span class="line"><span class="meta">        ((unsigned char *)&amp;addr)[1], \</span></span><br><span class="line"><span class="meta">        ((unsigned char *)&amp;addr)[2], \</span></span><br><span class="line"><span class="meta">        ((unsigned char *)&amp;addr)[3]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIPQUAD_FMT <span class="string">&quot;%u.%u.%u.%u&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_test_in_hook</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth_header</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip_header</span>;</span></span><br><span class="line">  eth_header = (<span class="keyword">struct</span> ethhdr *)(skb_mac_header(skb));</span><br><span class="line">  ip_header = (<span class="keyword">struct</span> iphdr *)(skb_network_header(skb));</span><br><span class="line">  hdr_dump(eth_header);</span><br><span class="line">  printk(<span class="string">&quot;src IP:&#x27;&quot;</span>NIPQUAD_FMT<span class="string">&quot;&#x27;, dst IP:&#x27;&quot;</span>NIPQUAD_FMT<span class="string">&quot;&#x27; \n&quot;</span>,</span><br><span class="line">         NIPQUAD(ip_header-&gt;saddr), NIPQUAD(ip_header-&gt;daddr));</span><br><span class="line">  <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_nf_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  ret = nf_register_hooks(nf_test_ops, ARRAY_SIZE(nf_test_ops));</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;register nf hook fail\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(KERN_NOTICE <span class="string">&quot;register nf test hook\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">exit_nf_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  nf_unregister_hooks(nf_test_ops, ARRAY_SIZE(nf_test_ops));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_nf_test);</span><br><span class="line">module_exit(exit_nf_test);=</span><br></pre></td></tr></table></figure>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">obj-m += nf_test.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/Netfilter">Netfilter Wiki</a></li>
<li><a href="https://wiki.dreamrunner.org/public_html/Linux/Networks/netfilter.html">Linux Netfilter and Traffic Control</a></li>
<li><a href="https://blog.csdn.net/lianhunqianr1/article/details/117538796">Linux Kernel TCP&#x2F;IP Stack|Linux网络硬核系列</a></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Netfilter</tag>
      </tags>
  </entry>
  <entry>
    <title>QUIC 协议初探</title>
    <url>/2024/03/08/network/QUIC-%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>Package Type</p>
<ul>
<li>Long Header Packets<ul>
<li>Version Negotiation Packet</li>
<li>Initial Packet</li>
<li>0-RTT Packet</li>
<li>Handshake Packet</li>
<li>Retry Packet</li>
</ul>
</li>
<li>Short Header Packets<ul>
<li>1-RTT Packet</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+=====================+=================+==================+</span><br><span class="line">| Packet Type         | Encryption Keys | PN Space         |</span><br><span class="line">+=====================+=================+==================+</span><br><span class="line">| Initial             | Initial secrets | Initial          |</span><br><span class="line">+---------------------+-----------------+------------------+</span><br><span class="line">| 0-RTT Protected     | 0-RTT           | Application data |</span><br><span class="line">+---------------------+-----------------+------------------+</span><br><span class="line">| Handshake           | Handshake       | Handshake        |</span><br><span class="line">+---------------------+-----------------+------------------+</span><br><span class="line">| Retry               | N/A             | N/A              |</span><br><span class="line">+---------------------+-----------------+------------------+</span><br><span class="line">| Version Negotiation | N/A             | N/A              |</span><br><span class="line">+---------------------+-----------------+------------------+</span><br><span class="line">| Short Header        | 1-RTT           | Application data |</span><br><span class="line">+---------------------+-----------------+------------------+</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>QUIC</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP Nagle算法与ACK延迟确认</title>
    <url>/2023/11/20/network/TCP-Nagle%E7%AE%97%E6%B3%95%E4%B8%8EACK%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>TCP-TFO快速打开</title>
    <url>/2024/03/21/network/TCP-TFO%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80/</url>
    <content><![CDATA[<h1 id="请求-Fast-Open-Cookie-的过程如下："><a href="#请求-Fast-Open-Cookie-的过程如下：" class="headerlink" title="请求 Fast Open Cookie 的过程如下："></a>请求 <code>Fast Open Cookie</code> 的过程如下：</h1><ul>
<li><p>客户端发送一个 <code>SYN</code> 包，头部包含 <code>Fast Open</code> 选项，且该选项的 <code>Cookie</code> 为空，这表明客户端请求 <code>Fast Open Cookie</code></p>
</li>
<li><p>服务端收取 <code>SYN</code> 包以后，生成一个 <code>cookie</code> 值（一串字符串）</p>
</li>
<li><p>服务端发送 <code>SYN</code> + <code>ACK</code> 包，在 <code>Options</code> 的 <code>Fast Open</code> 选项中设置 <code>cookie</code> 的值</p>
</li>
<li><p>客户端缓存服务端的 <code>IP</code> 和收到的 <code>cookie</code> 值</p>
<span id="more"></span>
<p>第一次过后，客户端就有了缓存在本地的 <code>cookie</code> 值，后面的握手和数据传输过程如下：</p>
</li>
<li><p>客户端发送 <code>SYN</code> 数据包，里面包含数据和之前缓存在本地的 <code>Fast Open Cookie</code>。</p>
</li>
<li><p>服务端检验收到的 <code>TFO Cookie</code> 和传输的数据是否合法。</p>
<ul>
<li>如果合法就会返回 <code>SYN</code> + <code>ACK</code> 包进行确认并将数据包传递给应用层</li>
<li>如果不合法就会丢弃数据包，走正常三次握手流程（只会确认 <code>SYN</code>）</li>
</ul>
</li>
<li><p>服务端程序收到数据以后可以握手完成之前发送响应数据给客户端了</p>
</li>
<li><p>客户端发送 <code>ACK</code> 包，确认第二步的 <code>SYN</code> 包和数据（如果有的话）<br>后面的过程就跟非 <code>TFO</code> 连接过程一样了</p>
</li>
</ul>
<p>我们看看 <code>curl</code> 如何支持 <code>fast open</code>, 通过 <code>strace</code> 抓下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace curl --tcp-fastopen http://192.168.14.168</span><br></pre></td></tr></table></figure>
<p><img src="/../../images/tfo_curl.jpg" alt="tfo_curl"></p>
<p>我们看下在服务器的抓包信息:</p>
<h2 id="第一次请求"><a href="#第一次请求" class="headerlink" title="第一次请求"></a>第一次请求</h2><p><code>fast open cookie</code> 为空</p>
<h2 id="第二次请求"><a href="#第二次请求" class="headerlink" title="第二次请求"></a>第二次请求</h2><p>第一个 <code>SYN</code> 包被识别成了 <code>HTTP</code> 请求<br><img src="/../../images/tfo_2.jpg" alt="tfo"></p>
<p><img src="/../../images/tfo_2_1.png" alt="tfo_1"><br><img src="/../../images/tfo_2_2.png" alt="tfo_2"></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>tfo</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 协议</title>
    <url>/2023/07/25/network/TCP-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a><code>TCP</code> 基本认识</h1><p><code>TCP</code> 是 <strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<h2 id="源端口-Source-Port"><a href="#源端口-Source-Port" class="headerlink" title="源端口(Source Port)"></a>源端口(<code>Source Port</code>)</h2><p>源端口，<code>16</code> 位</p>
<h2 id="目标端口-Destination-Port"><a href="#目标端口-Destination-Port" class="headerlink" title="目标端口(Destination Port)"></a>目标端口(<code>Destination Port</code>)</h2><p>目标端口，<code>16</code> 位</p>
<h2 id="序列号-Sequence-Number"><a href="#序列号-Sequence-Number" class="headerlink" title="序列号 (Sequence Number)"></a>序列号 (<code>Sequence Number</code>)</h2><p><code>TCP</code> 是面向字节流的协议，通过 <code>TCP</code> 传输的字节流的每个字节都分配了序列号，序列号（<code>Sequence number</code>）指的是本报文段第一个字节的序列号。</p>
<p>序列号加上报文的长度，就可以确定传输的是哪一段数据。序列号是一个 <code>32</code> 位的无符号整数，达到 <code>2^32-1</code> 后循环到 <code>0</code>。</p>
<p>在 <code>SYN</code> 报文中，序列号用于交换彼此的初始序列号，在其它报文中，序列号用于保证包的顺序。</p>
<p>因为网络层（<code>IP</code> 层）不保证包的顺序，<code>TCP</code> 协议利用序列号来解决网络包乱序、重复的问题，以保证数据包以正确的顺序组装传递给上层应用。</p>
<h3 id="初始序列号-（Initial-Sequence-Number-ISN）"><a href="#初始序列号-（Initial-Sequence-Number-ISN）" class="headerlink" title="初始序列号 （Initial Sequence Number, ISN）"></a>初始序列号 （<code>Initial Sequence Number, ISN</code>）</h3><p>在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。在建立连接时，通信双方通过 <code>SYN</code> 报文交换彼此的 <code>ISN</code></p>
<h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><h2 id="确认号-Acknowledgment-Number"><a href="#确认号-Acknowledgment-Number" class="headerlink" title="确认号 (Acknowledgment Number)"></a>确认号 (<code>Acknowledgment Number</code>)</h2><p><code>TCP</code> 使用确认号（<code>Acknowledgment number, ACK</code>）来告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到</p>
<h2 id="头部长度-Data-Offset"><a href="#头部长度-Data-Offset" class="headerlink" title="头部长度 (Data Offset ):"></a>头部长度 (<code>Data Offset </code>):</h2><p>只有 <code>4</code> 位, 取值范围 <code>0~15</code>, 表示 <code>TCP</code>头长度为 <code>32位(4字节)</code>的数量。<code>TCP</code> 头（甚至包括选项）的长度是 <code>32</code> 位的整数倍。例如 <code>DOffset</code>的值为 <code>0111</code>, 则该TCP包头的长度为 <code>7 * 4 = 28</code></p>
<h2 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h2><ul>
<li><code>SYN（Synchronize）</code>：用于发起连接数据包同步双方的初始序列号</li>
<li><code>ACK（Acknowledge）</code>：确认数据包</li>
<li><code>RST（Reset）</code>：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理</li>
<li><code>FIN（Finish）</code>：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。</li>
<li><code>PSH（Push）</code>：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来</li>
</ul>
<h2 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 (Window Size)"></a>窗口大小 (<code>Window Size</code>)</h2><p>窗口大小字段是接收方用来控制发送方数据流量的机制。它表示接收方当前允许发送方发送但尚未确认的数据字节数。通过动态调整窗口大小，<code>TCP</code> 可以有效地进行流量控制，防止发送方数据发送过快导致接收方缓存溢出。</p>
<p><code>TCP</code> 协议窗口大小只有 <code>16</code> 位，最大窗口大小为 <code>65535</code> 字节(<code>64KB</code>), 在今天显然不够用，所以 <code>TCP</code> 协议引入了 <strong>TCP 窗口缩放</strong> 选项，作为窗口缩放的比例因子，比利因子的值在 <code>0～14</code>，其中 <code>0</code> 表示不缩放，最大值为  <code>14</code>。比例因子可以将窗口扩大到原来的 <code>2</code> 的 <code>n</code> 次方，比如窗口大小缩放前为 <code>1050</code>，缩放因子为 <code>7</code>，则真正的窗口大小为 <code>1050 * 128 = 134400</code></p>
<h2 id="窗口缩放选项"><a href="#窗口缩放选项" class="headerlink" title="窗口缩放选项"></a>窗口缩放选项</h2><p>由于窗口大小字段只有 <code>16</code> 位，最大值为 <code>65535</code> 字节，这对于高带宽-延迟产品 (<code>BDP</code>) 的网络可能不够。为了解决这个问题，<code>TCP</code> 窗口缩放选项 (<code>Window Scale Option</code>) 被引入，用于扩展窗口大小的范围。</p>
<p>窗口缩放选项在 <code>TCP</code> 连接建立时通过 <code>SYN</code> 包交换协商。窗口缩放因子 (<code>Window Scale Factor</code>) 表示允许窗口大小值左移的位数，从而有效地扩展窗口大小的范围。</p>
<h3 id="计算实际窗口大小"><a href="#计算实际窗口大小" class="headerlink" title="计算实际窗口大小"></a>计算实际窗口大小</h3><p>实际的窗口大小计算如下：</p>
<p>$$Actual Window Size &#x3D; Window Size \times 2 ^{Window Scale Factor}$$</p>
<h3 id="示例（带窗口缩放）"><a href="#示例（带窗口缩放）" class="headerlink" title="示例（带窗口缩放）"></a>示例（带窗口缩放）</h3><p>假设窗口大小字段的值是 <code>8192</code>（十进制），窗口缩放因子是 <code>3</code>：</p>
<p>$Actual Window Size &#x3D; 8192 \times 2 ^ 3 &#x3D; 8192 \times 8 &#x3D; 65536 $ bytes</p>
<p>这表示接收方可以接受最多 <code>65536</code> 字节的未确认数据。</p>
<h2 id="可选项-Options"><a href="#可选项-Options" class="headerlink" title="可选项 (Options)"></a>可选项 (<code>Options</code>)</h2><p>只有 (<code>DOffset &gt; 5</code>) 才有此数据,</p>
<p>可选项的格式：</p>
<ul>
<li><p>一个字节的 <code>Kind</code></p>
<ul>
<li><code>No-Operation</code>: 无操作。</li>
</ul>
</li>
<li><p>一个字节的 <code>Kind</code>, 一个字节的 <code>option-length</code>，和真实的 <code>option data</code></p>
<ul>
<li><code>MSS</code>：最大段大小选项，是 <code>TCP</code> 允许的从对方接收的最大报文段</li>
<li><code>SACK</code>：选择确认选项</li>
<li><code>Window Scale</code>：窗口缩放选项<span id="more"></span>
<code>TCP</code> 连接状态图</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             +---------+ ---------\      active OPEN</span><br><span class="line">                             |  CLOSED |            \    -----------</span><br><span class="line">                             +---------+&lt;---------\   \   create TCB</span><br><span class="line">                               |     ^              \   \  snd SYN</span><br><span class="line">                  passive OPEN |     |   CLOSE        \   \</span><br><span class="line">                  ------------ |     | ----------       \   \</span><br><span class="line">                   create TCB  |     | delete TCB         \   \</span><br><span class="line">                               V     |                      \   \</span><br><span class="line">                             +---------+            CLOSE    |    \</span><br><span class="line">                             |  LISTEN |          ---------- |     |</span><br><span class="line">                             +---------+          delete TCB |     |</span><br><span class="line">                  rcv SYN      |     |     SEND              |     |</span><br><span class="line">                 -----------   |     |    -------            |     V</span><br><span class="line">+---------+      snd SYN,ACK  /       \   snd SYN          +---------+</span><br><span class="line">|         |&lt;-----------------           ------------------&gt;|         |</span><br><span class="line">|   SYN   |                    rcv SYN                     |   SYN   |</span><br><span class="line">|   RCVD  |&lt;-----------------------------------------------|   SENT  |</span><br><span class="line">|         |                    snd ACK                     |         |</span><br><span class="line">|         |------------------           -------------------|         |</span><br><span class="line">+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+</span><br><span class="line">  |           --------------   |     |   -----------</span><br><span class="line">  |                  x         |     |     snd ACK</span><br><span class="line">  |                            V     V</span><br><span class="line">  |  CLOSE                   +---------+</span><br><span class="line">  | -------                  |  ESTAB  |</span><br><span class="line">  | snd FIN                  +---------+</span><br><span class="line">  |                   CLOSE    |     |    rcv FIN</span><br><span class="line">  V                  -------   |     |    -------</span><br><span class="line">+---------+          snd FIN  /       \   snd ACK          +---------+</span><br><span class="line">|  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |</span><br><span class="line">| WAIT-1  |------------------                              |   WAIT  |</span><br><span class="line">+---------+          rcv FIN  \                            +---------+</span><br><span class="line">  | rcv ACK of FIN   -------   |                            CLOSE  |</span><br><span class="line">  | --------------   snd ACK   |                           ------- |</span><br><span class="line">  V        x                   V                           snd FIN V</span><br><span class="line">+---------+                  +---------+                   +---------+</span><br><span class="line">|FINWAIT-2|                  | CLOSING |                   | LAST-ACK|</span><br><span class="line">+---------+                  +---------+                   +---------+</span><br><span class="line">  |                rcv ACK of FIN |                 rcv ACK of FIN |</span><br><span class="line">  |  rcv FIN       -------------- |    Timeout=2MSL -------------- |</span><br><span class="line">  |  -------              x       V    ------------        x       V</span><br><span class="line">   \ snd ACK                 +---------+delete TCB         +---------+</span><br><span class="line">    ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |</span><br><span class="line">                             +---------+                   +---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何唯一确定一个-TCP-连接"><a href="#如何唯一确定一个-TCP-连接" class="headerlink" title="如何唯一确定一个 TCP 连接?"></a>如何唯一确定一个 <code>TCP</code> 连接?</h2><p><strong><code>TCP</code> 四元组</strong>可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<h1 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a><code>TCP</code> 连接建立</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul>
<li>防止历史连接</li>
<li>避免资源浪费</li>
<li>同步双方初始序列号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    TCP A                                                TCP B</span><br><span class="line"></span><br><span class="line">1.  CLOSED                                               LISTEN</span><br><span class="line"></span><br><span class="line">2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</span><br></pre></td></tr></table></figure>

<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p><code>TCP</code> 针对数据包丢失的情况，会用重传机制解决。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><code>RTT</code>（<code>Round-Trip Time</code> 往返时延）指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。</p>
<p>超时重传时间是以 <code>RTO</code> （<code>Retransmission Timeout</code>）表示。</p>
<p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p>
<ul>
<li>当超时时间 <code>RTO</code> 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <code>RTO</code> 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>根据上述的两种情况，我们可以得知，超时重传时间 <code>RTO</code> 的值应该略大于报文往返 <code>RTT</code> 的值。因为网络也是时常变化的，所以 <code>RTO</code> 是一个动态变化的值。</p>
<p>每当遇到一次超时重传的时候，都会将下一次 <code>RTO</code> 设为<strong>先前值的两倍</strong>。两次超时，就说明网络环境差，不宜频繁反复发送。</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>当收到三个相同的 <code>ACK</code> 报文时，会在定时器过期之前，重传丢失的报文段。快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题。为了解决不知道该重传哪些 <code>TCP</code> 报文，于是就有 <code>SACK</code> 方法。</p>
<h2 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h2><p><code>SACK</code>（<code>Selective Acknowledgment</code>），选择性确认。在 <code>TCP</code> 头部「选项」字段里加一个 <code>SACK</code> ，它可以将已收到的数据的信息发送给 <strong>「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以 <strong>只重传丢失的数据</strong>。</p>
<blockquote>
<p>在 <code>Linux</code> 下可以通过 <code>net.ipv4.tcp_sack</code> 参数开启&#x2F;关闭这个功能（<code>Linux 2.4</code> 后默认打开）。</p>
</blockquote>
<h2 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h2><p><code>D-SACK</code> (<code>Duplicate SACK</code>) ，其主要使用了 <code>SACK</code> 来告诉 <strong>「发送方」</strong>有哪些数据被重复接收了。</p>
<p><code>D-SACK</code> 有这么几个好处：</p>
<ul>
<li>可以让<strong>发送方</strong>知道，是发出去的包丢了，还是接收方回应的 <code>ACK</code> 包丢了</li>
<li>可以知道是不是<strong>发送方</strong>的数据包被网络延迟了</li>
<li>可以知道网络中是不是把<strong>发送方</strong>的数据包给复制了</li>
</ul>
<blockquote>
<p>在 <code>Linux</code> 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（<code>Linux 2.4</code> 后默认打开）。</p>
</blockquote>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值</p>
<h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h2><h2 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h2><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，**<code>TCP</code> 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**</p>
<h2 id="操作系统缓冲区和滑动窗口的关系"><a href="#操作系统缓冲区和滑动窗口的关系" class="headerlink" title="操作系统缓冲区和滑动窗口的关系"></a>操作系统缓冲区和滑动窗口的关系</h2><h2 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h2><p>如果窗口大小为 <code>0</code> 时，就会阻止发送方给接收方传递数据，直到窗口变为非 <code>0</code> 为止，这就是窗口关闭。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>慢启动就是一点一点的提高发送数据包的数量, <strong>当发送方每收到一个 <code>ACK</code>，拥塞窗口 <code>cwnd</code> 的大小就会加 <code>1</code></strong>, 发包的个数是<strong>指数性的增长</strong></p>
<ul>
<li>慢启动门限 <code>ssthresh</code> （<code>slow start threshold</code>）状态变量，默认 <code>65535</code> 大小。<ul>
<li><code>cwnd</code> &lt; <code>ssthresh</code> 时，使用<strong>慢启动算法</strong>。</li>
<li><code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用<strong>拥塞避免算法</strong>。</li>
</ul>
</li>
</ul>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p><strong>每当收到一个 <code>ACK</code> 时，<code>cwnd</code> 增加 <code>1/cwnd</code></strong>, 发包的个数是<strong>线性的增长</strong></p>
<h2 id="拥塞发送"><a href="#拥塞发送" class="headerlink" title="拥塞发送"></a>拥塞发送</h2><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<h3 id="超时重传-1"><a href="#超时重传-1" class="headerlink" title="超时重传"></a>超时重传</h3><ul>
<li><code>ssthresh</code> 设为<code> cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>10</code> （是恢复为 <code>cwnd</code> 初始化值，<code>Linux</code> 默认的 <code>cwnd</code> 初始化值 <code>10</code>）</li>
<li>进入慢启动<br>接着重新开始慢启动，慢启动是会突然减少数据流的, 这种方式太激进了，反应也很强烈，会造成网络卡顿。</li>
</ul>
<h3 id="快速重传-1"><a href="#快速重传-1" class="headerlink" title="快速重传"></a>快速重传</h3><p>当接收方发现丢了一个中间包的时候，发送三次前一个包的 <code>ACK</code>，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p><code>TCP</code> 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半</li>
<li><code>ssthresh = cwnd</code></li>
<li>进入快速恢复算法</li>
</ul>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>前面已讲进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半</li>
<li><code>ssthresh = cwnd</code></li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ <code>3</code> 的意思是确认有 <code>3</code> 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 <code>ACK</code>，那么 <code>cwnd</code> 增加 <code>1</code>；</li>
<li>如果收到新数据的 <code>ACK</code> 后，把 <code>cwnd</code> 设置为第一步中的 <code>ssthresh</code> 的值，原因是该 <code>ACK</code> 确认了新的数据，说明从 <code>duplicated ACK</code> 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入<strong>拥塞避免</strong>状态；</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="">深入理解TCP协议-从原理到实战</a></li>
<li><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">图解网络</a></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2023/07/17/network/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h1><p><code>HTTP</code> 是超文本传输协议，也就是 <code>HyperText Transfer Protocol</code>。</p>
<h1 id="URI-的完整图解"><a href="#URI-的完整图解" class="headerlink" title="URI 的完整图解"></a>URI 的完整图解</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  foo://example.com:8042/over/there?name=ferret#nose</span><br><span class="line">  \_/   \______________/\_________/ \_________/ \__/</span><br><span class="line">   |           |            |            |        |</span><br><span class="line">scheme     authority       path        query   fragment</span><br><span class="line">   |   _____________________|__</span><br><span class="line">  / \ /                        \</span><br><span class="line">  urn:example:animal:ferret:nose</span><br></pre></td></tr></table></figure>

<h1 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-line</span><br><span class="line">*( header-field CRLF )</span><br><span class="line">CRLF</span><br><span class="line">[ message-body ]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="start-line"><a href="#start-line" class="headerlink" title="start-line"></a>start-line</h2><ul>
<li>request line<ul>
<li>method SP request-target SP HTTP-version CRLF</li>
</ul>
</li>
<li>status line<ul>
<li>HTTP-version SP status-code SP reason-phrase CRLF</li>
</ul>
</li>
</ul>
<h2 id="Header-Fields"><a href="#Header-Fields" class="headerlink" title="Header Fields"></a>Header Fields</h2><ul>
<li>field-name “:” OWS field-value OWS</li>
</ul>
<h2 id="Message-Body"><a href="#Message-Body" class="headerlink" title="Message Body"></a>Message Body</h2><p>在一个请求中是否会出现消息体，以消息头中是否带有 <code>Content-Length</code> 或者 <code>Transfer-Encoding</code> 头字段作为信号</p>
<h1 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h1><h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p><a href="https://datatracker.ietf.org/doc/html/rfc7230#section-2.3">RFC 7230 - HTTP&#x2F;1.1: Message Syntax and Routing</a> 这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 <code>HTTP</code> 报文。</p>
<h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6">RFC 7231 - HTTP&#x2F;1.1: Semantics and Content</a> <code>HTTP</code> 客户端通过 <code>CONNECT</code> 方法请求隧道代理创建一条到达任意目的服务器和端口的 <code>TCP</code> 连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONNECT server.example.com:80 HTTP/1.1</span><br></pre></td></tr></table></figure>


<h1 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3 演变"></a><code>HTTP/1.1、HTTP/2、HTTP/3</code> 演变</h1><h2 id="HTTP-1-1-的优化"><a href="#HTTP-1-1-的优化" class="headerlink" title="HTTP/1.1 的优化"></a><code>HTTP/1.1</code> 的优化</h2><ul>
<li>长连接</li>
<li>支持管道 （<code>pipeline</code>）网络传输</li>
</ul>
<p>但 <code>HTTP/1.1</code> 还是有性能瓶颈：</p>
<ul>
<li>请求 &#x2F; 响应头部（<code>Header</code>）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<h2 id="HTTP-2-的优化"><a href="#HTTP-2-的优化" class="headerlink" title="HTTP/2 的优化"></a><code>HTTP/2</code> 的优化</h2><ul>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ul>
<h2 id="HTTP-3-的优化"><a href="#HTTP-3-的优化" class="headerlink" title="HTTP/3 的优化"></a><code>HTTP/3</code> 的优化</h2><p><code>HTTP/3</code> 基于 <code>UDP</code> 的 <code>QUIC</code> 协议 可以实现类似 <code>TCP</code> 的可靠性传输, 有以下 <code>3</code> 个特点。</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>libevent 使用入门</title>
    <url>/2023/08/23/network/libevent-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>libEvent</code>, 一个事件通知库。有以下特点：</p>
<ul>
<li>事件驱动，高性能；</li>
<li>轻量级，专注于网络；</li>
<li>跨平台，支持 <code>Windows</code>、<code>Linux</code>、<code>Mac</code> 等；</li>
<li>支持多种 <code>I/O</code> 多路复用技术， <code>epoll</code>、<code>poll</code>、<code>dev/poll</code>、<code>select</code> 和 <code>kqueue</code> 等；</li>
<li>支持 <code>I/O</code> ，定时器和信号等事件；</li>
</ul>
<h1 id="libevent接口分析"><a href="#libevent接口分析" class="headerlink" title="libevent接口分析"></a>libevent接口分析</h1><p>libevent 接口大概分为以下几类: </p>
<ul>
<li>环境配置和初始化<ul>
<li><code>event_base_new</code></li>
</ul>
</li>
<li><code>evutil socket</code> 函数封装<ul>
<li><code>evutil_make_socket_nonblocking</code></li>
<li><code>evutil_make_listen_socket_reuseable</code><ul>
<li>set SO_REUSEADDR on Unix and does nothing on Windows</li>
</ul>
</li>
<li><code>evutil_closesocket</code></li>
</ul>
</li>
<li>事件<code>IO</code>处理<ul>
<li><code>event_new</code></li>
</ul>
</li>
<li>缓冲<code>IO</code><ul>
<li><code>bufferevent</code></li>
</ul>
</li>
<li>循环(<code>Loop</code>)<ul>
<li><code>event_base_dispatch</code></li>
</ul>
</li>
</ul>
<h1 id="Libevent-API"><a href="#Libevent-API" class="headerlink" title="Libevent API"></a>Libevent API</h1><h2 id="libevent上下文创建"><a href="#libevent上下文创建" class="headerlink" title="libevent上下文创建"></a>libevent上下文创建</h2><ul>
<li>event_base *event_base_new(void)</li>
<li>event_base *event_base_new_with_config( const struct event_config *);<ul>
<li>配置参数<ul>
<li>event_config *event_config_new(void);</li>
<li>void event_config_free(struct event_config * cfg);</li>
</ul>
</li>
</ul>
</li>
<li>event_reinit<ul>
<li>int event_reinit(struct event_base *base); 调用 fork 之后可以正确工作</li>
</ul>
</li>
<li>void event_base_free(struct event_base *); 释放event_base内部分配的空间及其本身对象的空间，不释放事件和socket和在回调函数中申请 的空间</li>
<li>event_config_set_flag</li>
<li>event_config_avoid_method(struct event_ config *cfg, const char *method);</li>
<li>event_config_require_features</li>
</ul>
<p>event_base_config_flag</p>
<ul>
<li><p>EVENT_BASE_FLAG_NOLOCK: </p>
<ul>
<li>不要为event_base 分配锁。设置这个选项可以为event_base 节省一点用于锁定和解锁的时间，但是让在多个线程中访问event_base 成为不安全的。</li>
</ul>
</li>
<li><p>EVENT_BASE_FLAG_IGNORE_ENV</p>
<ul>
<li>选择使用的后端时，不要检测EVENT_*环境变量。使用这个标志需要三思:这会让用户更难 调试你的程序与libevent 的交互。</li>
</ul>
</li>
<li><p>EVENT_BASE_FLAG_STARTUP_IOCP</p>
<ul>
<li>仅用于Windows,启用任何必需的IOCP 分发逻辑</li>
<li>iocp<ul>
<li>event_config_set_num_cpus_hint</li>
<li>event_config_set_flag(cfg, EVENT_BASE_ FLAG_STARTUP_IOCP)</li>
<li>evthread_use_windows_threads();</li>
</ul>
</li>
</ul>
</li>
<li><p>EVENT_BASE_FLAG_NO_CACHE_TIME</p>
<ul>
<li>不是在事件循环每次准备执行超时回调时检测当前时间，而是在每次超时回调后进行检 测。注意:这会消耗更多的CPU 时间。</li>
</ul>
</li>
<li><p>EVENT_BASE_FLAG_EPOLL_USE_ CHANGELIST</p>
<ul>
<li>epoll下有效，防止同一个fd多次激发事件，fd如果做复制会有bug</li>
</ul>
</li>
<li><p>EVENT_BASE_FLAG_PRECISE_TIMER</p>
<ul>
<li>默认使用系统最快的记时机制，如果系统有较慢 且更精确的则采用</li>
</ul>
</li>
</ul>
<p>event_method_feature</p>
<ul>
<li>EV_FEATURE_ET &#x3D; 0x01<ul>
<li>边沿触发的后端</li>
</ul>
</li>
<li>EV_FEATURE_O1 &#x3D; 0x02,<ul>
<li>要求添加、删除单个事件，或者确定哪个事件激 活的操作是O(1)复杂度的后端</li>
</ul>
</li>
<li>EV_FEATURE_FDS &#x3D; 0x04,<ul>
<li>要求支持任意文件描述符，而不仅仅是套接字的 后端</li>
</ul>
</li>
<li>EV_FEATURE_EARLY_CLOSE &#x3D; 0x08<ul>
<li>检测连接关闭事件。您可以使用它来检测连接何时关闭，而不必从连接中读取所有挂起的数据。 并非所有后端都支持EV_CLOSED。允许您使用EV_CLOSED，而不需要读取所有挂起的数据。无法在所有内核版本上</li>
</ul>
</li>
</ul>
<h2 id="事件Event处理"><a href="#事件Event处理" class="headerlink" title="事件Event处理"></a>事件Event处理</h2><h2 id="循环-loop"><a href="#循环-loop" class="headerlink" title="循环(loop)"></a>循环(loop)</h2><h2 id="缓冲-bufferevent"><a href="#缓冲-bufferevent" class="headerlink" title="缓冲 bufferevent"></a>缓冲 bufferevent</h2><h2 id="libevent-http"><a href="#libevent-http" class="headerlink" title="libevent http"></a>libevent http</h2>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>libevent</tag>
      </tags>
  </entry>
  <entry>
    <title>socket 编程</title>
    <url>/2023/07/24/network/socket-%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-socket地址结构"><a href="#1-socket地址结构" class="headerlink" title="1. socket地址结构"></a>1. socket地址结构</h1><h2 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a><code>sockaddr_in</code></h2><p><code>ipv4</code> 协议的地址结构是 <code>sockaddr_in</code>，<code>ipv6</code> 的地址结构是<code>sockaddr_in6</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;netinet/in.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>     sin_family;</span><br><span class="line">    <span class="type">in_port_t</span>       sin_port;	    <span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>		<span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">            __SOCKADDR_COMMON_SIZE -</span><br><span class="line">            <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) -</span><br><span class="line">            <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sin_family</code>：表示地址簇，<code>ipv4: AF_INET, ipv6: AF_INET6</code>，</li>
<li><code>sin_port</code>：16位的端口号</li>
<li><code>sin_addr</code>：点分十进制。</li>
</ul>
<h2 id="通用地址结构"><a href="#通用地址结构" class="headerlink" title="通用地址结构"></a>通用地址结构</h2><p>结构体是 <code>sockaddr</code>，方便可以接受 <code>ipv4/ipv6</code> 的地址结构。之所以采用 <code>sockaddr</code>，而不采用 <code>void*</code>  是因为 <code>BSD</code> 设计套接字的时候大约是 <code>1982</code> 年，那个时候的 <code>C</code> 语言还没有<code>void *</code> 的支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>  sa_family;</span><br><span class="line">    <span class="type">char</span>         ss_data[<span class="number">14</span>];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>将 <code>sockaddr_in/sockaddr_in6</code> 强制转换为 <code>sockaddr</code> ，通过 <code>sockaddr</code> 的 <code>sa_family</code> 来分别使用的是 <code>ipv4/ipv6</code>。</p>
<h2 id="网络字节序列和主机字节序列转换"><a href="#网络字节序列和主机字节序列转换" class="headerlink" title="网络字节序列和主机字节序列转换"></a>网络字节序列和主机字节序列转换</h2><p><code>TCP/IP</code> 协议规定，网络传输字节按照<strong>大端字节序列</strong>方式      </p>
<ul>
<li>大端：低地址存储在高位。</li>
<li>小端：低地址存低位。</li>
</ul>
<h3 id="sin-port-转换"><a href="#sin-port-转换" class="headerlink" title="sin_port 转换"></a><code>sin_port</code> 转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;  <span class="comment">// host to net long(32位置)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net short(16位置)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;   <span class="comment">// net to host long</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sin-addr-转换"><a href="#sin-addr-转换" class="headerlink" title="sin_addr 转换"></a><code>sin_addr</code> 转换</h3><p>与协议无关的的转换函数，即 <code>ipv4/ipv6</code>都可以。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p><code>ipv4</code> 专用的转换函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> </span><br><span class="line">*<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> </span><br><span class="line"><span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>; <span class="comment">// 有风险，不建议使用</span></span><br></pre></td></tr></table></figure>
<h1 id="2-socket-函数"><a href="#2-socket-函数" class="headerlink" title="2. socket 函数"></a>2. socket 函数</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a><code>socket</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值 <ul>
<li>失败时返回 <code>-1</code>，成功是返回一个<strong>非零整数值</strong>，表示套接字描述符，<code>sockfd</code>。</li>
</ul>
</li>
<li>参数<ul>
<li><code>family</code>：<ul>
<li><code>PF_INET</code></li>
<li><code>PF_INET6</code></li>
<li><code>PF_LOCAL</code></li>
</ul>
</li>
<li><code>type</code>：<ul>
<li><code>SOCK_STREAM</code> : 表示的是字节流，对应 <code>TCP</code>；</li>
<li><code>SOCK_DGRAM</code> : 表示的是数据报，对应 <code>UDP</code>；</li>
<li><code>SOCK_RAW</code> : 表示的是原始套接字。</li>
<li>还可和 <code>SOCK_NOBLOCK</code> 和<code>SOCK_CLOEXEC</code> 进行组合使用。</li>
</ul>
</li>
<li><code>protocol</code>：<ul>
<li><code>0</code>，原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。目前一般写成 <code>0</code> 即可。</li>
</ul>
</li>
</ul>
</li>
<li>状态：  <ul>
<li>创建 <code>sockfd</code> 以后，处于 <code>CLOSED</code> 状态。</li>
</ul>
</li>
</ul>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>客户端调用函数。  </p>
<ul>
<li>返回值<ul>
<li>成功返回 <code>0</code>，失败返回 <code>-1</code>。</li>
<li>客户端调用 <code>connect</code> 函数，<strong>会激发<code>TCP</code>的三次握手过程</strong>，而且仅仅在连接成功或者失败才返回。<strong>客户端是在第二个分节返回，服务端是第三个分节返回</strong>。  </li>
<li>*<code>ETIMEOUT</code>*：若客户端没有收到 <code>SYN</code> 分节响应，就会返回这个错误。</li>
<li>*<code>ECONNREFUSED</code>*：若对客户端的 <code>SYN</code> 分节响应的是 <code>RST</code>，表示服务器主机在指定的端口上没有进程与之连接，客户端一接受到 <code>RST</code> 就返回 <code>ECONNREFUSED</code> 错误。</li>
<li>不可达错误。</li>
</ul>
</li>
<li>参数<ul>
<li><code>sockfd</code>：是<code>socket</code>函数返回值。</li>
<li><code>sockaddr</code>：是套接字的地址结构，<code>sockaddr_int/sockaddr_in6</code> 强制转换而来。</li>
<li><code>addrlen</code>：传入的地址结构大小。</li>
</ul>
</li>
<li>状态：<br>  <code>connect</code> 会使得当前套接字从 <code>closed</code> 状态转移到 <code>SYN_SENT</code> 状态，如成功再转移到<code>ESTABLISHED</code> 状态，若失败则该套接字不可用，<strong>必须关闭</strong>。</li>
</ul>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><code>bind</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>服务器端调用函数。</p>
<ul>
<li>参数<ul>
<li><code>addr</code><ul>
<li>可以使用<code>通配地址</code> 对于 <code>IPv4</code> 的地址来说，使用 <code>INADDR_ANY</code> 来完成通配地址的设置；对于 <code>IPv6</code> 的地址来说，使用 <code>IN6ADDR_ANY</code> 来完成通配地址的设置</li>
<li><code>0</code>, 系统随机分配</li>
</ul>
</li>
<li><code>port</code><ul>
<li>绑定端口，一般选择大于 <code>1024</code> 的端口。</li>
<li><code>0</code>, 系统随机分配</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line">name.sin_addr.s_addr = htonl (INADDR_ANY); <span class="comment">/* IPV4 通配地址 */</span></span><br></pre></td></tr></table></figure>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a><code>listen</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p><code>listen</code> 函数由<strong>服务器端</strong>调用。</p>
<p>初始化创建的套接字，可以认为是一个”主动”套接字，其目的是之后主动发起请求（通过调用 <code>connect</code> 函数）。通过 <code>listen</code> 函数，可以将原来的”主动”套接字转换为”被动”套接字，告诉操作系统内核：”我这个套接字是用来等待用户请求的。”, 操作系统内核会为此做好接收用户请求的一切准备，比如完成连接队列。</p>
<ul>
<li><p>返回值 </p>
<ul>
<li>失败时返回 <code>-1</code>，成功返回 <code>0</code>。</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>sockfd</code><ul>
<li>初始化套接字</li>
</ul>
</li>
<li><code>backlog</code><ul>
<li><p>内核为相应套接字排队的最大连接个数，这个参数的大小决定了可以接收的并发数目。</p>
</li>
<li><p>内核为每个<strong>监听</strong>套接字维护两个队列：<br>  (1) 半连接队列（ <code>SYN</code> 队列）：接收到一个 <code>SYN</code> 建立连接请求，处于 <code>SYN_RCVD</code> 状态；<br><br>  (2) 全连接队列（ <code>Accept</code> 队列）：已完成 <code>TCP</code> 三次握手过程，处于 <code>ESTABLISHED</code> 状态； </p>
<p>  在早期 <code>Linux</code> 内核 <code>backlog</code> 是 <code>SYN</code> 队列大小，也就是未完成的队列大小。在 <code>Linux</code> 内核 <code>2.2</code> 之后，<code>SYN</code> 队列由 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>指定； <code>backlog</code> 变成 <code>Accept</code> 队列，也就是已完成连接建立的队列长度，所以现在通常认为 <code>backlog</code> 是 <code>accept</code> 队列。但是上限值是内核参数 <code>somaxconn</code> 的大小，也就说 ** <code>Accept</code> 队列长度 &#x3D; <code>min(backlog, somaxconn)</code>**。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>状态转移</p>
<ul>
<li>当来自客户的 <code>SYN</code> 分节到达时，<code>TCP</code> 在未连接队列创建一个新项，然后响应以三次握手的第二个分节，这一项一直保留在未完成连接队列中，直到三次握手的第三个分节到达或者超时。如果到达，该项就从未完成连接队列中移到已完成连接队列的队尾。当调用 <code>accept</code> 时，已完成连接队列的队首将作为 <code>accept</code> 的返回值，如果已完成连接队列是空，那么调用 <code>accept</code> 函数的进程会进入睡眠状态。</li>
</ul>
</li>
</ul>
<h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a><code>accept</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>调用 <code>accept</code> 时，已完成连接队列的队首将作为 <code>accept</code> 的返回值，如果已完成连接队列是空，那么调用进程进入睡眠状态。成功返回客户端的已连接套接字<code>connfd</code>，失败返回 <code>-1</code>。</p>
<p><code>accpet</code> 函数返回时，表示已连接套接字 <code>connfd</code> 和服务器端的监听套接字 <code>listenfd</code> 完成了三次握手。</p>
<ul>
<li><p><em><code>EMFILE</code></em><br>  如果函数<code>accept</code>返回<code>EMFILE</code>，即文件描述符过多，怎么处理？</p>
<blockquote>
<p>先实现准备一个空闲的文件描述符 *<code>/dev/null</code>*。遇到这种情况，先关闭这个空闲的文件描述符，就可以获得一个文件描述名额，然后再<code>accept</code>就可以拿到这个连接的<code>socket</code>文件描述符，随后立即<code>close</code>，就优雅的断开了与客户端的连接，最后重新打开空闲文件，以备这种情况再次出现。</p>
</blockquote>
</li>
</ul>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a><code>close</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数表示的把该套接字标记为已关闭，然后立即返回到调用进程，该套接字描述符不能再被调用进程使用。  </p>
<ul>
<li>注意事项<ul>
<li>由于描述符是引用计数，<code>close</code> 只是减少该引用计数，只有当该引用计数为 <code>0</code> 时才会引用终止序列。</li>
<li>tcp会先将已经排队等待发送到对端的任何数据发送过去，然后再发送终止序列<code>FIN</code>。因此，调用 <code>close</code> 不是立即发送终止序列。</li>
</ul>
</li>
</ul>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shutdown</code> 解决的是 <code>close</code> 的两个限制：</p>
<ul>
<li><p><code>close</code> 把描述符计数减一，仅仅在计数变为 <code>0</code> 时才关闭套接字。<code>shutdown</code> 可以不管描述符计数就激发 <code>TCP</code> 的正常连接终止序列。</p>
</li>
<li><p><code>close</code> 终止<strong>读和写</strong>两个方向的数据传递，<code>shutdown</code> 是半关闭，可以只是关闭一个方向数据流。</p>
</li>
<li><p>参数</p>
<ul>
<li><code>how</code>:<ul>
<li><code>SHUT_RD</code>：关闭读</li>
<li><code>SHUT_WR</code>：关闭写</li>
<li><code>SHUT_RDWR</code>：关闭读写</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 抓包</title>
    <url>/2023/07/19/network/tcpdump-%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p><code>tcpdump</code> 命令行抓包工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump [ -AbdDefhHIJKlLnNOpqStuUvxX# ] [ -B buffer_size ]</span><br><span class="line">        [ -c count ] [ --count ] [ -C file_size ]</span><br><span class="line">        [ -E spi@ipaddr algo:secret,...  ]</span><br><span class="line">        [ -F file ] [ -G rotate_seconds ] [ -i interface ]</span><br><span class="line">        [ --immediate-mode ] [ -j tstamp_type ] [ -k (metadata_arg) ]</span><br><span class="line">        [ -m module ]</span><br><span class="line">        [ -M secret ] [ --number ] [ --print ]</span><br><span class="line">        [ -Q packet-metadata-filter ] [ -Q in|out|inout ]</span><br><span class="line">        [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]</span><br><span class="line">        [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]</span><br><span class="line">        [ -z postrotate-command ] [ -Z user ]</span><br><span class="line">        [ --time-stamp-precision=tstamp_precision ]</span><br><span class="line">        [ --micro ] [ --nano ]</span><br><span class="line">        [ expression ]</span><br></pre></td></tr></table></figure>
<p>需要 <code>root</code> 权限运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">sudo</span> tcpdump -i any</span></span><br><span class="line">tcpdump: data link type LINUX_SLL2</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes</span><br><span class="line">15:01:28.921972 ens33 Out IP ept.55660 &gt; 123.208.120.34.bc.googleusercontent.com.https: Flags [P.], seq 1706429942:1706429981, ack 1072465052, win 63000, length 39</span><br><span class="line">15:01:28.922423 ens33 In  IP 123.208.120.34.bc.googleusercontent.com.https &gt; ept.55660: Flags [.], ack 39, win 64240, length 0</span><br><span class="line">15:01:28.971505 lo    In  IP localhost.33425 &gt; localhost.domain: 48367+ [1au] PTR? 123.208.120.34.in-addr.arpa. (56)</span><br><span class="line">15:01:28.971785 ens33 Out IP ept.50072 &gt; _gateway.domain: 32506+ PTR? 123.208.120.34.in-addr.arpa. (45)</span><br><span class="line">15:01:28.977216 ens33 In  IP _gateway.domain &gt; ept.50072: 32506 1/0/0 PTR 123.208.120.34.bc.googleusercontent.com. (98)</span><br><span class="line">15:01:28.977492 lo    In  IP localhost.domain &gt; localhost.33425: 48367 1/0/1 PTR 123.208.120.34.bc.googleusercontent.com. (109)</span><br><span class="line">15:01:28.977796 lo    In  IP localhost.45140 &gt; localhost.domain: 38317+ [1au] PTR? 168.14.168.192.in-addr.arpa. (56)</span><br><span class="line">15:01:28.978066 ens33 Out IP ept.50288 &gt; _gateway.domain: 21988+ PTR? 168.14.168.192.in-addr.arpa. (45)</span><br></pre></td></tr></table></figure>

<p><code>-i</code> 表示指定哪一个网卡，<code>any</code> 表示任意。有哪些网卡可以用 <code>ifconfig</code> 来查看，在我的虚拟机上，<code>ifconfig</code> 输出结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.14.168  netmask 255.255.255.0  broadcast 192.168.14.255</span><br><span class="line">        inet6 fe80::a421:b6c8:4404:333d  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:cc:cd:fb  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 4548  bytes 5135525 (5.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2897  bytes 1689085 (1.6 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 5307  bytes 391240 (391.2 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5307  bytes 391240 (391.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>如果只想查看 <code>ens33</code> 网卡经过的数据包，就可以使用 <code>tcpdump -i ens33</code>来指定。</p>
<span id="more"></span>

<h1 id="过滤主机：host-选项"><a href="#过滤主机：host-选项" class="headerlink" title="过滤主机：host 选项"></a>过滤主机：<code>host</code> 选项</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any host 10.211.55.2</span><br></pre></td></tr></table></figure>

<h1 id="过滤源地址、目标地址：src、dst"><a href="#过滤源地址、目标地址：src、dst" class="headerlink" title="过滤源地址、目标地址：src、dst"></a>过滤源地址、目标地址：<code>src</code>、<code>dst</code></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any src 10.211.55.10</span><br></pre></td></tr></table></figure>
<h1 id="过滤端口：port-选项"><a href="#过滤端口：port-选项" class="headerlink" title="过滤端口：port 选项"></a>过滤端口：<code>port</code> 选项</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any port 80</span><br></pre></td></tr></table></figure>

<h1 id="过滤指定端口范围内的流量"><a href="#过滤指定端口范围内的流量" class="headerlink" title="过滤指定端口范围内的流量"></a>过滤指定端口范围内的流量</h1><p>抓取 <code>21</code> 到 <code>23</code> 区间所有端口的流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump portrange 21-23</span><br></pre></td></tr></table></figure>

<h1 id="禁用主机与端口解析：-n-与-nn-选项"><a href="#禁用主机与端口解析：-n-与-nn-选项" class="headerlink" title="禁用主机与端口解析：-n 与 -nn 选项"></a>禁用主机与端口解析：<code>-n</code> 与 <code>-nn</code> 选项</h1><h1 id="过滤协议"><a href="#过滤协议" class="headerlink" title="过滤协议"></a>过滤协议</h1><h1 id="用-ASCII-格式查看包体内容：-A-选项"><a href="#用-ASCII-格式查看包体内容：-A-选项" class="headerlink" title="用 ASCII 格式查看包体内容：-A 选项"></a>用 <code>ASCII</code> 格式查看包体内容：<code>-A</code> 选项</h1><p>与 <code>-A</code> 对应的还有一个 <code>-X</code> 命令，用来同时用 <code>HEX</code> 和 <code>ASCII</code> 显示报文内容。</p>
<h1 id="限制包大小：-s-选项"><a href="#限制包大小：-s-选项" class="headerlink" title="限制包大小：-s 选项"></a>限制包大小：<code>-s</code> 选项</h1><p>当包体很大，可以用 <code>-s</code> 选项截取部分报文内容，一般都跟 <code>-A</code> 一起使用。查看每个包体前 <code>500</code> 字节可以用下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any -nn port 80 -A -s 500</span><br></pre></td></tr></table></figure>

<p>如果想显示包体所有内容，可以加上 <code>-s 0</code></p>
<h1 id="只抓取-5-个报文：-c-选项"><a href="#只抓取-5-个报文：-c-选项" class="headerlink" title="只抓取 5 个报文： -c 选项"></a>只抓取 <code>5</code> 个报文： <code>-c</code> 选项</h1><p>使用 <code>-c number</code> 命令可以抓取 <code>number</code> 个报文后退出。在网络包交互非常频繁的服务器上抓包比较有用，可能运维人员只想抓取 <code>1000</code> 个包来分析一些网络问题，就比较有用了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any -nn port 80  -c 5</span><br></pre></td></tr></table></figure>
<h1 id="数据报文输出到文件：-w-选项"><a href="#数据报文输出到文件：-w-选项" class="headerlink" title="数据报文输出到文件：-w 选项"></a>数据报文输出到文件：<code>-w</code> 选项</h1><p><code>-w</code> 选项用来把数据报文输出到文件，比如下面的命令就是把所有 <code>80</code> 端口的数据输出到文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any port 80 -w test.pcap</span><br></pre></td></tr></table></figure>
<p>生成的 <code>pcap</code> 文件就可以用 <code>wireshark</code> 打开进行更详细的分析了</p>
<p>也可以加上 <code>-U</code> 强制立即写到本地磁盘，性能稍差</p>
<h1 id="显示绝对的序号：-S-选项"><a href="#显示绝对的序号：-S-选项" class="headerlink" title="显示绝对的序号：-S 选项"></a>显示绝对的序号：<code>-S</code> 选项</h1><p>默认情况下，<code>tcpdump</code> 显示的是从 <code>0</code> 开始的相对序号。如果想查看真正的绝对序号，可以用 <code>-S</code> 选项。</p>
<p>没有 <code>-S</code> 时的输出，<code>seq</code> 和 <code>ACK</code> 都是从 <code>0</code> 开始</p>
<h1 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h1><p><code>tcpdump</code> 真正强大的是可以用布尔运算符<code>and</code>（或<code>&amp;&amp;</code>）、<code>or</code>（或<code>||</code>）、<code>not</code>（或<code>!</code>）来组合出任意复杂的过滤器</p>
<p>抓取 <code>ip</code> 为 <code>10.211.55.10</code> 到端口 <code>3306</code> 的数据包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any host 10.211.55.10 and dst port 3306</span><br></pre></td></tr></table></figure>

<p>抓取源 <code>ip</code> 为 <code>10.211.55.10</code>，目标端口除了 <code>22</code> 以外所有的流量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any src 10.211.55.10 and not dst port 22</span><br></pre></td></tr></table></figure>
<h2 id="复杂的分组"><a href="#复杂的分组" class="headerlink" title="复杂的分组"></a>复杂的分组</h2><p>如果要抓取：来源 <code>ip</code> 为 <code>10.211.55.10</code> 且目标端口为 <code>3306</code> 或 <code>6379</code> 的包，按照前面的描述，我们会写出下面的语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any src 10.211.55.10 and (dst port 3306 or 6379)</span><br></pre></td></tr></table></figure>
<p>如果运行一下，就会发现执行报错了，因为包含了特殊字符 <code>()</code>，解决的办法是用单引号把复杂的组合条件包起来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any &#x27;src 10.211.55.10 and (dst port 3306 or 6379)&#x27;</span><br></pre></td></tr></table></figure>

<p>如果想显示所有的 <code>RST</code> 包，要如何来写 <code>tcpdump</code> 的语句呢？先来说答案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;tcp[13] &amp; 4 != 0&#x27;</span><br></pre></td></tr></table></figure>

<p>要弄懂这个语句，必须要清楚 <code>TCP</code> 首部中 <code>offset</code> 为 <code>13</code> 的字节的第 <code>3</code> 比特位就是 <code>RST</code></p>
<p><code>tcp[13]</code> 表示 <code>tcp</code> 头部中偏移量为 <code>13</code> 字节, <code>!=0</code> 表示当前 <code>bit</code> 置 <code>1</code>，即存在此标记位，跟 <code>4</code> 做与运算是因为 <code>RST</code> 在 <code>TCP</code> 的标记位的位置在第 <code>3</code> 位(<code>00000100</code>)</p>
<p>如果想过滤 <code>SYN + ACK</code> 包，那就是 <code>SYN</code> 和 <code>ACK</code> 包同时置位（<code>00010010</code>），写成 <code>tcpdump</code> 语句就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;tcp[13] &amp; 18 != 0&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="">深入理解TCP协议-从原理到实战</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确使用TCP</title>
    <url>/2023/07/24/network/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8TCP/</url>
    <content><![CDATA[<h1 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a><code>SO_REUSEADDR</code></h1><ul>
<li><code>TCP</code> 服务器能够在杀掉或崩溃后快速重启</li>
<li>也适用 <code>fork-per-connection</code> 服务器模型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="built_in">sizeof</span>(optval));</span><br></pre></td></tr></table></figure>
<h1 id="忽略-SIGPIPE"><a href="#忽略-SIGPIPE" class="headerlink" title="忽略 SIGPIPE"></a>忽略 <code>SIGPIPE</code></h1><p>程序向对方已经关闭的管道，写数据，会收到 <code>SIGPIPE</code> 信号。<code>write</code> 系统调用返回 <code>-1</code>收到 <code>errono EPIPE</code>。 <code>SIGPIPE</code> 信号默认行为终止进程。我们应该忽略 <code>SIGPIPE</code> 信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">signal</span>(SIGPIPE, SIG_IGN) == SIG_ERR) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h1 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h1><p><code>Nagle</code> 算法避免发送大量的小包，防止小包泛滥于网络，理想情况下，对于一个 <code>TCP</code> 连接而言，只允许一个未被 <code>ACK</code>的包存在于网络。</p>
<p><code>Nagle</code> 算法规则:</p>
<ul>
<li>如果包长度达到 <code>MSS</code>，则允许发送</li>
<li>如果包含 <code>FIN</code>，则允许发送</li>
<li>如果设置了 <code>TCP_NODELAY</code>，则允许发送</li>
<li>未设置 <code>TCP_CORK</code> 选项时，若所有发出去的小数据包（包长度小于<code>MSS</code>）均被确认，则允许发送</li>
<li>上述条件都未满足，但发生了超时（一般为<code>200ms</code>），则立即发送。</li>
</ul>
<p>通过设置 <code>TCP_NODELAY</code> 禁用 <code>nagle</code> 算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, IPPROTO_TCP, TCP_NODELAY, (<span class="type">char</span>*)&amp;flag, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<h1 id="正确关闭-TCP-连接"><a href="#正确关闭-TCP-连接" class="headerlink" title="正确关闭 TCP 连接"></a>正确关闭 <code>TCP</code> 连接</h1><p>如果协议栈接受缓存区中有数据，程序还没有读，直接调用 <code>close</code> 函数，<code>TCP</code> 协议栈会发送 <code>RST</code> 包，强行断开连接，如果协议栈发送缓存区还有有数据，则对方没能收到，造成数据丢失。 对于无格式的协议正确的做法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送方: send() + shutdown(WR) + read()-&gt;0 + close()</span><br><span class="line">接收方: read()-&gt;0 + 没有数据发送 + close()</span><br></pre></td></tr></table></figure>

<p>如果遇到恶意或者是有 <code>bug</code> 的 <code>client</code>，一直不 <code>close</code>，发送方一直阻塞在 <code>read</code> , 建议加一个超时机制退出程序，这是为了程序安全 <code>security</code>，不是为了数据安全 <code>safety</code> 完整性 <code>Integrity</code>。</p>
<p>依赖 <code>shutdown write</code> 会发送 <code>FIN</code>，<code>end of file</code>，更好的办法是设计协议，把数据长度包含进来，接收方可以主动判断数据是否收全。</p>
<h1 id="Socket-选项之-SO-LINGER"><a href="#Socket-选项之-SO-LINGER" class="headerlink" title="Socket 选项之 SO_LINGER"></a><code>Socket</code> 选项之 <code>SO_LINGER</code></h1>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工具 telnet、 nc、 netstat、ss</title>
    <url>/2024/03/20/network/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%20telnet%E3%80%81-nc%E3%80%81-netstat/</url>
    <content><![CDATA[<h1 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a><code>telnet</code></h1><h2 id="检查端口是否打开"><a href="#检查端口是否打开" class="headerlink" title="检查端口是否打开"></a>检查端口是否打开</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet [domainname or ip] [port]</span><br><span class="line"></span><br><span class="line">telnet 220.181.57.216 80</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a><code>netcat</code></h1><h2 id="当服务器"><a href="#当服务器" class="headerlink" title="当服务器"></a>当服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l [port]</span><br><span class="line"></span><br><span class="line">nc -l 9090</span><br></pre></td></tr></table></figure>
<h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc [host or ip] [port]</span><br><span class="line"></span><br><span class="line">nc 10.211.55.5 9090</span><br></pre></td></tr></table></figure>

<h2 id="查看远程端口是否打开"><a href="#查看远程端口是否打开" class="headerlink" title="查看远程端口是否打开"></a>查看远程端口是否打开</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -zv [host or ip] [port]</span><br></pre></td></tr></table></figure>

<p>其中 <code>-z</code> 参数表示不发送任何数据包，<code>tcp</code> 三次握手完后自动退出进程。有了 <code>-v</code> 参数则会输出更多详细信息（<code>verbose</code>）</p>
<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p><code>netstat</code> 用来显示套接字的状态。</p>
<h2 id="列出所有套接字"><a href="#列出所有套接字" class="headerlink" title="列出所有套接字"></a>列出所有套接字</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code> 命令可以输出所有的套接字，包括监听的和未监听的套接字。 示例输出：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ netstat -a</span><br><span class="line">Active Internet connections (including servers)</span><br><span class="line">Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)</span><br><span class="line">tcp4       0      0  yanghao.51628          43.134.115.68.https    ESTABLISHED</span><br><span class="line">tcp4       0      0  localhost.hydap        localhost.51627        ESTABLISHED</span><br><span class="line">tcp4       0      0  localhost.51627        localhost.hydap        ESTABLISHED</span><br><span class="line">tcp4       0      0  localhost.ddi-tcp-2    localhost.51626        ESTABLISHED</span><br><span class="line">tcp4       0      0  localhost.51626        localhost.ddi-tcp-2    ESTABLISHED</span><br></pre></td></tr></table></figure>

<h2 id="只列出-TCP-连接"><a href="#只列出-TCP-连接" class="headerlink" title="只列出 TCP 连接"></a>只列出 <code>TCP</code> 连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -at</span><br></pre></td></tr></table></figure>

<h2 id="只列出-UDP-连接"><a href="#只列出-UDP-连接" class="headerlink" title="只列出 UDP 连接"></a>只列出 <code>UDP</code> 连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -au</span><br></pre></td></tr></table></figure>
<h2 id="只列出处于监听状态的连接"><a href="#只列出处于监听状态的连接" class="headerlink" title="只列出处于监听状态的连接"></a>只列出处于监听状态的连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -l</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-l</code> 选项用来指定处于 <code>LISTEN</code> 状态的连接</li>
</ul>
<h2 id="禁用端口-和-IP-映射"><a href="#禁用端口-和-IP-映射" class="headerlink" title="禁用端口 和 IP 映射"></a>禁用端口 和 IP 映射</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ltn</span><br></pre></td></tr></table></figure>
<ul>
<li>常用端口都被映射为了名字，比如 <code>22</code> 端口输出显示为 <code>ssh</code>，<code>8080</code> 端口被映射为 <code>webcache</code>。大部分情况下，我们并不想 <code>netstat</code> 帮我们做这样的事情，可以加上 <code>-n</code> 禁用</li>
</ul>
<h2 id="显示进程"><a href="#显示进程" class="headerlink" title="显示进程"></a>显示进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ltnp</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-p</code> 命令可以显示连接归属的进程信息，在查看端口被哪个进程占用时非常有用.</li>
</ul>
<h2 id="显示所有的网卡信息"><a href="#显示所有的网卡信息" class="headerlink" title="显示所有的网卡信息"></a>显示所有的网卡信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure>

<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a><code>ss</code></h2>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt QML 核心概念基础</title>
    <url>/2024/02/26/qt/Qt-QML-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Qt-QML-简介"><a href="#Qt-QML-简介" class="headerlink" title="Qt QML 简介"></a>Qt QML 简介</h1><h2 id="QML-是什么？"><a href="#QML-是什么？" class="headerlink" title="QML 是什么？"></a>QML 是什么？</h2><ul>
<li><code>QML</code> 是声明式编程语言</li>
<li><code>QML</code> 模块 类型库</li>
<li>内置了 <code>javascript</code> 运行时环境, 提供逻辑处理： 界面逻辑，业务逻辑</li>
</ul>
<h2 id="Qt-Quick-是什么？"><a href="#Qt-Quick-是什么？" class="headerlink" title="Qt Quick 是什么？"></a>Qt Quick 是什么？</h2><p><code>Qt Quick</code> 是类型库，提供了可视化 <code>UI</code> 组件，软件开发框架，用于构建用户界面</p>
<span id="more"></span>
<h2 id="QML-应用程序"><a href="#QML-应用程序" class="headerlink" title="QML 应用程序"></a>QML 应用程序</h2><h2 id="使用-qmlscene-运行-QML-程序"><a href="#使用-qmlscene-运行-QML-程序" class="headerlink" title="使用 qmlscene 运行 QML 程序"></a>使用 qmlscene 运行 QML 程序</h2><h2 id="C-应用程序使用-QML"><a href="#C-应用程序使用-QML" class="headerlink" title="C++ 应用程序使用 QML"></a>C++ 应用程序使用 QML</h2><h3 id="使用-QML-Engine"><a href="#使用-QML-Engine" class="headerlink" title="使用 QML Engine"></a>使用 QML Engine</h3><p>只使用了 Qt Quick 框架，没有使用Qt Widgets</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQmlApplicationEngine&gt;</span></span></span><br><span class="line"></span><br><span class="line">QQmlApplicationEngine engine;</span><br><span class="line">engine.<span class="built_in">load</span>(<span class="built_in">QUrl</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;qrc:/main.qml&quot;</span>)));</span><br><span class="line"><span class="keyword">if</span> (engine.<span class="built_in">rootObjects</span>().<span class="built_in">isEmpty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用-QML-View"><a href="#使用-QML-View" class="headerlink" title="使用 QML View"></a>使用 QML View</h3><p>只使用了 Qt Quick 框架，没有使用 QWidget, QQuickView 不支持 window 作为根节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQuickView&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> QUrl <span class="title">url</span><span class="params">(QStringLiteral(<span class="string">&quot;qrc:/main.qml&quot;</span>))</span></span>;</span><br><span class="line">QQuickView* view = <span class="keyword">new</span> QQuickView;</span><br><span class="line">view-&gt;<span class="built_in">setSource</span>(url);</span><br><span class="line">view-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>
<h3 id="使用-QML-Widget"><a href="#使用-QML-Widget" class="headerlink" title="使用 QML Widget"></a>使用 QML Widget</h3><p>支持混合使用Qt Quick 框架和 Qt Widgets 框架, 不支持 window 作为根节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQuickWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line">QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line"><span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> QUrl <span class="title">url</span><span class="params">(QStringLiteral(<span class="string">&quot;qrc:/main.qml&quot;</span>))</span></span>;</span><br><span class="line">QQuickWidget *view = <span class="keyword">new</span> QQuickWidget;</span><br><span class="line">view-&gt;<span class="built_in">setSource</span>(url);</span><br><span class="line">view-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h1 id="Qt-QML-语法基础"><a href="#Qt-QML-语法基础" class="headerlink" title="Qt QML 语法基础"></a>Qt QML 语法基础</h1><h2 id="QML-术语表"><a href="#QML-术语表" class="headerlink" title="QML 术语表"></a>QML 术语表</h2><table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>QML</td>
<td>1. QML 是一种应用编程语言 2. QML模块实现了QML语言的架构和引擎</td>
</tr>
<tr>
<td>Qt Quick</td>
<td>1 基于QML实现的类型和功能的标准库 2. Qt Quick 模块实现了这些类型和功能</td>
</tr>
<tr>
<td>Type</td>
<td>1. QML 基础类型 2. QML对象类型</td>
</tr>
<tr>
<td>Basic Type</td>
<td>QML 内置类型。 int、bool、string等</td>
</tr>
<tr>
<td>Object Type</td>
<td>QML代码定义的对象类型 c++代码定义的对象类型</td>
</tr>
<tr>
<td>Object</td>
<td>对象由QML引擎创建，1. 在对象定义时实例化 2.延迟实例化</td>
</tr>
<tr>
<td>Component</td>
<td>组件是用于创建QML对象或者对象树的模板 1. QML文档加载时由QML引擎创建 2. 在QML 文档内部内联定义创建</td>
</tr>
<tr>
<td>Document</td>
<td>QML 文档包含了一些QML源代码，文档名以大写字母开头 1. 可以位于 QML 源代码文件 2. 可以位于一个文本字符串中</td>
</tr>
<tr>
<td>Property</td>
<td>一个对象可以有一个或多个属性 1. 属性名称 2.属性的值</td>
</tr>
<tr>
<td>Binding</td>
<td>属性绑定到一个javascript 表达式，任何时候属性的值由整个 javascript表达式估值决定</td>
</tr>
<tr>
<td>Signal</td>
<td>对象可以发射一个信号  其他对象可以接受并通过信号处理器处理这个信号</td>
</tr>
<tr>
<td>Signal Handler</td>
<td>信号处理</td>
</tr>
<tr>
<td>Lazy Instance</td>
<td>对象可以延迟初始化，已避免不必要的工作</td>
</tr>
</tbody></table>
<h2 id="QML-导入语句"><a href="#QML-导入语句" class="headerlink" title="QML 导入语句"></a>QML 导入语句</h2><ul>
<li>import 模块标识 主版本.次版本 as 模块名称</li>
<li>import “目录路径” as 模块名称</li>
<li>import “javascript文件名称” as 模块名称</li>
</ul>
<h2 id="QML-对象定义语句"><a href="#QML-对象定义语句" class="headerlink" title="QML 对象定义语句"></a>QML 对象定义语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象类型 &#123;</span><br><span class="line">    属性： 属性值</span><br><span class="line">    信号</span><br><span class="line">    信号处理器</span><br><span class="line">    函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QML-注释"><a href="#QML-注释" class="headerlink" title="QML 注释"></a>QML 注释</h2><p>跟 <code>C++</code> 一样，单行和多行</p>
<h1 id="QML-调试"><a href="#QML-调试" class="headerlink" title="QML 调试"></a>QML 调试</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);</span><br><span class="line">console.debug(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);</span><br><span class="line">console.info(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);</span><br><span class="line">console.warn(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);</span><br><span class="line">console.error(&quot;宽度: &quot;, width, &quot;高度: &quot;, height);</span><br></pre></td></tr></table></figure>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><strong>断言失败不影响之后的代码运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.assert(width &gt; 600, &quot;assert failed&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.time(&quot;ty&quot;);</span><br><span class="line">...</span><br><span class="line">console.timeEnd(&quot;ty&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.trace();</span><br></pre></td></tr></table></figure>
<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>统计函数执行了多少次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.count();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>QML</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Application-Layer Protocol Negotiation</title>
    <url>/2023/12/11/network/TLS/ALPN/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><code>ALPN</code>(<code>Application-Layer Protocol Negotiation</code>)应用层协议协商, 当单个服务器端口号（例如端口 <code>443</code>）上支持多个应用程序协议时，客户端和服务器需要协商用于每个连接的应用程序协议。希望在不增加客户端和服务器之间的网络往返次数的情况下完成此协商，因为每次往返都会降低最终用户的体验。</p>
<p><code>ALPN</code> 作为 <code>TSL</code>的扩展，客户端会将支持的应用程序协议列表作为 <code>TLS ClientHello</code> 消息的一部分发送给服务器，服务器选择一个协议，并将所选协议作为 <code>TLS ServerHello</code> 消息的一部分发送给客户端。因此，可以在 <code>TLS</code> 握手中完成应用协议协商，而无需添加网络往返，并且允许服务器根据需要，将不同的证书与每个应用协议相关联。</p>
<span id="more"></span>
<p>通过 <code>OpenSSL</code> 命令行工具，快速查看 <code>HTTP/2</code> 服务是否支持 <code>ALPN</code> 扩展：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl s_client -alpn h2 -servername ipinfo.io -connect ipinfo.io:443 &lt; /dev/null | grep ALPN </span><br></pre></td></tr></table></figure>
<ul>
<li>提示 <code>unknown option -alpn</code>:  <code>OpenSSL</code> 版本太低, <code>OpenSSL 1.0.2</code> 才开始支持 <code>ALPN</code> 需要升级高版本</li>
<li>结果包含 <code>ALPN protocol: h2</code>，说明服务端支持 <code>ALPN</code></li>
<li>结果包含 <code>No ALPN negotiated</code>，说明服务端不支持 <code>ALPN</code></li>
</ul>
<h1 id="Application-Layer-Protocol-Negotiation"><a href="#Application-Layer-Protocol-Negotiation" class="headerlink" title="Application-Layer Protocol Negotiation"></a><code>Application-Layer Protocol Negotiation</code></h1><h2 id="The-Application-Layer-Protocol-Negotiation-Extension"><a href="#The-Application-Layer-Protocol-Negotiation-Extension" class="headerlink" title="The Application-Layer Protocol Negotiation Extension"></a><code>The Application-Layer Protocol Negotiation Extension</code></h2><p>定义新的扩展类型（<code>application_layer_protocol_negotiation（16</code>），并且可以由客户端包括在其 <code>ClientHello</code> 消息中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    application_layer_protocol_negotiation(<span class="number">16</span>), (<span class="number">65535</span>)</span><br><span class="line">&#125; ExtensionType;</span><br></pre></td></tr></table></figure>

<p>（<code>application_layer_protocol_negotiation（16</code>）扩展的 <code>extension_data</code> 字段应包含<code>ProtocolNameList</code> 值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">opaque ProtocolName&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">8</span><span class="number">-1</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ProtocolName protocol_name_list&lt;<span class="number">2.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;</span><br><span class="line">&#125; ProtocolNameList;</span><br></pre></td></tr></table></figure>

<p><code>ProtocolNameList</code> 按优先级从高到低包含客户端发布的协议列表。 协议是由 <code>IANA</code> 注册的不透明非空字节串命名的。不能包含空字符串，并且不能截断字节字符串。</p>
<p>接收到包含 <code>application_layer_protocol_negotiation</code> 扩展名的 <code>ClientHello</code> 的服务器可以向客户端返回合适的协议选择作为响应。服务器将忽略它无法识别的任何协议名称。一个新的 <code>ServerHello</code> 扩展类型(<code>application_layer_protocol_negotiation(16)</code>) 可以在 <code>ServerHello</code> 消息扩展中返回给客户端。(<code>application_layer_protocol_negotiation(16)</code>) 扩展名的 <code>extension_data</code> 字段的结构与上述针对客户端 <code>extension_data</code> 的描述相同，只是 <code>ProtocolNameList</code> 必须包含一个 <code>ProtocolName</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client                                              Server</span><br><span class="line">ClientHello                     --------&gt;       ServerHello</span><br><span class="line">  (ALPN extension &amp;                               (ALPN extension &amp;</span><br><span class="line">   list of protocols)                              selected protocol)</span><br><span class="line">                                                Certificate*</span><br><span class="line">                                                ServerKeyExchange*</span><br><span class="line">                                                CertificateRequest*</span><br><span class="line">                                &lt;--------       ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                        --------&gt;</span><br><span class="line">                                                [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------       Finished</span><br><span class="line">Application Data                &lt;-------&gt;       Application Data</span><br></pre></td></tr></table></figure>

<h2 id="Protocol-Selection"><a href="#Protocol-Selection" class="headerlink" title="Protocol Selection"></a>Protocol Selection</h2><p>期望服务器将具有优先级支持的协议列表，并且仅在客户端支持的情况下才选择协议。在这种情况下，服务器应该选择它所支持的，并且也是由客户端发布的最优先的协议。如果服务器不支持客户端传过来的协议，则服务器应以 <code>&quot;no_application_protocol&quot;</code> <code>alert</code> 错误回应。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    no_application_protocol(<span class="number">120</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure>

<h2 id="Wireshark-抓包"><a href="#Wireshark-抓包" class="headerlink" title="Wireshark 抓包"></a><code>Wireshark</code> 抓包</h2><p>在 <code>TLS1.3</code> 中:</p>
<ul>
<li><p><code>ClientHello</code>消息:<br><img src="/images/alpn_client_hello_tls1_3.png" alt="ClientHello"></p>
</li>
<li><p><code>ServerHello</code>消息:<br><img src="/images/alpn_server_hello_tls1_3.png" alt="ServerHello"></p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7301">Application-Layer Protocol Negotiation Extension</a></li>
</ul>
]]></content>
      <tags>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 之 焦点处理</title>
    <url>/2023/02/15/qt/Qt-%E4%B9%8B-%E7%84%A6%E7%82%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h1><p>当焦点从一个 <code>widget</code> 移动到另一个 <code>widget</code> 时，会触发 <code>QFocusEvent</code> 事件，这个事件会被发送给原焦点窗口和当前焦点窗口，原焦点窗口执行 <code>focusOutEvent()</code> ，新焦点窗口执行 <code>focusInEvent()</code>。 相关函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusInEvent</span><span class="params">(QFocusEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusOutEvent</span><span class="params">(QFocusEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="焦点策略"><a href="#焦点策略" class="headerlink" title="焦点策略"></a>焦点策略</h1><p>只有<strong>可获取焦点</strong>的窗口，才有机会成为焦点窗口。比如<code>QWidget</code> 默认策略是 <code>Qt::NoFocus</code> 所以 QWidget 默认不获取焦点。Qt提供了如下接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocusPolicy</span><span class="params">(Qt::FocusPolicy policy)</span></span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="enum-Qt-FocusPolicy"><a href="#enum-Qt-FocusPolicy" class="headerlink" title="enum Qt::FocusPolicy"></a>enum Qt::FocusPolicy</h2><table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt::TabFocus</td>
<td align="left">0x1</td>
<td align="left">the widget accepts focus by tabbing.</td>
</tr>
<tr>
<td align="left">Qt::ClickFocus</td>
<td align="left">0x2</td>
<td align="left">the widget accepts focus by clicking.</td>
</tr>
<tr>
<td align="left">Qt::StrongFocus</td>
<td align="left">TabFocus &#124; ClickFocus &#124; 0x8</td>
<td align="left">the widget accepts focus by both tabbing and clicking. On macOS this will also be indicate that the widget accepts tab focus when in ‘Text&#x2F;List focus mode’.</td>
</tr>
<tr>
<td align="left">Qt::WheelFocus</td>
<td align="left">StrongFocus &#124; 0x4</td>
<td align="left">like Qt::StrongFocus plus the widget accepts focus by using the mouse wheel.</td>
</tr>
<tr>
<td align="left">Qt::NoFocus</td>
<td align="left">0</td>
<td align="left">the widget does not accept focus.</td>
</tr>
</tbody></table>
<h1 id="焦点原因"><a href="#焦点原因" class="headerlink" title="焦点原因"></a>焦点原因</h1><h3 id="Qt-FocusReason"><a href="#Qt-FocusReason" class="headerlink" title="Qt::FocusReason"></a>Qt::FocusReason</h3><table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt::MouseFocusReason</td>
<td align="left">0</td>
<td align="left">A mouse action occurred.</td>
</tr>
<tr>
<td align="left">Qt::TabFocusReason</td>
<td align="left">1</td>
<td align="left">The Tab key was pressed.</td>
</tr>
<tr>
<td align="left">Qt::BacktabFocusReason</td>
<td align="left">2</td>
<td align="left">A Backtab occurred. The input for this may include the Shift or Control keys; e.g. Shift+Tab.</td>
</tr>
<tr>
<td align="left">Qt::ActiveWindowFocusReason</td>
<td align="left">3</td>
<td align="left">The window system made this window either active or inactive.</td>
</tr>
<tr>
<td align="left">Qt::PopupFocusReason</td>
<td align="left">4</td>
<td align="left">The application opened&#x2F;closed a pop-up that grabbed&#x2F;released the keyboard focus.</td>
</tr>
<tr>
<td align="left">Qt::ShortcutFocusReason</td>
<td align="left">5</td>
<td align="left">The user typed a label’s buddy shortcut</td>
</tr>
<tr>
<td align="left">Qt::MenuBarFocusReason</td>
<td align="left">6</td>
<td align="left">The menu bar took focus.</td>
</tr>
<tr>
<td align="left">Qt::OtherFocusReason</td>
<td align="left">7</td>
<td align="left">Another reason, usually application-specific.</td>
</tr>
</tbody></table>
<h1 id="焦点信号"><a href="#焦点信号" class="headerlink" title="焦点信号"></a>焦点信号</h1><p><code>QApplication</code> 的信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">focusChanged</span><span class="params">(QWidget *old, QWidget *now)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="焦点次序"><a href="#焦点次序" class="headerlink" title="焦点次序"></a>焦点次序</h1><p>相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回此部件焦点链中的下一个部件</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::nextInFocusChain</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">// 返回此部件焦点链中的前一个部件</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::previousInFocusChain</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将焦点顺序中的部件 second 放置在部件 first 之后</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setTabOrder</span><span class="params">(QWidget *, QWidget *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过按 <code>Tab</code> 或者 <code>Shift+Tab</code>，可以实现焦点在各个窗口之间循环移动。</p>
<ul>
<li><p>点击 <code>Tab</code> 键，焦点向后查找，直至找到第一个 <code>FocusPolicy</code> 大于等于 <code>TabFocus</code> 的窗口，并设置该窗口为焦点窗口;</p>
</li>
<li><p>点击 <code>Shift+Tab</code> ，焦点向前查找，直至找到第一个 <code>FocusPolicy</code>  大于等于 <code>TabFocus</code> 的窗口，并设置该窗口为焦点窗口;</p>
</li>
</ul>
<p>默认情况下, 先加入的 <code>QWidget</code> 焦点顺序越靠前。可以通过 <code>setTabOrder</code> 调整顺序.</p>
<p>比如，若默认的焦点链顺序为 <code>a-b-c-d</code> ，则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTabOrder(d,c); //改变后焦点链的顺序为 a-b-d-c</span><br><span class="line">setTabOrder(b,a); //改变后焦点链的顺序为 b-a-d-c</span><br></pre></td></tr></table></figure>

<h1 id="焦点切换"><a href="#焦点切换" class="headerlink" title="焦点切换"></a>焦点切换</h1><p>相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于focusNextPrevChild(true)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusNextChild</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 等同于focusNextPrevChild(false)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusPreviousChild</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// next==true：设置焦点链中下个`FocusPolicy`为`TabFocus`的窗口为焦点窗口</span></span><br><span class="line"><span class="comment">// next==false：设置焦点链中前一个`FocusPolicy`为`TabFocus`的窗口为焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::focusNextPrevChild</span><span class="params">(<span class="type">bool</span> next)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前窗口为焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocus</span><span class="params">(Qt::FocusReason reason)</span></span>;</span><br><span class="line"><span class="comment">// 取消焦点窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::clearFocus</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="焦点代理"><a href="#焦点代理" class="headerlink" title="焦点代理"></a>焦点代理</h1><p>代为接收焦点事件。比如，<code>Widget A</code> 是 <code>Widget B</code> 的焦点代理，则当 <code>B</code> 获得焦点时，实际获得并处理焦点的是 <code>A</code>。相关接口如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回该窗口的焦点代理</span></span><br><span class="line"><span class="function">QWidget* <span class="title">QWidget::focusProxy</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="comment">//设置该窗口的焦点代理为w</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::setFocusProxy</span><span class="params">(QWidget* w)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>焦点</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS False Start</title>
    <url>/2023/12/11/network/TLS/TLS-False-Start/</url>
    <content><![CDATA[<h1 id="什么是TLS-False-Start？"><a href="#什么是TLS-False-Start？" class="headerlink" title="什么是TLS False Start？"></a>什么是TLS False Start？</h1><p>在 <code>TLS</code> 协商第二阶段，浏览器发送 <code>ChangeCipherSpec</code> 和 <code>Finished</code> 后，立即发送加密的应用层数据，而无需等待服务器端的确认。</p>
<h1 id="如何启用TLS-False-Start？"><a href="#如何启用TLS-False-Start？" class="headerlink" title="如何启用TLS False Start？"></a>如何启用TLS False Start？</h1><ul>
<li>需要支持 <code>NPN/ALPN</code></li>
<li>服务器端配置支持前向安全(<code>Forward Secrecy</code>)</li>
</ul>
]]></content>
      <tags>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
</search>
