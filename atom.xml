<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Symbol Crash</title>
  
  <subtitle>不学无术</subtitle>
  <link href="https://yngty.github.io/atom.xml" rel="self"/>
  
  <link href="https://yngty.github.io/"/>
  <updated>2023-03-10T14:36:53.204Z</updated>
  <id>https://yngty.github.io/</id>
  
  <author>
    <name>yngty</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective-STL 21：总是让比较函数在等值情况下返回 false</title>
    <link href="https://yngty.github.io/2023/03/10/effective-stl/effective-stl-21/"/>
    <id>https://yngty.github.io/2023/03/10/effective-stl/effective-stl-21/</id>
    <published>2023-03-10T21:05:20.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 21: Always have comparison functions return false for equal values.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;严格弱序-strict-weak-ordering&quot;&gt;&lt;a href=&quot;#严格弱序-strict-weak-ordering&quot; class=&quot;headerlink&quot; title=&quot;严格弱序( strict weak ordering )&quot;&gt;&lt;/a&gt;严格弱序( &lt;code&gt;strict weak ordering&lt;/code&gt; )&lt;/h1&gt;&lt;p&gt;先补充下严格弱序的概念: 对两个变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x &amp;gt; y&lt;/code&gt; 等同于 &lt;code&gt;y &amp;lt; x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x == y&lt;/code&gt; 等同于 &lt;code&gt;!(x &amp;lt; y) &amp;amp;&amp;amp; !(x &amp;gt; y)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想严格弱序，就需要遵循如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个变量值必须等于其本身（&lt;code&gt;irreflexivity&lt;/code&gt;）：&lt;code&gt;x &amp;lt; x&lt;/code&gt; 永远不能为 &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不对称性（&lt;code&gt;asymmetry&lt;/code&gt;）：如果 &lt;code&gt;x &amp;lt; y&lt;/code&gt;，那么 &lt;code&gt;y &amp;lt; x&lt;/code&gt; 就不能为 &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有序性必须可传递性：如果 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 并且 &lt;code&gt;y &amp;lt; z&lt;/code&gt;，那么 &lt;code&gt;x &amp;lt; z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;值相同必须具有可传递性：如果 &lt;code&gt;x == y&lt;/code&gt; 并且 &lt;code&gt;y == z&lt;/code&gt;，那么 &lt;code&gt;x == z&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Effective-STL" scheme="https://yngty.github.io/categories/Effective-STL/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-STL" scheme="https://yngty.github.io/tags/Effective-STL/"/>
    
    <category term="stl" scheme="https://yngty.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>Effective-STL 9：慎重选择删除元素的方法</title>
    <link href="https://yngty.github.io/2023/02/16/effective-stl/effective-stl-9/"/>
    <id>https://yngty.github.io/2023/02/16/effective-stl/effective-stl-9/</id>
    <published>2023-02-16T15:11:25.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item9. Choose carefully among easing options.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、删除特定值&quot;&gt;&lt;a href=&quot;#一、删除特定值&quot; class=&quot;headerlink&quot; title=&quot;一、删除特定值&quot;&gt;&lt;/a&gt;一、删除特定值&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;code&gt;vector&lt;/code&gt;、 &lt;code&gt;string&lt;/code&gt; 或 &lt;code&gt;deque&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 最好使用 &lt;code&gt;erase-remove&lt;/code&gt;习惯用法: &lt;/p&gt;
 &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c.&lt;span class=&quot;built_in&quot;&gt;erase&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;remove&lt;/span&gt;(c.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), c.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(), &lt;span class=&quot;number&quot;&gt;1963&lt;/span&gt;, c.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;code&gt;list&lt;/code&gt; 容器&lt;/p&gt;
&lt;p&gt; 直接使用 &lt;code&gt;remove&lt;/code&gt; 方法:&lt;/p&gt;
 &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c.&lt;span class=&quot;built_in&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1963&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于标准关联容器&lt;/p&gt;
&lt;p&gt; 直接使用 &lt;code&gt;erase&lt;/code&gt; 方法:&lt;/p&gt;
 &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c.&lt;span class=&quot;built_in&quot;&gt;erase&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1963&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Effective-STL" scheme="https://yngty.github.io/categories/Effective-STL/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-STL" scheme="https://yngty.github.io/tags/Effective-STL/"/>
    
    <category term="stl" scheme="https://yngty.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>Disk Arbitration</title>
    <link href="https://yngty.github.io/2023/02/16/macos/Disk-Arbitration/"/>
    <id>https://yngty.github.io/2023/02/16/macos/Disk-Arbitration/</id>
    <published>2023-02-16T13:38:07.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Disk Arbitration framework&lt;/code&gt; 是一个基于 &lt;code&gt;Core Foundation&lt;/code&gt; 的低级框架。会在磁盘出现和消失时通知您的应用程序，并让您的应用程序影响该过程。借助 &lt;code&gt;Disk Arbitration&lt;/code&gt;，我们可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检测何时出现新磁盘&lt;/li&gt;
&lt;li&gt;阻止挂载&lt;/li&gt;
&lt;li&gt;使用不同的标志或在不同的安装点上安装卷&lt;/li&gt;
&lt;li&gt;卸载卷&lt;/li&gt;
&lt;li&gt;观察卷的变化&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MacOS" scheme="https://yngty.github.io/categories/MacOS/"/>
    
    
    <category term="MacOS" scheme="https://yngty.github.io/tags/MacOS/"/>
    
    <category term="Disk" scheme="https://yngty.github.io/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>Qt 之 焦点处理</title>
    <link href="https://yngty.github.io/2023/02/15/qt/Qt-%E4%B9%8B-%E7%84%A6%E7%82%B9%E5%A4%84%E7%90%86/"/>
    <id>https://yngty.github.io/2023/02/15/qt/Qt-%E4%B9%8B-%E7%84%A6%E7%82%B9%E5%A4%84%E7%90%86/</id>
    <published>2023-02-15T17:08:09.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;焦点事件&quot;&gt;&lt;a href=&quot;#焦点事件&quot; class=&quot;headerlink&quot; title=&quot;焦点事件&quot;&gt;&lt;/a&gt;焦点事件&lt;/h1&gt;&lt;p&gt;当焦点从一个 &lt;code&gt;widget&lt;/code&gt; 移动到另一个 &lt;code&gt;widget&lt;/code&gt; 时，会触发 &lt;code&gt;QFocusEvent&lt;/code&gt; 事件，这个事件会被发送给原焦点窗口和当前焦点窗口，原焦点窗口执行 &lt;code&gt;focusOutEvent()&lt;/code&gt; ，新焦点窗口执行 &lt;code&gt;focusInEvent()&lt;/code&gt;。 相关函数如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;focusInEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QFocusEvent *event)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;focusOutEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QFocusEvent *event)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;焦点策略&quot;&gt;&lt;a href=&quot;#焦点策略&quot; class=&quot;headerlink&quot; title=&quot;焦点策略&quot;&gt;&lt;/a&gt;焦点策略&lt;/h1&gt;&lt;p&gt;只有&lt;strong&gt;可获取焦点&lt;/strong&gt;的窗口，才有机会成为焦点窗口。比如&lt;code&gt;QWidget&lt;/code&gt; 默认策略是 &lt;code&gt;Qt::NoFocus&lt;/code&gt; 所以 QWidget 默认不获取焦点。Qt提供了如下接口：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;QWidget::setFocusPolicy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Qt::FocusPolicy policy)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://yngty.github.io/categories/Qt/"/>
    
    
    <category term="焦点" scheme="https://yngty.github.io/tags/%E7%84%A6%E7%82%B9/"/>
    
    <category term="Qt" scheme="https://yngty.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>std::make_shared vs. new</title>
    <link href="https://yngty.github.io/2023/02/07/c++/std-make-shared-vs-new/"/>
    <id>https://yngty.github.io/2023/02/07/c++/std-make-shared-vs-new/</id>
    <published>2023-02-07T10:30:24.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;headerlink&quot; title=&quot;内存分配&quot;&gt;&lt;/a&gt;内存分配&lt;/h1&gt;&lt;p&gt;&lt;code&gt;std::make_shared&lt;/code&gt; 执行&lt;strong&gt;一次&lt;/strong&gt;堆分配，而调用&lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数执行&lt;strong&gt;两次&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在一个典型的实现中 &lt;code&gt;std::shared_ptr&lt;/code&gt; 管理两个实体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制块（存储元数据，如引用计数、类型擦除删除器等）&lt;/li&gt;
&lt;li&gt;被管理的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制块是一个动态分配的对象，它包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向托管对象的指针或托管对象本身；&lt;/li&gt;
&lt;li&gt;删除器 (类型擦除)&lt;/li&gt;
&lt;li&gt;分配器 (类型擦除)&lt;/li&gt;
&lt;li&gt;拥有被管理对象的 &lt;code&gt;shared_ptr&lt;/code&gt;的数量&lt;/li&gt;
&lt;li&gt;引用托管对象的 &lt;code&gt;weak_ptr&lt;/code&gt; 的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;std::make_shared&lt;/code&gt;执行一次堆分配，计算控制块和数据所需的总空间。在另一种情况 &lt;code&gt;std::shared_ptr&amp;lt;Obj&amp;gt;(new Obj(&amp;quot;foo&amp;quot;))&lt;/code&gt;下执行两次, &lt;code&gt;new Obj(&amp;quot;foo&amp;quot;)&lt;/code&gt;为托管数据调用堆分配，&lt;code&gt;std::shared_ptr&lt;/code&gt;构造函数为控制块执行另一个堆分配。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://yngty.github.io/categories/C-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="智能指针" scheme="https://yngty.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>在MacOS平台上符号化崩溃报告</title>
    <link href="https://yngty.github.io/2022/07/26/macos/%E5%9C%A8MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A/"/>
    <id>https://yngty.github.io/2022/07/26/macos/%E5%9C%A8MacOS%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A/</id>
    <published>2022-07-26T15:41:02.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;dSYM&quot;&gt;&lt;a href=&quot;#dSYM&quot; class=&quot;headerlink&quot; title=&quot;.dSYM&quot;&gt;&lt;/a&gt;&lt;code&gt;.dSYM&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;&lt;code&gt;.dSYM&lt;/code&gt; (&lt;code&gt;debugging SYMbols&lt;/code&gt;) 又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的 &lt;code&gt;DWARF&lt;/code&gt;（&lt;code&gt;Debugging With Attributed Record Formats&lt;/code&gt;），其在.xcarchive目录中的层次结构为：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.xcarchive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--dSYMs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |--Your.app.dSYM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    |--Contents&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      |--Resources&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        |--DWARF&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="MacOS" scheme="https://yngty.github.io/categories/MacOS/"/>
    
    
    <category term="MacOS" scheme="https://yngty.github.io/tags/MacOS/"/>
    
    <category term="Creash" scheme="https://yngty.github.io/tags/Creash/"/>
    
  </entry>
  
  <entry>
    <title>解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY</title>
    <link href="https://yngty.github.io/2022/04/19/linux/NO_PUBKEY/"/>
    <id>https://yngty.github.io/2022/04/19/linux/NO_PUBKEY/</id>
    <published>2022-04-19T22:41:41.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://yngty.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://yngty.github.io/tags/Linux/"/>
    
    <category term="apt" scheme="https://yngty.github.io/tags/apt/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 28：避免返回 handles 指向对象内部成分</title>
    <link href="https://yngty.github.io/2022/04/16/effecitve-cpp/effective-cpp-28/"/>
    <id>https://yngty.github.io/2022/04/16/effecitve-cpp/effective-cpp-28/</id>
    <published>2022-04-16T21:42:47.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item28: Avoid returning “handles” to object internals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;避免返回 &lt;code&gt;handles&lt;/code&gt; (包括 &lt;code&gt;references&lt;/code&gt; 、指针、迭代器)指向对象内部。&lt;/p&gt;</summary>
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 26：尽可能推迟变量的定义</title>
    <link href="https://yngty.github.io/2022/04/15/effecitve-cpp/effective-cpp-26/"/>
    <id>https://yngty.github.io/2022/04/15/effecitve-cpp/effective-cpp-26/</id>
    <published>2022-04-15T10:38:20.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 26:Postpone variable definitions as long as possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推迟变量的定义有两个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改善程序效率，减少无用的构造和析构。&lt;/li&gt;
&lt;li&gt;增加程序流程清晰度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这条规则看似简单，但存在流程控制语句的时候容易疏忽。如：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;string &lt;span class=&quot;title&quot;&gt;encryptPassword&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; string&amp;amp; password)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    string encrypted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (password.&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;() &amp;lt; MinimumPasswordLength) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;logic_error&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Password is too short&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    encrypted = password;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;encrypt&lt;/span&gt;(encrypted);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; encrypted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 25：设计一个不抛异常的 swap 函数</title>
    <link href="https://yngty.github.io/2022/04/09/effecitve-cpp/effective-cpp-25/"/>
    <id>https://yngty.github.io/2022/04/09/effecitve-cpp/effective-cpp-25/</id>
    <published>2022-04-09T23:12:46.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 25: Consider support for a non-throwing swap.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;swap&lt;/code&gt; 函数能置换两对象值，功能很重要!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异常安全性编程&lt;/li&gt;
&lt;li&gt;处理自我赋值可能性：&lt;a href=&quot;/2021/11/01/effecitve-cpp/effective-cpp-11/&quot; title=&quot;Effective C++ 11：赋值运算符需要考虑自我赋值问题&quot;&gt;赋值运算符需要考虑自我赋值问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;std&lt;/code&gt; 的缺省基本实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T&amp;amp; a, T&amp;amp; b)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a = b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 24：若所有参数皆需类型转换，请采用非成员函数</title>
    <link href="https://yngty.github.io/2022/04/09/effecitve-cpp/effective-cpp-24/"/>
    <id>https://yngty.github.io/2022/04/09/effecitve-cpp/effective-cpp-24/</id>
    <published>2022-04-09T22:39:25.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 24: Declare non-member functions when type conversions should apply all parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;令 &lt;code&gt;classes&lt;/code&gt; 支持隐式转换通常是糟糕的设计，但也有例外，最常见的是在建立数值类型时。 比如设计一个有理数 &lt;code&gt;class&lt;/code&gt; 允许整数隐式转换。&lt;/p&gt;</summary>
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 23：用非成员函数、非友元函数替换成员函数</title>
    <link href="https://yngty.github.io/2022/04/09/effecitve-cpp/effective-cpp-23/"/>
    <id>https://yngty.github.io/2022/04/09/effecitve-cpp/effective-cpp-23/</id>
    <published>2022-04-09T22:30:35.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 23: Prefer non-member non-friend functions to member</summary>
        
      
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 22：将成员变量声明为private</title>
    <link href="https://yngty.github.io/2022/03/23/effecitve-cpp/effective-cpp-22/"/>
    <id>https://yngty.github.io/2022/03/23/effecitve-cpp/effective-cpp-22/</id>
    <published>2022-03-23T11:22:04.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 22: Declare data members</summary>
        
      
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 21：需要返回对象时，不要返回引用</title>
    <link href="https://yngty.github.io/2022/03/23/effecitve-cpp/effective-cpp-21/"/>
    <id>https://yngty.github.io/2022/03/23/effecitve-cpp/effective-cpp-21/</id>
    <published>2022-03-23T10:43:36.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 21: Don’t to return a reference when you must return an object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Item 20 中提到，多数情况下传引用比传值更好。但不要无脑追求这一点，一定不要返回空引用或指针。&lt;/p&gt;</summary>
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 20：传常量引用比传值更好</title>
    <link href="https://yngty.github.io/2022/03/23/effecitve-cpp/effective-cpp-20/"/>
    <id>https://yngty.github.io/2022/03/23/effecitve-cpp/effective-cpp-20/</id>
    <published>2022-03-23T10:29:27.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 20: Prefer pass-by-reference-to-const to pass-by-value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缺省情况下&lt;code&gt;C++&lt;/code&gt; 用传值得方式(一个继承自&lt;code&gt;C&lt;/code&gt;的方式)传递对象至(或来自)函数。除非你另外指定，否则函数参数都是以实际实参的复件(副本)为初值，而调用端所获得的亦是函数返回值的一个复件。这些复件(副本)系由对象的&lt;code&gt;copy&lt;/code&gt;构造函数产出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量以传常量引用替换传值前者通常比较高效，并可避免切割问题 (&lt;code&gt;slicing problem&lt;/code&gt;)，但是内置类型和 &lt;code&gt;STL&lt;/code&gt; 迭代器，还是传值更加合适。&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>文件MIME类型</title>
    <link href="https://yngty.github.io/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yngty.github.io/2021/11/23/linux/%E6%96%87%E4%BB%B6MIME%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-11-23T20:14:31.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是-MIME-类型？&quot;&gt;&lt;a href=&quot;#什么是-MIME-类型？&quot; class=&quot;headerlink&quot; title=&quot;什么是 MIME 类型？&quot;&gt;&lt;/a&gt;什么是 MIME 类型？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;MIME&lt;/code&gt;（多用途 &lt;code&gt;Internet&lt;/code&gt; 邮件扩展）的类型来识别文件格式。 &lt;code&gt;MIME&lt;/code&gt; 类型构成了 &lt;code&gt;Internet&lt;/code&gt; 上对文件类型进行分类的标准方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MIME Type&lt;/code&gt;是用于描述文件的类型的一种表述方法，其将文件划分为多种类型，方便对其进行统一的管理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MIME Type&lt;/code&gt;指定了文件的类型名称、描述、图标信息，同时通过与.desktop应用程序描述文件整合，指定了文件的打开方式。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://yngty.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://yngty.github.io/tags/Linux/"/>
    
    <category term="mime" scheme="https://yngty.github.io/tags/mime/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之tr</title>
    <link href="https://yngty.github.io/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/"/>
    <id>https://yngty.github.io/2021/11/17/linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Btr/</id>
    <published>2021-11-17T11:08:28.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 中 &lt;code&gt;tr&lt;/code&gt; 命令用于转换或删除文件中的字符。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;tr&lt;/span&gt; [OPTION] SET1 [SET2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;选项&quot;&gt;&lt;a href=&quot;#选项&quot; class=&quot;headerlink&quot; title=&quot;选项&quot;&gt;&lt;/a&gt;选项&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-c, --complerment：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-d, --delete：删除所有属于第一字符集的字符；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-s, --squeeze-repeats：把连续重复的字符以单独一个字符表示；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t, --truncate-set1：先删除第一字符集较第二字符集多出的字符;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://yngty.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://yngty.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 19：设计 class 犹如设计 type</title>
    <link href="https://yngty.github.io/2021/11/11/effecitve-cpp/effective-cpp-19/"/>
    <id>https://yngty.github.io/2021/11/11/effecitve-cpp/effective-cpp-19/</id>
    <published>2021-11-11T16:36:55.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 19: Teat class design as type</summary>
        
      
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 malloc 和 new 的区别</title>
    <link href="https://yngty.github.io/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://yngty.github.io/2021/11/08/c++/C-%E4%B8%ADmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-11-08T22:44:44.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;特征&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;new&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;malloc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td</summary>
        
      
    
    
    
    <category term="C/C++" scheme="https://yngty.github.io/categories/C-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 18：让接口容易被正确使用，不易被误用</title>
    <link href="https://yngty.github.io/2021/11/08/effecitve-cpp/effective-cpp-18/"/>
    <id>https://yngty.github.io/2021/11/08/effecitve-cpp/effective-cpp-18/</id>
    <published>2021-11-08T15:48:13.000Z</published>
    <updated>2023-03-10T14:36:53.204Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Item 18: Make interfaces easy to use correctly and hard to use</summary>
        
      
    
    
    
    <category term="Effective-C++" scheme="https://yngty.github.io/categories/Effective-C/"/>
    
    
    <category term="C++" scheme="https://yngty.github.io/tags/C/"/>
    
    <category term="Effective-C++" scheme="https://yngty.github.io/tags/Effective-C/"/>
    
  </entry>
  
</feed>
