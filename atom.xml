<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Symbol Crash</title>
  
  <subtitle>不学无术</subtitle>
  <link href="https://yngty.github.io/atom.xml" rel="self"/>
  
  <link href="https://yngty.github.io/"/>
  <updated>2025-05-19T02:58:05.399Z</updated>
  <id>https://yngty.github.io/</id>
  
  <author>
    <name>yngty</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解TUN与TAP：虚拟网络设备的原理与应用</title>
    <link href="https://yngty.github.io/2025/05/09/network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TUN%E4%B8%8ETAP%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://yngty.github.io/2025/05/09/network/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TUN%E4%B8%8ETAP%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2025-05-09T17:20:28.000Z</published>
    <updated>2025-05-19T02:58:05.399Z</updated>
    
    
    <summary type="html">&lt;p&gt;在构建虚拟网络或实现VPN时，&lt;strong&gt;TUN&lt;/strong&gt;和&lt;strong&gt;TAP&lt;/strong&gt;是两个常被提及的虚拟网络设备。它们看似相似，却在网络协议栈的不同层级发挥作用。本文将深入解析它们的工作原理、应用场景及配置方法。&lt;/p&gt;</summary>
    
    
    
    <category term="网络虚拟化" scheme="https://yngty.github.io/categories/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="TUN" scheme="https://yngty.github.io/tags/TUN/"/>
    
    <category term="TAP" scheme="https://yngty.github.io/tags/TAP/"/>
    
    <category term="VPN" scheme="https://yngty.github.io/tags/VPN/"/>
    
    <category term="虚拟机" scheme="https://yngty.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SOCKS5 代理协议详解</title>
    <link href="https://yngty.github.io/2025/05/07/network/SOCKS5-%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yngty.github.io/2025/05/07/network/SOCKS5-%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-05-07T14:49:41.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;SOCKS5-代理协议详解&quot;&gt;&lt;a href=&quot;#SOCKS5-代理协议详解&quot; class=&quot;headerlink&quot; title=&quot;SOCKS5 代理协议详解&quot;&gt;&lt;/a&gt;SOCKS5 代理协议详解&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;SOCKS5&lt;/strong&gt; 是一种网络代理协议，是 &lt;code&gt;SOCKS&lt;/code&gt; 协议的第五个版本, 它不仅支持传统的 &lt;code&gt;TCP&lt;/code&gt; 连接，还增加了对 &lt;code&gt;UDP&lt;/code&gt; 和多种认证方法的支持。&lt;code&gt;SOCKS5&lt;/code&gt; 工作在 &lt;code&gt;OSI&lt;/code&gt; 模型的&lt;strong&gt;会话层&lt;/strong&gt;，广泛用于突破网络限制、隐藏客户端真实 &lt;code&gt;IP&lt;/code&gt; 等场景。本文深入解析其协议字段、工作模式及认证机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="SOCKS5" scheme="https://yngty.github.io/tags/SOCKS5/"/>
    
  </entry>
  
  <entry>
    <title>深入了解FTP协议：原理、命令与数据连接</title>
    <link href="https://yngty.github.io/2025/05/07/network/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3FTP%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5/"/>
    <id>https://yngty.github.io/2025/05/07/network/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3FTP%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5/</id>
    <published>2025-05-07T14:41:21.000Z</published>
    <updated>2025-05-19T02:58:05.399Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;深入了解FTP协议：原理、命令与数据连接&quot;&gt;&lt;a href=&quot;#深入了解FTP协议：原理、命令与数据连接&quot; class=&quot;headerlink&quot; title=&quot;深入了解FTP协议：原理、命令与数据连接&quot;&gt;&lt;/a&gt;深入了解FTP协议：原理、命令与数据连接&lt;/h1&gt;&lt;h2 id=&quot;什么是FTP协议？&quot;&gt;&lt;a href=&quot;#什么是FTP协议？&quot; class=&quot;headerlink&quot; title=&quot;什么是FTP协议？&quot;&gt;&lt;/a&gt;什么是FTP协议？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;FTP（File Transfer Protocol）&lt;/code&gt; 是最常用的网络文件传输协议之一，允许计算机之间通过网络传输文件。它是一个基于客户端-服务器模型的协议，通过 &lt;code&gt;TCP&lt;/code&gt; 连接进行通信，通常运行在端口 &lt;code&gt;21&lt;/code&gt;。FTP主要支持两种模式：&lt;strong&gt;主动模式&lt;/strong&gt;和&lt;strong&gt;被动模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在本文中，我们将深入探讨 &lt;code&gt;FTP&lt;/code&gt; 协议的工作原理、常用命令、数据连接的处理方式以及两种模式的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="FTP" scheme="https://yngty.github.io/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 HKDF：HMAC 密钥派生函数</title>
    <link href="https://yngty.github.io/2025/04/18/cryptographic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-HKDF%EF%BC%9AHMAC-%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0/"/>
    <id>https://yngty.github.io/2025/04/18/cryptographic/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-HKDF%EF%BC%9AHMAC-%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0/</id>
    <published>2025-04-18T10:33:24.000Z</published>
    <updated>2025-05-19T02:58:05.395Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在加密领域，密钥派生函数（&lt;code&gt;KDF&lt;/code&gt;）是通过从一个初始密钥（通常称为“种子密钥”或“主密钥”）生成多个密钥的算法。&lt;code&gt;HKDF（HMAC-based Key Derivation Function）&lt;/code&gt;是一种基于 &lt;code&gt;HMAC&lt;/code&gt; 的密钥派生函数，它被设计用于从一个或多个输入密钥材料中生成多个安全的输出密钥。&lt;code&gt;HKDF&lt;/code&gt; 是一个简洁且具有高度安全性的 &lt;code&gt;KDF&lt;/code&gt;，广泛用于生成加密协议中的密钥（如 &lt;code&gt;TLS&lt;/code&gt;、&lt;code&gt;IPSec&lt;/code&gt; 等）。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将深入探讨 &lt;code&gt;HKDF&lt;/code&gt; 的原理、计算过程以及应用场景，帮助你更好地理解这个关键的密码学工具。&lt;/p&gt;</summary>
    
    
    
    <category term="Cryptographic Algorithms" scheme="https://yngty.github.io/categories/Cryptographic-Algorithms/"/>
    
    
    <category term="HKDF" scheme="https://yngty.github.io/tags/HKDF/"/>
    
    <category term="HMAC" scheme="https://yngty.github.io/tags/HMAC/"/>
    
  </entry>
  
  <entry>
    <title>HMAC：理解其原理和计算过程</title>
    <link href="https://yngty.github.io/2025/04/18/cryptographic/HMAC%EF%BC%9A%E7%90%86%E8%A7%A3%E5%85%B6%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
    <id>https://yngty.github.io/2025/04/18/cryptographic/HMAC%EF%BC%9A%E7%90%86%E8%A7%A3%E5%85%B6%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</id>
    <published>2025-04-18T10:26:26.000Z</published>
    <updated>2025-05-19T02:58:05.395Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;HMAC（Hash-based Message Authentication Code&lt;/strong&gt;是一种基于哈希函数的消息认证码（&lt;code&gt;MAC&lt;/code&gt;）算法，用于验证数据的完整性和真实性。它通过结合哈希算法与密钥来生成一个认证码，可以防止数据在传输过程中被篡改。&lt;code&gt;HMAC&lt;/code&gt; 广泛应用于网络协议（如 &lt;code&gt;TLS&lt;/code&gt;、&lt;code&gt;IPSec&lt;/code&gt; 等）、数字签名以及 &lt;code&gt;API&lt;/code&gt; 认证等场景中。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将深入了解 &lt;code&gt;HMAC&lt;/code&gt; 的原理，并通过具体的计算过程来说明其如何工作。&lt;/p&gt;</summary>
    
    
    
    <category term="Cryptographic Algorithms" scheme="https://yngty.github.io/categories/Cryptographic-Algorithms/"/>
    
    
    <category term="HMAC" scheme="https://yngty.github.io/tags/HMAC/"/>
    
  </entry>
  
  <entry>
    <title>TLS 1.2 与 TLS 1.3 握手流程深度解析：安全与性能的演进</title>
    <link href="https://yngty.github.io/2025/04/08/network/TLS/TLS-1-2-and-TLS-1-3-Handshake/"/>
    <id>https://yngty.github.io/2025/04/08/network/TLS/TLS-1-2-and-TLS-1-3-Handshake/</id>
    <published>2025-04-08T10:17:59.000Z</published>
    <updated>2025-05-19T02:58:05.399Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;TLS-1-2-与-TLS-1-3-握手流程深度解析：安全与性能的演进&quot;&gt;&lt;a href=&quot;#TLS-1-2-与-TLS-1-3-握手流程深度解析：安全与性能的演进&quot; class=&quot;headerlink&quot; title=&quot;TLS 1.2 与 TLS 1.3 握手流程深度解析：安全与性能的演进&quot;&gt;&lt;/a&gt;TLS 1.2 与 TLS 1.3 握手流程深度解析：安全与性能的演进&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TLS&lt;/code&gt;（传输层安全协议）是互联网加密通信的基石。从 &lt;code&gt;TLS 1.2&lt;/code&gt; 到 &lt;code&gt;TLS 1.3&lt;/code&gt;，协议在安全性和性能上实现了质的飞跃。本文将深入对比两者的握手流程，解析其设计差异，并探讨为何 &lt;code&gt;TLS 1.3&lt;/code&gt; 成为现代网络通信的首选。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="SSL/TLS" scheme="https://yngty.github.io/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>基础密码知识</title>
    <link href="https://yngty.github.io/2025/04/08/cryptographic/cryptographic_algorithms/"/>
    <id>https://yngty.github.io/2025/04/08/cryptographic/cryptographic_algorithms/</id>
    <published>2025-04-08T10:11:14.000Z</published>
    <updated>2025-05-19T02:58:05.395Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;常见加密模式&quot;&gt;&lt;a href=&quot;#常见加密模式&quot; class=&quot;headerlink&quot; title=&quot;常见加密模式&quot;&gt;&lt;/a&gt;常见加密模式&lt;/h1&gt;&lt;h2 id=&quot;为什么要分模式？&quot;&gt;&lt;a href=&quot;#为什么要分模式？&quot; class=&quot;headerlink&quot; title=&quot;为什么要分模式？&quot;&gt;&lt;/a&gt;为什么要分模式？&lt;/h2&gt;&lt;p&gt;对称加密算法（如&lt;code&gt;AES&lt;/code&gt;）只能加密&lt;strong&gt;固定长度&lt;/strong&gt;的数据块（比如 &lt;code&gt;AES&lt;/code&gt; 的块是 &lt;code&gt;128&lt;/code&gt; 位）。如果要加密一个很长的文件，就需要将文件切分成多个块，再逐个加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题来了&lt;/strong&gt;：如何让这些块之间产生关联，避免被破解？这就是&lt;strong&gt;加密模式&lt;/strong&gt;的作用！&lt;/p&gt;</summary>
    
    
    
    <category term="Cryptographic Algorithms" scheme="https://yngty.github.io/categories/Cryptographic-Algorithms/"/>
    
    
    <category term="密码" scheme="https://yngty.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
    <category term="加密" scheme="https://yngty.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Mac 终端设备控制</title>
    <link href="https://yngty.github.io/2025/02/24/macos/Mac-%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6/"/>
    <id>https://yngty.github.io/2025/02/24/macos/Mac-%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6/</id>
    <published>2025-02-24T14:05:09.000Z</published>
    <updated>2025-05-19T02:58:05.397Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;AirDrop&quot;&gt;&lt;a href=&quot;#AirDrop&quot; class=&quot;headerlink&quot; title=&quot;AirDrop&quot;&gt;&lt;/a&gt;AirDrop&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;打开  &lt;figure class=&quot;highlight</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MacOS文件监控</title>
    <link href="https://yngty.github.io/2024/10/25/macos/MacOS%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7/"/>
    <id>https://yngty.github.io/2024/10/25/macos/MacOS%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7/</id>
    <published>2024-10-25T10:25:38.000Z</published>
    <updated>2025-05-19T02:58:05.397Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;1-文件系统事件：文件变动的探测器&quot;&gt;&lt;a href=&quot;#1-文件系统事件：文件变动的探测器&quot; class=&quot;headerlink&quot; title=&quot;1. 文件系统事件：文件变动的探测器&quot;&gt;&lt;/a&gt;1.</summary>
        
      
    
    
    
    <category term="macOS" scheme="https://yngty.github.io/categories/macOS/"/>
    
    
    <category term="macOS" scheme="https://yngty.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Git 备忘录</title>
    <link href="https://yngty.github.io/2024/09/13/git/Git-%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://yngty.github.io/2024/09/13/git/Git-%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2024-09-13T10:38:55.000Z</published>
    <updated>2025-05-19T02:58:05.397Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;如何修改-Git提交历史中的-author-等信息&quot;&gt;&lt;a href=&quot;#如何修改-Git提交历史中的-author-等信息&quot; class=&quot;headerlink&quot; title=&quot;如何修改 Git提交历史中的 author 等信息&quot;&gt;&lt;/a&gt;如何修改</summary>
        
      
    
    
    
    <category term="Git" scheme="https://yngty.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://yngty.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 代理原理</title>
    <link href="https://yngty.github.io/2024/07/22/network/HTTP-%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/"/>
    <id>https://yngty.github.io/2024/07/22/network/HTTP-%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86/</id>
    <published>2024-07-22T14:49:00.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h1&gt;&lt;p&gt;在网络通信中，&lt;code&gt;HTTP&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="http" scheme="https://yngty.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>译 SO_REUSEADDR 和 SO_REUSEPORT 有何不同？</title>
    <link href="https://yngty.github.io/2024/07/18/network/SO-REUSEADDR-%E5%92%8C-SO-REUSEPORT-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>https://yngty.github.io/2024/07/18/network/SO-REUSEADDR-%E5%92%8C-SO-REUSEPORT-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2024-07-18T10:54:35.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Socket-编程中的端口复用：SO-REUSEADDR-和-SO-REUSEPORT&quot;&gt;&lt;a href=&quot;#Socket-编程中的端口复用：SO-REUSEADDR-和-SO-REUSEPORT&quot; class=&quot;headerlink&quot; title=&quot;Socket 编程中的端口复用：SO_REUSEADDR 和 SO_REUSEPORT&quot;&gt;&lt;/a&gt;Socket 编程中的端口复用：SO_REUSEADDR 和 SO_REUSEPORT&lt;/h1&gt;&lt;p&gt;欢迎来到一个充满移植性挑战的世界！在深入分析这两个选项之前，我们首先需要了解 &lt;code&gt;BSD&lt;/code&gt; 套接字实现是所有套接字实现的鼻祖。几乎所有其他系统都在某个时间点复制了 &lt;code&gt;BSD&lt;/code&gt; 套接字实现，或至少是其接口，然后在此基础上发展演变。当然，&lt;code&gt;BSD&lt;/code&gt; 套接字实现本身也在不断演变，因此那些更晚期复制它的系统获得了更早期系统所缺乏的功能。理解 &lt;code&gt;BSD&lt;/code&gt; 套接字实现是理解其他所有套接字实现的关键，即使你不打算为 &lt;code&gt;BSD&lt;/code&gt; 系统编写代码，也应该了解它。&lt;/p&gt;
&lt;p&gt;在深入探讨 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 和 &lt;code&gt;SO_REUSEPORT&lt;/code&gt; 之前，你需要了解一些基本知识。一个 &lt;code&gt;TCP/UDP&lt;/code&gt; 连接由五个值组成的元组标识：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;lt;协议&amp;gt;, &amp;lt;源地址&amp;gt;, &amp;lt;源端口&amp;gt;, &amp;lt;目标地址&amp;gt;, &amp;lt;目标端口&amp;gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;任何唯一的这些值组合标识一个连接。因此，没有两个连接可以具有相同的五个值，否则系统将无法区分这些连接。&lt;/p&gt;
&lt;h2 id=&quot;套接字的基本操作&quot;&gt;&lt;a href=&quot;#套接字的基本操作&quot; class=&quot;headerlink&quot; title=&quot;套接字的基本操作&quot;&gt;&lt;/a&gt;套接字的基本操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建套接字：使用 &lt;code&gt;socket()&lt;/code&gt; 函数设置套接字的协议。&lt;/li&gt;
&lt;li&gt;绑定地址和端口：使用 &lt;code&gt;bind()&lt;/code&gt; 函数设置源地址和端口。&lt;/li&gt;
&lt;li&gt;连接目标地址和端口：使用 &lt;code&gt;connect()&lt;/code&gt; 函数设置目标地址和端口。&lt;br&gt;对于 &lt;code&gt;UDP&lt;/code&gt;，由于它是无连接协议，可以在不连接的情况下使用。然而，在某些情况下连接它是有益的。在无连接模式下，如果未显式绑定，&lt;code&gt;UDP&lt;/code&gt; 套接字通常会在第一次发送数据时由系统自动绑定，因为未绑定的 &lt;code&gt;UDP&lt;/code&gt; 套接字无法接收任何（回复）数据。对于未绑定的 TCP 套接字也是如此，它在连接之前会自动绑定。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="tcp" scheme="https://yngty.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Netfilter 框架浅析</title>
    <link href="https://yngty.github.io/2024/07/11/network/Netfilter-%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://yngty.github.io/2024/07/11/network/Netfilter-%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/</id>
    <published>2024-07-11T17:42:47.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Netfilter&lt;/code&gt;，在 &lt;code&gt;Linux&lt;/code&gt; 内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（&lt;code&gt;NAT&lt;/code&gt;）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如 &lt;code&gt;iptables&lt;/code&gt; 、&lt;code&gt;nftables&lt;/code&gt; 、&lt;code&gt;ebtables&lt;/code&gt; 和 &lt;code&gt;arptables&lt;/code&gt; 等，来控制 &lt;code&gt;Netfilter&lt;/code&gt;，系统管理者可以管理通过Linux操作系统的各种网络数据包。&lt;code&gt;1990&lt;/code&gt; 年代，&lt;code&gt;Netfilter&lt;/code&gt; 在 &lt;code&gt;Linux 2.3.15&lt;/code&gt; 版时进入Linux内核，正式应用于 &lt;code&gt;Linux 2.4&lt;/code&gt; 版。&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="Netfilter" scheme="https://yngty.github.io/tags/Netfilter/"/>
    
  </entry>
  
  <entry>
    <title>TCP-TFO快速打开</title>
    <link href="https://yngty.github.io/2024/03/21/network/TCP-TFO%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80/"/>
    <id>https://yngty.github.io/2024/03/21/network/TCP-TFO%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80/</id>
    <published>2024-03-21T11:25:45.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt; 快速打开（&lt;code&gt;TCP Fast Open&lt;/code&gt;，简称&lt;code&gt;TFO&lt;/code&gt;）是对计算机网络中传输控制协议（&lt;code&gt;TCP&lt;/code&gt;）连接的一种简化握手手续的拓展，用于提高两端点间连接的打开速度。&lt;/p&gt;
&lt;p&gt;它通过握手开始时的 &lt;code&gt;SYN&lt;/code&gt; 包中的 &lt;code&gt;TFO cookie&lt;/code&gt;（一个 &lt;code&gt;TCP&lt;/code&gt; 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 &lt;code&gt;ACK&lt;/code&gt; 包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。这个加密的 &lt;code&gt;Cookie&lt;/code&gt; 被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个 &lt;code&gt;Cookie&lt;/code&gt; 被重复返回。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最显著的优点是可以利用握手去除一个往返 RTT&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;开启-TFO&quot;&gt;&lt;a href=&quot;#开启-TFO&quot; class=&quot;headerlink&quot; title=&quot;开启 TFO&quot;&gt;&lt;/a&gt;开启 TFO&lt;/h1&gt;&lt;p&gt;&lt;code&gt;net.ipv4.tcp_fastopen&lt;/code&gt; 是 &lt;code&gt;Linux&lt;/code&gt; 内核中的一个配置参数，它用于控制 &lt;code&gt;TCP Fast Open&lt;/code&gt; 功能。&lt;br&gt;具体地，&lt;code&gt;net.ipv4.tcp_fastopen&lt;/code&gt; 的值可以是以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;：禁用 &lt;code&gt;TCP Fast Open&lt;/code&gt; 功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;：在客户端启用 &lt;code&gt;TCP Fast Open&lt;/code&gt; 功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt;：在服务器端启用 &lt;code&gt;TCP Fast Open&lt;/code&gt; 功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3&lt;/code&gt;：在客户端和服务器端都启用 &lt;code&gt;TCP Fast Open&lt;/code&gt; 功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过设置这个参数，可以根据实际需求选择是否启用和在哪一端启用 &lt;code&gt;TCP Fast Open&lt;/code&gt;，从而优化网络性能。&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="tcp" scheme="https://yngty.github.io/tags/tcp/"/>
    
    <category term="tfo" scheme="https://yngty.github.io/tags/tfo/"/>
    
  </entry>
  
  <entry>
    <title>网络工具 telnet、 nc、 netstat、ss</title>
    <link href="https://yngty.github.io/2024/03/20/network/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%20telnet%E3%80%81-nc%E3%80%81-netstat/"/>
    <id>https://yngty.github.io/2024/03/20/network/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%20telnet%E3%80%81-nc%E3%80%81-netstat/</id>
    <published>2024-03-20T09:42:47.000Z</published>
    <updated>2025-05-19T02:58:05.399Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;telnet&quot;&gt;&lt;a href=&quot;#telnet&quot; class=&quot;headerlink&quot; title=&quot;telnet&quot;&gt;&lt;/a&gt;&lt;code&gt;telnet&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;检查端口是否打开&quot;&gt;&lt;a href=&quot;#检查端口是否打开&quot; class=&quot;headerlink&quot; title=&quot;检查端口是否打开&quot;&gt;&lt;/a&gt;检查端口是否打开&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;telnet [domainname or ip] [port]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;telnet 220.181.57.216 80&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="tools" scheme="https://yngty.github.io/tags/tools/"/>
    
    <category term="network" scheme="https://yngty.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>MTU与MSS的奥秘</title>
    <link href="https://yngty.github.io/2024/03/18/network/MTU%E4%B8%8EMSS%E7%9A%84%E5%A5%A5%E7%A7%98/"/>
    <id>https://yngty.github.io/2024/03/18/network/MTU%E4%B8%8EMSS%E7%9A%84%E5%A5%A5%E7%A7%98/</id>
    <published>2024-03-18T14:44:24.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;最大传输单元（Maximum-Transmission-Unit-MTU）&quot;&gt;&lt;a href=&quot;#最大传输单元（Maximum-Transmission-Unit-MTU）&quot; class=&quot;headerlink&quot; title=&quot;最大传输单元（Maximum Transmission Unit, MTU）&quot;&gt;&lt;/a&gt;最大传输单元（Maximum Transmission Unit, MTU）&lt;/h1&gt;&lt;p&gt;数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（&lt;code&gt;Maximum Transmission Unit, MTU&lt;/code&gt;）」&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="tcp" scheme="https://yngty.github.io/tags/tcp/"/>
    
    <category term="MTU" scheme="https://yngty.github.io/tags/MTU/"/>
    
    <category term="MSS" scheme="https://yngty.github.io/tags/MSS/"/>
    
  </entry>
  
  <entry>
    <title>QUIC 协议初探</title>
    <link href="https://yngty.github.io/2024/03/08/network/QUIC-%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/"/>
    <id>https://yngty.github.io/2024/03/08/network/QUIC-%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/</id>
    <published>2024-03-08T14:24:01.000Z</published>
    <updated>2025-05-19T02:58:05.398Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Package Type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Long Header Packets&lt;ul&gt;
&lt;li&gt;Version Negotiation Packet&lt;/li&gt;
&lt;li&gt;Initial Packet&lt;/li&gt;
&lt;li&gt;0-RTT</summary>
        
      
    
    
    
    <category term="Network" scheme="https://yngty.github.io/categories/Network/"/>
    
    
    <category term="QUIC" scheme="https://yngty.github.io/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>SUSE Linux 系统记录</title>
    <link href="https://yngty.github.io/2024/03/07/linux/SUSE-Linux-%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/"/>
    <id>https://yngty.github.io/2024/03/07/linux/SUSE-Linux-%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/</id>
    <published>2024-03-07T11:18:01.000Z</published>
    <updated>2025-05-19T02:58:05.397Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近接触到 &lt;code&gt;SUSE Linux&lt;/code&gt; 操作系统，一些命令不一样，这里记录下:&lt;/p&gt;
&lt;h1 id=&quot;包管理器-zypper&quot;&gt;&lt;a href=&quot;#包管理器-zypper&quot; class=&quot;headerlink&quot; title=&quot;包管理器</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt QML 核心概念基础</title>
    <link href="https://yngty.github.io/2024/02/26/qt/Qt-QML-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/"/>
    <id>https://yngty.github.io/2024/02/26/qt/Qt-QML-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-26T09:50:56.000Z</published>
    <updated>2025-05-19T02:58:05.399Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Qt-QML-简介&quot;&gt;&lt;a href=&quot;#Qt-QML-简介&quot; class=&quot;headerlink&quot; title=&quot;Qt QML 简介&quot;&gt;&lt;/a&gt;Qt QML 简介&lt;/h1&gt;&lt;h2 id=&quot;QML-是什么？&quot;&gt;&lt;a href=&quot;#QML-是什么？&quot; class=&quot;headerlink&quot; title=&quot;QML 是什么？&quot;&gt;&lt;/a&gt;QML 是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QML&lt;/code&gt; 是声明式编程语言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QML&lt;/code&gt; 模块 类型库&lt;/li&gt;
&lt;li&gt;内置了 &lt;code&gt;javascript&lt;/code&gt; 运行时环境, 提供逻辑处理： 界面逻辑，业务逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Qt-Quick-是什么？&quot;&gt;&lt;a href=&quot;#Qt-Quick-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Qt Quick 是什么？&quot;&gt;&lt;/a&gt;Qt Quick 是什么？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Qt Quick&lt;/code&gt; 是类型库，提供了可视化 &lt;code&gt;UI&lt;/code&gt; 组件，软件开发框架，用于构建用户界面&lt;/p&gt;</summary>
    
    
    
    <category term="Qt" scheme="https://yngty.github.io/categories/Qt/"/>
    
    
    <category term="QML" scheme="https://yngty.github.io/tags/QML/"/>
    
    <category term="Qt" scheme="https://yngty.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++ Class layout</title>
    <link href="https://yngty.github.io/2024/01/22/c++/C-Class-layout/"/>
    <id>https://yngty.github.io/2024/01/22/c++/C-Class-layout/</id>
    <published>2024-01-22T10:24:40.000Z</published>
    <updated>2025-05-19T02:58:05.394Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;C-Class&quot;&gt;&lt;a href=&quot;#C-Class&quot; class=&quot;headerlink&quot; title=&quot;C++ Class&quot;&gt;&lt;/a&gt;C++ Class&lt;/h1&gt;&lt;p&gt;在类定义中，只有非静态数据声明会增加类对象的大小&lt;/p&gt;
&lt;h1 id=&quot;Empty-Class&quot;&gt;&lt;a href=&quot;#Empty-Class&quot; class=&quot;headerlink&quot; title=&quot;Empty Class&quot;&gt;&lt;/a&gt;Empty Class&lt;/h1&gt;&lt;p&gt;一个空类在C++中没有非静态数据成员、没有虚函数，也没有虚基类。这样的类通常被称为“无状态”，因为它们不封装任何状态或数据。然而，即使一个空类没有显式的数据成员，它仍然需要占用一些内存空间。&lt;/p&gt;
&lt;p&gt;C++标准规定，不同类型的对象必须具有不同的地址。因此，一个空类对象必须在内存中具有唯一的地址。这确保了即使一个空类对象没有任何可见的数据成员或行为，它也必须占用至少一个字节的内存，以区分它与具有不同类型的其他对象。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://yngty.github.io/categories/C-C/"/>
    
    
  </entry>
  
</feed>
