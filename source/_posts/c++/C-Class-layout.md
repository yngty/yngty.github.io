---
title: C++ Class layout
date: 2024-01-22 10:24:40
categories:
- C/C++
---

# C++ Class

在类定义中，只有非静态数据声明会增加类对象的大小


# Empty Class

一个空类在C++中没有非静态数据成员、没有虚函数，也没有虚基类。这样的类通常被称为“无状态”，因为它们不封装任何状态或数据。然而，即使一个空类没有显式的数据成员，它仍然需要占用一些内存空间。

C++标准规定，不同类型的对象必须具有不同的地址。因此，一个空类对象必须在内存中具有唯一的地址。这确保了即使一个空类对象没有任何可见的数据成员或行为，它也必须占用至少一个字节的内存，以区分它与具有不同类型的其他对象。

## C++20 no_unique_address

## Empty Base Class

空基类优化（`Empty Base Class Optimization`，`EBCO`）

- 对于多重继承，重新排列基类的顺序以便空基类首先出现在基类列表上通常是有意义的。
- `C++` 标准并没有规定编译器必须对空基类进行存储优化

# 标准布局类

- `C++` 只为标准布局类型提供布局保证
- 标准布局类型本质上是一种C类型:
    - 标量类型(算术、枚举或指针类型)
    - 具有标准布局类型元素的数组
    - 一个标准布局类(可能声明为结构或联合)

标准布局类可以具有:
- 无虚函数或虚基类
- 标准布局类类型的零个或多个基类。
- 没有两个相同类型的基类
- 标准布局类型的零个或多个非静态数据成员，例如:所有成员具有相同的访问控制，并且
- 所有成员都声明在最派生的类中或在同一个基类中标准布局类- 可以具有非虚和静态成员函数、静态数据成员和嵌套类型

## 布局保证

关于标准布局类的布局，`C++` 只保证:
- 第一个非静态数据成员位于偏移量为零
- 这意味着将指向标准布局类对象的指针 `reinterpret_cast` 转换为指向其第一个非静态数据成员的指针是合理的
- 每一个后续的非静态数据成员的偏移量都大于在它之前声明的非静态数据会员的偏移量
- 类的对象存储在连续内存中
